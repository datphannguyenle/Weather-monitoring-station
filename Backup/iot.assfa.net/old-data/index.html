<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="keywords" content="IoT, ESP8266, IoTs, WoT">
<meta name="author" content="IoT Maker Việt Nam">
<meta name="copyright" content="@2017 IoT Maker VietNam">
<title>Internet Of Things (IoT) : cho người mới bắt đầu</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="book">
<div id="header">
<h1>Internet Of Things (IoT) : cho người mới bắt đầu</h1>
<div class="details">
<span id="author" class="author">IoT Maker Việt Nam</span><br>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_lời_mở_đầu">Lời mở đầu</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Internet Of Things (IoT)</strong> – <strong>Internet vạn vật</strong> dường như đang đứng trước một bước ngoặt để đi đến giai đoạn tiếp theo cho một thế giới hiện đại, văn minh. Đó là viễn cảnh mà mọi vật đều có thể kết nối với nhau thông qua Internet không dây. Các doanh nghiệp đang có xu hướng ứng dụng sản phẩm công nghệ IoT vào sản xuất ngày càng nhiều bởi thị trường sáng tạo tiềm năng và chi phí sản xuất ngày càng thấp.</p>
</div>
<div class="paragraph">
<p>Chứng kiến sự phát triển như vũ bão của các sản phẩm ứng dụng công nghệ IoT và thị trường công nghệ Start up tiềm năng đang ngày càng sôi động hơn bao giờ hết, quyển sách này cung cấp các nội dung về IoT với triết lí Không chỉ là thực tế – không rời rạc, hướng đến những người trẻ tuổi đã, đang và muốn tập trung năng lực của mình cho không gian Internet Of Things. Mong muốn cho ra đời những sản phẩm độc đáo, sáng tạo, ngày càng hoàn thiện và đồng bộ để có thể đáp ứng nhu cầu của cuộc sống.</p>
</div>
<div class="paragraph">
<p>Nội dung được thiết kế một cách cơ bản giúp học viên có cái nhìn tổng quan về việc xây dựng hệ thống, sản xuất thiết bị và dễ dàng tham gia vào lĩnh vực IoT mới mẻ.</p>
</div>
<div class="sect2">
<h3 id="_Đôi_lời_về_tác_giả">Đôi lời về tác giả</h3>
<div class="paragraph">
<p>Chủ biên của cuốn sách là ông <a href="https://twitter.com/tuanpmt">Phạm Minh Tuấn</a>(<a href="https://github.com/tuanpmt">TuanPM</a>), có nhiều năm kinh nghiệm làm việc trong mảng IoT và phát triển các thư viện mã nguồn mở cho cộng đồng. Tác giả xây dựng cuốn sách này với mục đích đóng góp 1 phần nhỏ những kiến thức của mình vào sự phát triển của ngành công nghiệp vẫn còn mới mẻ nhưng rất tiềm năng này.</p>
</div>
</div>
<div class="sect2">
<h3 id="_thuật_ngữ_hay_sử_dụng">Thuật ngữ hay sử dụng</h3>
<div class="ulist">
<ul>
<li>
<p><code>IoT</code> - Internet Of Things hay internet vạn vật.</p>
</li>
<li>
<p><code>ESP8266</code> - Chip xử lí tích hợp thu phát WiFi.</p>
</li>
<li>
<p><code>Git</code> - Trình quản lý phiên bản.</p>
</li>
<li>
<p><code>Github</code> - Mạng xã hội dành cho lập trình viên.</p>
</li>
<li>
<p><code>IDE</code> - Viết tắt của Integrated Development Enviroment - môi trường phát triển tích hợp.</p>
</li>
<li>
<p><code>Compiler</code> - Trình biên dịch.</p>
</li>
<li>
<p><code>Logic Level</code> - Mức điện áp để chip hiểu được (1 hay 0).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_giải_thích_code_trong_bài">Giải thích code trong bài</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void setup()
{
    //comment <i class="conum" data-value="1"></i><b>(1)</b>
    int a = 1;
    a ++; <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dòng này giải thích đây là comment (chú thích).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Dòng này giải thích biến <code>a</code> tăng thêm 1 đơn vị.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_giới_thiệu_nội_dung">Giới thiệu nội dung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nội dung quyển sách này bao gồm các hướng dẫn chi tiết cho người đọc lập trình ứng dụng IoT sử dụng Chip WiFi phổ biến hiện này là ESP8266 để kết nối với Server, gởi, nhận dữ liệu và thực thi các lệnh từ Server. Internet Of Things dựa và các kết nối Internet khá nhiều, do vậy các nội dung cũng tập trung nhiều vào các giao thức (prototcol), các phương pháp quản lý cũng như cấu hình kết nối.</p>
</div>
<div class="paragraph">
<p>Phần cứng sử dụng chính là System On Chip (SoC) <strong>ESP8266</strong> - có khả năng kết nối WiFi và lập trình được với giá thành rẻ và phổ biến trên thế giới. Board mạch sử dụng là board phần cứng mở. <a href="https://github.com/iotmakervn/iot-wifi-uno-hw">IoT WiFi Uno</a> có sơ đồ chân tương thích với các board Arduino Uno.</p>
</div>
<div class="paragraph">
<p>Phần mềm sử dụng lập trên máy tính cho Chip ESP8266 là <a href="https://arduino.cc"><strong>Arduino</strong></a>, ngôn ngữ lập trình <code>C/C++</code>.</p>
</div>
<div class="paragraph">
<p>Các phần liên quan đến Server chạy trên máy tính sử dụng <a href="https://nodejs.org">NodeJS</a> với ngôn ngữ lập trình <code>Javascript</code>.</p>
</div>
<div class="paragraph">
<p>Ngoài ra, bạn sẽ cần tìm hiểu một số công cụ và khái niệm thường xuyên được sử dụng trong quyển sách này như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Git</strong> - Trình quản lý phiên bản sử dụng rất rộng rãi trên thế giới, <strong>Github</strong> là một mạng xã hội cho lập trình viên dựa trên Git. Git giúp bạn quản lý được mã nguồn, làm việc nhóm, xử lý các thao tác hợp nhất, lịch sử mã nguồn &#8230;&#8203; Có thể trong quá trình làm việc với quyển sách này, bạn sẽ cần sử dụng các thư viện mã nguồn mở cho Arduino từ Github, nên việc cài đặt và sử dụng công cụ khá cần thiết cho việc đó. Chưa kể, nó sẽ giúp bạn quản lý mã nguồn và dự án ngày càng chuyên nghiệp hơn.</p>
</li>
<li>
<p><strong>Sublime Text</strong> - Là một trình soạn thảo phổ biến, nhanh, nhẹ và nhiều tính năng hay. Sử dụng để lập trình. Javascript (NodeJS)</p>
</li>
<li>
<p>Code formater - Dùng để định dạng mã nguồn phù hợp, dễ đọc, dễ sửa chữa.</p>
</li>
<li>
<p>Editorconfig - Là một công cụ cộng thêm vào cho các Editor, giúp việc đồng bộ hóa các tiêu chuẩn như Indent, Align, Space &#8230;&#8203; để đảm bảo code khi được mở ở các Editor không bị thay đổi.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Tuy phần cứng chính thức sử dụng là board mạch phần cứng mở <a href="https://github.com/iotmakervn/iot-wifi-uno-hw">IoT WiFi Uno</a>, nhưng bạn hoàn toàn có thể sử dụng bất kỳ board ESP8266 nào khác trên thị trường cho cuốn sách này, ví dụ như: <code>NODEMCU</code>, <code>Wemos</code>, &#8230;&#8203;
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Các nội dung trong quyển sách này tập trung vào hướng dẫn các giao thức, cách thức làm việc với có hệ thống với board ESP8266, Server &#8230;&#8203;, còn các dự án mẫu, hướng dẫn chi tiết có thể tìm thêm tại <strong><a href="https://arduino.esp8266.vn" class="bare">arduino.esp8266.vn</a></strong>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Tất cả các phần Code đều không giải thích rõ chi tiết API cho mỗi tính năng. Mà thay vào đó được cung cấp tại phụ lục Cheat Sheet (Arduino và C).
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_ai_có_thể_sử_dụng">Ai có thể sử dụng?</h3>
<div class="ulist">
<ul>
<li>
<p>Các lập trình viên phần mềm/Mobile App, Web App… muốn tham gia làm sản phẩm <code>IoT</code>.</p>
</li>
<li>
<p>Sinh viên muốn nâng cao kỹ năng, bổ sung kiến thức.</p>
</li>
<li>
<p>Cá nhân muốn tự mình làm các sản phẩm phục vụ cuộc sống, phục vụ công việc.</p>
</li>
<li>
<p>Startup Tech không chuyên về phần cứng hoặc phần mềm.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_mục_tiêu_mang_lại_cho_người_đọc">Mục tiêu mang lại cho người đọc</h3>
<div class="ulist">
<ul>
<li>
<p>Giúp cho người không chuyên về phần cứng tiếp cận để làm sản phẩm IoT dễ dàng.</p>
</li>
<li>
<p>Có thể tự phát triển hệ thống tích hợp cho sản phẩm IoT.</p>
</li>
<li>
<p>Hiểu biết về quy trình tạo ra sản phẩm phần cứng, đi vào mảng sản xuất thiết bị.</p>
</li>
<li>
<p>Tránh những sai sót không đáng có khi phát triển và thiết kế sai hệ thống.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_chuẩn_bị">Chuẩn bị</h3>
<div class="ulist">
<ul>
<li>
<p>Ít nhất bạn cần 1 board mạch ESP8266 lập trình được, tốt nhất nên sử dụng các board mạch tương tích với Arduino IDE (đã có các module nạp cho chip).</p>
</li>
<li>
<p>Nên có thêm các module khác như cảm biến, động cơ để thực hành, một bộ StarterKit là phù hợp.</p>
</li>
<li>
<p>1 máy tính cá nhân (Windows, MacOS hoặc Linux).</p>
</li>
<li>
<p>C &amp; Arduino ESP8266 Cheatsheet (Mục lục cuối quyển sách này).</p>
</li>
</ul>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">Mục lục</div>
<ul class="sectlevel1">
<li><a href="#_lời_mở_đầu">Lời mở đầu</a>
<ul class="sectlevel2">
<li><a href="#_Đôi_lời_về_tác_giả">Đôi lời về tác giả</a></li>
<li><a href="#_thuật_ngữ_hay_sử_dụng">Thuật ngữ hay sử dụng</a></li>
<li><a href="#_giải_thích_code_trong_bài">Giải thích code trong bài</a></li>
</ul>
</li>
<li><a href="#_giới_thiệu_nội_dung">Giới thiệu nội dung</a>
<ul class="sectlevel2">
<li><a href="#_ai_có_thể_sử_dụng">Ai có thể sử dụng?</a></li>
<li><a href="#_mục_tiêu_mang_lại_cho_người_đọc">Mục tiêu mang lại cho người đọc</a></li>
<li><a href="#_chuẩn_bị">Chuẩn bị</a></li>
</ul>
</li>
<li><a href="#_getting_started">Kiến thức cơ bản</a>
<ul class="sectlevel1">
<li><a href="#_internet_of_things_iot">Internet Of Things (IoT)</a>
<ul class="sectlevel2">
<li><a href="#_internet_of_things_iot_là_gì">Internet of Things (IoT) là gì?</a></li>
<li><a href="#_hệ_thống_internet_of_things_iot">Hệ thống Internet of Things (IoT)</a></li>
<li><a href="#_những_ứng_dụng_thực_tế_trong_cuộc_sống">Những ứng dụng thực tế trong cuộc sống</a></li>
</ul>
</li>
<li><a href="#_esp8266">ESP8266</a>
<ul class="sectlevel2">
<li><a href="#_sơ_đồ_chân">Sơ đồ chân</a></li>
<li><a href="#_thông_số_phần_cứng">Thông số phần cứng</a></li>
<li><a href="#_sdk_hỗ_trợ_chính_thức_từ_hãng">SDK hỗ trợ chính thức từ hãng</a></li>
<li><a href="#_esp8285">ESP8285</a></li>
<li><a href="#_module_và_board_mạch_phát_triển">Module và Board mạch phát triển</a></li>
<li><a href="#_board_mạch_phát_triển_esp8266">Board mạch phát triển ESP8266</a></li>
</ul>
</li>
<li><a href="#_arduino_là_gì">Arduino là gì?</a>
<ul class="sectlevel2">
<li><a href="#_một_số_đặc_điểm_của_arduino">Một số đặc điểm của Arduino</a></li>
<li><a href="#_các_lợi_ích_khi_sử_dụng_arduino">Các lợi ích khi sử dụng Arduino</a></li>
<li><a href="#_cộng_đồng_arduino_trên_thế_giới">Cộng đồng Arduino trên thế giới</a></li>
<li><a href="#_arduino_cho_esp8266_board_mạch_esp8266_wifi_uno">Arduino cho ESP8266 &amp; board mạch ESP8266 WiFi Uno</a></li>
</ul>
</li>
<li><a href="#_node_js">Node.js</a>
<ul class="sectlevel2">
<li><a href="#_lý_do_sử_dụng_node_js_trong_cuốn_sách_này">Lý do sử dụng Node.js trong cuốn sách này</a></li>
<li><a href="#_cuốn_sách_này_có_hướng_dẫn_node_js">Cuốn sách này có hướng dẫn Node.js ?</a></li>
</ul>
</li>
<li><a href="#_sublime_text">Sublime Text</a></li>
<li><a href="#_cài_đặt_và_chuẩn_bị">Cài đặt và chuẩn bị</a>
<ul class="sectlevel2">
<li><a href="#_arduino_ide">Arduino IDE</a></li>
<li><a href="#install-library">Cài đặt thư viện Arduino</a></li>
<li><a href="#_usb_cdc_driver">USB CDC driver.</a></li>
<li><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></li>
<li><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></li>
<li><a href="#export-binary">Xuất firmware binary trong Arduino IDE</a></li>
<li><a href="#_serial_terminal">Serial Terminal</a></li>
<li><a href="#_node_js_2">Node.js</a></li>
<li><a href="#_sublime_text_2">Sublime Text</a></li>
<li><a href="#_git">Git</a></li>
</ul>
</li>
<li><a href="#_tổng_kết">Tổng kết</a></li>
</ul>
</li>
<li><a href="#_hello_world">Hello World</a>
<ul class="sectlevel1">
<li><a href="#_chớp_tắt_bóng_led">Chớp tắt bóng LED</a>
<ul class="sectlevel2">
<li><a href="#_kiến_thức">Kiến thức</a></li>
<li><a href="#_Đấu_nối">Đấu nối</a></li>
<li><a href="#_mã_nguồn_chớp_tắt_dùng_delay">Mã nguồn chớp tắt dùng Delay</a></li>
<li><a href="#_mã_nguồn_chớp_tắt_dùng_định_thời">Mã nguồn chớp tắt dùng định thời</a></li>
<li><a href="#_digital_io">Digital IO</a></li>
<li><a href="#_tổng_kết_2">Tổng kết</a></li>
<li><a href="#_kiến_thức_2">Kiến thức</a></li>
<li><a href="#_mã_nguồn_dùng_hỏi_vòng">Mã nguồn dùng hỏi vòng</a></li>
<li><a href="#_mã_nguồn_dùng_ngắt">Mã nguồn dùng ngắt</a></li>
<li><a href="#_các_khái_niệm">Các khái niệm</a></li>
</ul>
</li>
<li><a href="#_oled">OLED</a>
<ul class="sectlevel2">
<li><a href="#_màn_hình_oled">Màn hình OLED</a></li>
<li><a href="#_màn_hình_oled_ssd1306">Màn hình OLED SSD1306</a></li>
<li><a href="#_giao_tiếp_i2c">Giao tiếp I2C</a></li>
<li><a href="#_hiển_thị_màn_hình_oled_với_esp8266">Hiển thị màn hình OLED với ESP8266</a></li>
</ul>
</li>
<li><a href="#_tổng_kết_3">Tổng kết</a></li>
</ul>
</li>
<li><a href="#_wifi">ESP8266 WiFi</a>
<ul class="sectlevel1">
<li><a href="#_chế_độ_wifi_station">Chế độ WiFi Station</a>
<ul class="sectlevel2">
<li><a href="#_kiến_thức_3">Kiến thức</a></li>
<li><a href="#_kết_nối_vào_mạng_wifi_nội_bộ">Kết nối vào mạng WiFi nội bộ</a></li>
<li><a href="#_sử_dụng_wifimulti">Sử dụng WiFiMulti</a></li>
</ul>
</li>
<li><a href="#_http_client">HTTP Client</a>
<ul class="sectlevel2">
<li><a href="#_giao_thức_http">Giao thức HTTP</a></li>
<li><a href="#_json">JSON</a></li>
<li><a href="#_Ứng_dụng_xem_giá_bitcoin">Ứng dụng xem giá Bitcoin</a></li>
</ul>
</li>
<li><a href="#_chế_độ_wifi_access_point">Chế độ WiFi Access Point</a>
<ul class="sectlevel2">
<li><a href="#_esp8266_hoạt_động_ở_chế_độ_access_point">ESP8266 hoạt động ở chế độ Access Point</a></li>
<li><a href="#_khởi_tạo_mạng_wifi_sử_dụng_esp8266">Khởi tạo mạng WiFi sử dụng ESP8266</a></li>
</ul>
</li>
<li><a href="#web-server">Web Server</a>
<ul class="sectlevel2">
<li><a href="#_web_server_là_gì">Web Server là gì?</a></li>
<li><a href="#_html_javascript_css">HTML - Javascript - CSS</a></li>
<li><a href="#_Ứng_dụng_điều_khiển_đèn_led_thông_qua_webserver">Ứng dụng điều khiển đèn LED thông qua Webserver</a></li>
<li><a href="#_esp8266_web_server">ESP8266 Web Server</a></li>
<li><a href="#_kết_hợp_wifi_ap_và_web_server">Kết hợp WiFi AP và Web Server</a></li>
</ul>
</li>
<li><a href="#_trao_đổi_dữ_liệu_giữa_2_esp8266">Trao đổi dữ liệu giữa 2 ESP8266</a>
<ul class="sectlevel2">
<li><a href="#_yêu_cầu">Yêu cầu</a></li>
<li><a href="#_hướng_dẫn_thực_hiện">Hướng dẫn thực hiện</a></li>
<li><a href="#_code">Code</a></li>
</ul>
</li>
<li><a href="#_tổng_kết_4">Tổng kết</a></li>
</ul>
</li>
<li><a href="#_DHT11_logger">Dự án đọc cảm biến DHT11 và gởi về Server</a>
<ul class="sectlevel1">
<li><a href="#_thiết_kế_ứng_dụng">Thiết kế ứng dụng</a>
<ul class="sectlevel2">
<li><a href="#_yêu_cầu_2">Yêu cầu</a></li>
<li><a href="#_phân_tích">Phân tích</a></li>
<li><a href="#_kiến_thức_4">Kiến thức</a></li>
<li><a href="#_thực_hiện">Thực hiện</a></li>
</ul>
</li>
<li><a href="#server-nodejs">Server Nodejs</a></li>
<li><a href="#_code_esp8266">Code ESP8266</a>
<ul class="sectlevel2">
<li><a href="#_chuẩn_bị_2">Chuẩn bị</a></li>
</ul>
</li>
<li><a href="#_Ứng_dụng_mở_rộng">Ứng dụng mở rộng</a>
<ul class="sectlevel2">
<li><a href="#_dùng_esp8266_như_1_web_server">Dùng ESP8266 như 1 Web Server</a></li>
</ul>
</li>
<li><a href="#_tổng_kết_5">Tổng kết</a></li>
</ul>
</li>
<li><a href="#_wifi_config">Các chế độ cấu hình WiFi</a>
<ul class="sectlevel1">
<li><a href="#_smartconfig">Smartconfig</a>
<ul class="sectlevel2">
<li><a href="#_kiến_thức_5">Kiến thức</a></li>
<li><a href="#_thực_hiện_smartconfig_với_esp8266">Thực hiện SmartConfig với ESP8266</a></li>
<li><a href="#_code_2">Code</a></li>
</ul>
</li>
<li><a href="#_wps">WPS</a>
<ul class="sectlevel2">
<li><a href="#_wps_là_gì">WPS là gì?</a></li>
<li><a href="#_thực_hiện_wps_với_esp8266">Thực hiện WPS với ESP8266</a></li>
<li><a href="#_code_3">Code</a></li>
</ul>
</li>
<li><a href="#_wifi_manager">Wifi Manager</a>
<ul class="sectlevel2">
<li><a href="#_hoạt_động_cơ_bản_wifimanager">Hoạt động cơ bản WifiManager</a></li>
<li><a href="#_chuẩn_bị_3">Chuẩn bị</a></li>
<li><a href="#_code_4">Code</a></li>
<li><a href="#_mở_rộng">Mở rộng</a></li>
</ul>
</li>
<li><a href="#_tổng_kết_6">Tổng kết</a></li>
</ul>
</li>
<li><a href="#_mqtt">MQTT</a>
<ul class="sectlevel2">
<li><a href="#_publish_subscribe">Publish, subscribe</a></li>
<li><a href="#_qos">QoS</a></li>
<li><a href="#_retain">Retain</a></li>
<li><a href="#_lwt">LWT</a></li>
<li><a href="#_mqtt_client">MQTT Client</a>
<ul class="sectlevel2">
<li><a href="#_mqtt_lens">MQTT Lens</a></li>
<li><a href="#_mqtt_js">MQTT.js</a></li>
<li><a href="#_esp8266_mqtt_client">ESP8266 MQTT Client</a></li>
</ul>
</li>
<li><a href="#_mqtt_broker">MQTT Broker</a>
<ul class="sectlevel2">
<li><a href="#_mosca">MOSCA</a></li>
<li><a href="#_một_số_mqtt_broker_sử_dụng_cho_sản_phẩm_thực_tế">Một số MQTT Broker sử dụng cho sản phẩm thực tế</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tổng_kết_7">Tổng kết</a></li>
<li><a href="#_websocket">Websocket</a>
<ul class="sectlevel2">
<li><a href="#_Ưu_điểm">Ưu điểm</a></li>
<li><a href="#_nhược_điểm">Nhược điểm</a></li>
<li><a href="#_sử_dụng_esp8266_như_websocket_server">Sử dụng ESP8266 như Websocket Server</a>
<ul class="sectlevel2">
<li><a href="#_yêu_cầu_3">Yêu cầu</a></li>
<li><a href="#_chuẩn_bị_4">Chuẩn bị</a></li>
<li><a href="#_Đoạn_code_javascript_để_tạo_kết_nối_web_socket">Đoạn code Javascript để tạo kết nối Web Socket</a></li>
<li><a href="#_nhúng_file_html_chứa_đoạn_code_js_vào_esp8266">Nhúng file HTML chứa đoạn code JS vào ESP8266</a></li>
<li><a href="#_chương_trình_hoàn_chỉnh_cho_esp8266">Chương trình hoàn chỉnh cho ESP8266</a></li>
<li><a href="#_kết_quả_2">Kết quả</a></li>
<li><a href="#_video_kết_quả">Video kết quả</a></li>
</ul>
</li>
<li><a href="#_sử_dụng_esp8266_như_websocket_client">Sử dụng ESP8266 như Websocket Client</a>
<ul class="sectlevel2">
<li><a href="#_javascript_websocket_client_trên_trình_duyệt">Javascript Websocket Client trên trình duyệt</a></li>
<li><a href="#_node_js_websocket_server">Node.js Websocket Server</a></li>
<li><a href="#_esp8266_websocket_client">ESP8266 Websocket Client</a></li>
</ul>
</li>
<li><a href="#_tổng_kết_8">Tổng kết</a></li>
</ul>
</li>
<li><a href="#_fota">Firmware update over the air (FOTA)</a>
<ul class="sectlevel1">
<li><a href="#_cập_nhật_firmware_từ_xa">Cập nhật firmware từ xa</a>
<ul class="sectlevel2">
<li><a href="#_bảo_mật">Bảo mật</a></li>
<li><a href="#_an_toàn">An toàn</a></li>
<li><a href="#_yêu_cầu_căn_bản">Yêu cầu căn bản</a></li>
<li><a href="#_update_process_memory_view">Update process - memory view</a></li>
</ul>
</li>
<li><a href="#_ota_sử_dụng_arduino_ide">OTA sử dụng Arduino IDE</a>
<ul class="sectlevel2">
<li><a href="#ota-step1">Bước 1: nạp firmware hỗ trợ OTA thông qua cổng Serial</a></li>
<li><a href="#_bước_2_lựa_chọn_cổng_nạp_thông_qua_ota">Bước 2: Lựa chọn cổng nạp thông qua OTA</a></li>
<li><a href="#_bước_3_sửa_firmware_mới_và_nạp_lại_thông_qua_wifi">Bước 3: Sửa firmware mới và nạp lại thông qua WiFi</a></li>
<li><a href="#_sử_dụng_mật_khẩu">Sử dụng mật khẩu</a></li>
<li><a href="#_những_sự_cố_thường_gặp">Những sự cố thường gặp</a></li>
</ul>
</li>
<li><a href="#_cập_nhật_firmware_dùng_web_browser">Cập nhật Firmware dùng Web Browser</a>
<ul class="sectlevel2">
<li><a href="#_thực_hiện_2">Thực hiện</a></li>
<li><a href="#_bảo_mật_2">Bảo mật</a></li>
</ul>
</li>
<li><a href="#_http_server">HTTP Server</a>
<ul class="sectlevel2">
<li><a href="#esp8266-ESPhttpUpdate">ESP8266 ESPhttpUpdate</a></li>
</ul>
</li>
<li><a href="#_node_js_ota_server">Node.js OTA Server</a></li>
</ul>
</li>
<li><a href="#_cheat_sheet">Cheatsheet</a>
<ul class="sectlevel1">
<li><a href="#_arduino_esp8266_cheatsheet">Arduino - ESP8266 Cheatsheet</a></li>
<li><a href="#_c_cheatsheet">C - Cheatsheet</a></li>
</ul>
</li>
<li><a href="#_contributors">Lời kết</a>
<ul class="sectlevel2">
<li><a href="#_các_thành_viên_tham_gia_đóng_góp">Các thành viên tham gia đóng góp.</a></li>
<li><a href="#_lời_kết">Lời kết.</a></li>
<li><a href="#_giấy_phép_sử_dụng_tài_liệu">Giấy phép sử dụng tài liệu.</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="_getting_started" class="sect0">Kiến thức cơ bản</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Trong phần này, chúng ta sẽ bắt đầu bằng việc tìm hiểu tổng quan về hệ thống <strong>IoT</strong>, tổng quan về dòng chip <strong>ESP8266</strong>, rồi đến việc cài đặt công cụ phát triển <strong>Arduino</strong> trên máy tính của bạn. Tiếp đến là việc biên dịch các dự án mẫu, lựa chọn trình thư viện, trình soạn thảo sẽ làm việc. Kết thúc chương này chúng ta sẽ có được cái nhìn tổng quát về hệ thống IoT, làm thế nào và sử dụng công cụ gì để lập trình ứng dụng với ESP8266.</p>
</div>
<div class="paragraph">
<p>Điểm qua phần này như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IoT</code> và ứng dụng thực tế.</p>
</li>
<li>
<p>Tìm hiểu về chip WiFi <code>ESP8266</code>.</p>
</li>
<li>
<p><code>Arduino IDE</code> và sử dụng Arduino với ESP8266.</p>
</li>
<li>
<p><code>Starter Kit</code> bộ công cụ khởi động việc học lập trình <code>IoT</code>.</p>
</li>
<li>
<p><code>Node.js - Javascript</code> ngôn ngữ lập trình Server Side.</p>
</li>
<li>
<p><code>Cài đặt</code> tất cả các công cụ.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Với những ai đã từng hiểu rõ ESP8266, đã từng làm về hệ thống IoT, đã chuyên nghiệp trong lập trình <strong>C/C++</strong> có thể bỏ qua chương này.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_internet_of_things_iot">Internet Of Things (IoT)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_internet_of_things_iot_là_gì">Internet of Things (IoT) là gì?</h3>
<div class="quoteblock">
<blockquote>
Internet of Things (IoT) - Mạng lưới vạn vật kết nối Internet là một kịch bản của thế giới, khi mà mỗi đồ vật, con người được cung cấp một định danh của riêng mình, và tất cả có khả năng truyền tải, trao đổi thông tin, dữ liệu qua một mạng duy nhất mà không cần đến sự tương tác trực tiếp giữa người với người, hay người với máy tính. IoT đã phát triển từ sự hội tụ của công nghệ không dây, công nghệ vi cơ điện tử và Internet[1]. Nói đơn giản là một tập hợp các thiết bị có khả năng kết nối với nhau, với Internet và với thế giới bên ngoài để thực hiện một công việc nào đó.
<strong>Link</strong>: <a href="http://vi.wikipedia.org/wiki/Mạng_lưới_vạn_vật_kết_nối_Internet" class="bare">vi.wikipedia.org/wiki/Mạng_lưới_vạn_vật_kết_nối_Internet</a>
</blockquote>
<div class="attribution">
&#8212; Wikipedia
</div>
</div>
<div class="paragraph">
<p>Internet of things (IoT) dùng để chỉ các đối tượng có thể được nhận biết cũng như chỉ sự tồn tại của chúng trong một kiến trúc tổng hòa mang tính kết nối: Mạng lưới vạn vật kết nối Internet, hay gọi đơn giản hơn là <code>Things</code>.</p>
</div>
<div class="paragraph">
<p>IoT có thể là bộ cảm ứng được lắp ráp trong một chiếc tủ lạnh để ghi lại nhiệt độ, là một trái tim được cấy ghép trong cơ thể con người,&#8230;&#8203; Hiểu đơn giản, IoT có thể khiến mọi vật giờ đây có thể giao tiếp với nhau dễ dàng hơn và ưu điểm lớn nhất của <code>“Thông minh”</code> là khả năng phòng ngừa và cảnh báo tại bất kì đâu.</p>
</div>
<div class="paragraph">
<p>Cụm từ Internet of things được đưa ra bởi Kevin Ashton vào năm 1999, tiếp sau đó nó cũng được dùng nhiều trong các ấn phẩm đến từ các hãng và nhà phân tích. Họ cho rằng IoT là một hệ thống phức tạp, bởi nó là một lượng lớn các đường liên kết giữa máy móc, thiết bị và dịch vụ với nhau. Ban đầu, IoT không mang ý nghĩa tự động và thông minh. Về sau, người ta đã nghĩ đến khả năng kết hợp giữa hai khái niệm IoT - Autonomous control lại với nhau. Nó có thể quan sát sự thay đổi và phản hồi với môi trường xung quanh, cũng có thể tự điều khiển bản thân mà không cần kết nối mạng. Việc tích hợp trí thông minh vào IoT còn có thể giúp các thiết bị, máy móc, phần mềm thu thập và phân tích các dữ liệu điện tử của con người khi chúng ta tương tác với chúng. Xu hướng tất yếu trong tương lai, con người có thể giao tiếp với máy móc chỉ qua mạng internet không dây mà không cần thêm bất cứ hình thức trung gian nào khác.</p>
</div>
<div class="paragraph">
<p>Câu hỏi đặt ra là, điều gì giúp IoT “thông minh” và “hiểu” con người? Ban đầu, người ta cho rằng Internet của vạn vật chủ yếu xoay quanh giao tiếp M2M (các thiết bị kết nối với nhau thông qua một thiết bị khác điều khiển). Nhưng khi hướng đến sự “thông minh hóa”, đó không chỉ là giao tiếp giữa M2M nữa mà cần phải đề cập đến các cảm biến (sensor). Và cũng đừng lầm tưởng rằng Sensor là một cỗ máy hoạt động dưới sự vận hành của các thiết bị khác mà thực chất, nó tương tự như đôi mắt và đôi tai của loài người với sự ghi nhận liên tục những đo lường, định lượng, thu thập dữ liệu từ thế giới bên ngoài. Suy cho cùng, Internet of things đem đến sự kết nối giữa máy móc và cảm biến, và nhờ đến dữ liệu điện toán đám mây để mã hóa dữ liệu. Những ứng dụng điện toán đám mây là mắt xích quan trọng giúp cho Internet of things có thể hoạt động nhờ sự phân tích, xử lí và sử dụng dữ liệu mà các cảm biến thu thập được.</p>
</div>
<div class="paragraph">
<p>Tình hình trên thế giới hiện nay, tác động của IOT rất đa dạng và tích cực ở nhiều lĩnh vực: quản lý hạ tầng, y tế, xây dựng và tự động hóa, giao thông…. John Chambers (CEO của Cisco) đã công bố: Cho đến năm 2024 sẽ có 500 tỷ thiết bị được kết nối. Thực tế, con số này lớn hơn gần 100 lần số người trên Trái đất, điều đó cho thấy “vạn vật” nhiều hơn con người rất nhiều. Chúng ta đều biết ứng dụng IoT có thể “nói chuyện” với con người thông qua bàn phím, thiết bị cũng được thiết kế ngày càng hoàn thiện với nhiều cảm biến hơn để có thể giao tiếp một cách nhanh nhất và chính xác nhất với con người, thu thập dữ liệu đơn giản từ mỗi người chúng ta. Nhưng quan trọng nhất, tuy giao tiếp với con người nhưng ứng dụng IoT không phải là con người.</p>
</div>
<div class="paragraph">
<p>Người ta cho rằng, IoT là chìa khóa của sự thành công, là bước ngoặt và cơ hội lớn của tương lai. Để không bị tụt lại phía sau, các chính phủ và doanh nghiệp cần có sự đổi mới và đầu tư mạnh tay hơn để phát triển các sản phẩm ứng dụng công nghệ Internet of things.</p>
</div>
<div class="paragraph">
<p>Các hashtag: <a href="https://www.google.com/search?q=iot"><strong>#IoT</strong></a> <a href="https://www.google.com/search?q=iot"><strong>#InternetOfThings</strong></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_hệ_thống_internet_of_things_iot">Hệ thống Internet of Things (IoT)</h3>
<div class="paragraph">
<p>Hệ thống IoT cho phép người dùng tiến sâu hơn vào việc tự động hóa, phân tích, tích hợp. Giúp cho việc cải thiện tầm nhìn, tính chính xác, nâng tầm các công nghệ về cảm biến, kết nối, robot để đạt hiệu quả cao nhất.</p>
</div>
<div class="paragraph">
<p>Các hệ thống IoT phát triển, khai thác các tiến bộ của phần mềm, giảm giá thành khi xây dụng phần cứng và tận dụng các công nghệ hiện đại. Những cải tiến này làm thay đổi cách vận hành của quá trình sản xuất sản phẩm, dịch vụ, xã hội, kinh tế và ảnh hưởng đến cả chính trị</p>
</div>
<div class="sect3">
<h4 id="_những_điểm_mấu_chốt_của_iot">Những điểm mấu chốt của IoT</h4>
<div class="paragraph">
<p>Những vấn đề quan trọng nhất của hệ thống IoT bao gồm trí thông minh nhân tạo, kết nối, cảm biến và các thiết bị nhỏ nhưng mang tính cơ động cao, chúng được mô tả sơ lược như bên dưới:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>AI (Artifical Intelligence)</strong> - Hệ thống IoT về cơ bản được hiểu là làm cho mọi thiết bị trở nên <strong>thông minh</strong>, nghĩa là nó giúp nâng cao mọi khía cạnh của cuộc sống bằng những dữ liệu thu thập được, thông qua các thuật toán tính toán nhân tạo và kết nối mạng. Một ví dụ đơn giản như hộp đựng gạo của bạn, khi biết rằng gạo sắp hết, hệ thống tự động đặt một đơn hàng mới cho nhà cung cấp.</p>
</li>
<li>
<p><strong>Connectivity</strong> - Là một đặc trưng cơ bản của IoT, hiện nay các mạng thiết bị đang trở nên phổ biến, nhiều mạng thiết bị ngày càng nhỏ hơn, rẻ hơn và được phát triển phù hợp với thực tế cũng như nhu cầu của người dùng .</p>
</li>
<li>
<p><strong>Sensors</strong> - IoT sẽ mất đi sự quan trọng của mình nếu không có sensors. Các cảm biến hoạt động giống như một công cụ giúp IoT chuyển từ mạng lưới các thiết bị thụ động sang mạng lưới các thiết bị tích cực, đồng thời có thể tương tác với thế giới thực.</p>
</li>
<li>
<p><strong>Active Engagement</strong> Ngày nay, phần lớn các tương tác của những công nghệ kết nối xảy ra 1 cách thụ động. IoT được cho là sẽ đem đến những hệ thống mang tích tích cực về nội dung, sản phẩm cũng như các dịch vụ gắn kết.</p>
</li>
<li>
<p><strong>Small Devices</strong> - Như đã được dự đoán từ trước, các thiết bị ngày càng được tối ưu với mục đích nâng cao độ chính xác, khả năng mở rộng cũng như tính linh hoạt. Nó được thiết kế ngày càng nhỏ hơn, rẻ hơn và mạnh mẽ hơn theo thời gian.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_iot_những_lợi_ích_mang_lại">IoT − Những lợi ích mang lại</h4>
<div class="paragraph">
<p>Những lợi ích mà IoT đem lại được dàn trải hầu hết đến các tất cả các lĩnh vực trong đời sống, kinh doanh&#8230;&#8203; Dưới đây liệt kê ngắn gọn một số tính năng hữu ích của IoT:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cải thiện việc gắn kết khách hàng</strong> - Hệ thống IoT giúp phân tích các điểm mù hiện tại, tìm ra những sai sót về độ chính xác. IoT thay đổi điều này để mang lại nhiều sự gắn kết hơn và hiệu quả hơn với người dùng. Một ứng dụng tại các cửa hàng, dịch vụ iBeacon giúp tăng số lượng sản phẩm tới người tiêu dùng bằng cách chỉ dẫn người dùng tới khu vực cụ thể trong cửa hàng và đưa ra các gợi ý về sản phẩm. Chúng cung cấp các thông tin chi tiết, các đánh giá về sản phẩm,  &#8230;&#8203;Bên cạnh đó chúng cũng có khả năng cho phép người dùng chia sẻ các sản phẩm qua mạng xã hội &#8230;&#8203;</p>
</li>
<li>
<p><strong>Tối ưu hóa công nghệ</strong> - giúp nâng cao trải nghiệm của khách hàng cũng như cải thiện việc sử dụng thiết bị và hỗ trợ cải tiến công nghệ.</p>
</li>
<li>
<p><strong>Giảm sự hao phí</strong> - IoT giúp việc quản lí tài nguyên ở các lĩnh vực được cải thiện 1 cách rõ ràng. Các phân tích hiện tại thường cung cấp cho chúng ta cái nhìn ở khía cạnh bên ngoài, trong khi IoT cung cấp các dữ liêu, thông tin thực tế để quản lí tài nguyên một cách hiệu quả hơn.</p>
</li>
<li>
<p><strong>Tăng cường việc thu thập dữ liệu</strong> - Thông thường, việc thu thập dữ liệu bị hạn chế do thiết kế hệ thống mang tính thụ động. IoT phá vỡ sự ràng buộc, giới hạn của thiết kế và tạo ra 1 hình ảnh chính xác của tất cả mọi thứ.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_iot_những_thách_thức_gặp_phải">IoT − Những thách thức gặp phải</h4>
<div class="paragraph">
<p>Mặc dù IoT mang lại khá nhiều lợi ích ấn tượng, nó cũng gặp phải những thách thức đáng kể. Dưới đây là 1 số vấn đề chính của IoT :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kiểm soát an ninh</strong> - IoT tạo ra 1 hệ sinh thái mà ở đó các thiết bị kết nối liên tục và giao tiếp với nhau qua mạng lưới các kết nối. Tuy nhiên, hệ thống thường chưa chú trọng đến các biện pháp an ninh nhằm bảo mật thông tin, dẫn đến nó có thể gặp phải các cuộc tấn công nhằm lấy cắp thông tin của người dùng.</p>
</li>
<li>
<p><strong>Tính bảo mật</strong> - Do tính bảo mật chưa cao cộng với bản chất của IoT là không cần nhiều sự tương tác của con người nên các kẻ tấn công có thể cung cấp các thông tin người dùng giả mạo.</p>
</li>
<li>
<p><strong>Tính phức tạp</strong> - Một số hệ thống IoT có độ phức tạp về thiết kế và triển khai ứng dụng cũng như khó khăn trong việc bảo trì, nâng cấp  hệ thống do sử dụng nhiều công nghệ còn khá mới mẻ.</p>
</li>
<li>
<p><strong>Tính linh hoạt</strong> - Có nhiều sự lo ngại khi đề cập đến tính linh hoạt của hệ thống IoT khi tích hợp với các hệ thống khác bởi các hệ thống khi kết hợp có thể xảy ra xung đột và các tính năng sẽ bị khóa lẫn nhau.</p>
</li>
<li>
<p><strong>Tuân thủ các tiêu chuẩn</strong> - Giống như các công nghệ khác trong lĩnh vực thương mại, IoT cũng phải tuân thủ các tiêu chuẩn, quy định đã đặt ra trước đó. Tính phức tạp của IoT làm cho việc tuân thủ các tiêu chuẩn là một thử thách thực sự</p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/01-intro/01.iot-concept.png" alt="Hình minh họa IoT" width="500">
</div>
<div class="title">Hình 1. Hình minh họa</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/01.iot_growth_technology.png" alt="Sự phát triển của iot dự đoán đến năm 2020" width="500">
</div>
<div class="title">Hình 2. Sự phát triển của iot dự đoán đến năm 2020</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_những_ứng_dụng_thực_tế_trong_cuộc_sống">Những ứng dụng thực tế trong cuộc sống</h3>
<div class="paragraph">
<p>Những ứng dụng của IoT vào các lĩnh vực trong đời sống là vô cùng phong phú và đa dạng. Chúng ta sẽ cùng điểm qua một số ứng dụng điển hình đã mang lại <code>"tiếng tăm"</code> cho IoT:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Smart Home</strong> - Theo thống kê, smart home là ứng dụng liên quan đến IoT được tìm kiếm nhiều nhất trên Google. Smart Home là 1 ngôi nhà với rất nhiều tính năng tự động như bật máy điều không khí khi bạn sắp về tới nhà, tắt đèn ngay khi bạn rời khỏi nhà, mở khóa khi người thân trong gia đình đang ở cửa nhà, mở garage khi bạn lái xe đi làm về &#8230;&#8203; còn rất nhiều những tính năng giúp nâng cao chất lượng cuộc sống khi sử dụng smart home.</p>
</li>
<li>
<p><strong>Vật dụng mang theo trên người</strong> - Có thể kể đến một số thiết bị như <code>Dashbon Mask</code>, đây là 1 chiếc smart headphone giúp bạn vừa có thể nghe nhạc với âm thanh có độ trung thực cao vừa có thể xem phim HD với máy chiếu ảo , hoặc <code>AMPL SmartBag</code> ba lô có pin dự phòng có thể sạc điện cho các thiết bị di động, kể cả máy tính.</p>
</li>
<li>
<p><strong>Connected cars</strong> - Giúp nâng cao những trải nghiệm cho người dùng xe ôtô, 1 chiếc <code>Connected car</code> có thể tối ưu các hoạt động của nó như thông báo khi hết nhiên liệu, đưa ra các cảnh báo khi có vật tới gần hoặc mới đây nhất là xe điện tự lái của hãng Tesla&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_esp8266">ESP8266</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ESP8266 là dòng chip tích hợp Wi-Fi 2.4Ghz có thể lập trình được, rẻ tiền được sản xuất bởi một công ty bán dẫn Trung Quốc: Espressif Systems.</p>
</div>
<div class="paragraph">
<p>Được phát hành đầu tiên vào tháng 8 năm 2014, đóng gói đưa ra thị trường dạng Mô dun ESP-01, được sản xuất bởi bên thứ 3: AI-Thinker. Có khả năng kết nối Internet qua mạng Wi-Fi một cách nhanh chóng và sử dụng rất ít linh kiện đi kèm. Với giá cả có thể nói là rất rẻ so với tính năng và khả năng ESP8266 có thể làm được.</p>
</div>
<div class="paragraph">
<p>ESP8266 có một cộng đồng các nhà phát triển trên thế giới rất lớn, cung cấp nhiều Module lập trình mã nguồn mở giúp nhiều người có thể tiếp cận và xây dựng ứng dụng rất nhanh.</p>
</div>
<div class="paragraph">
<p>Hiện nay tất cả các dòng chip ESP8266 trên thị trường đều mang nhãn ESP8266EX, là phiên bản nâng cấp của ESP8266</p>
</div>
<div class="sect2">
<h3 id="_sơ_đồ_chân">Sơ đồ chân</h3>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/01.esp8266-soc.svg" alt="Sơ đồ chân ESP8266EX" width="500">
</div>
<div class="title">Hình 3. Sơ đồ chân ESP8266EX</div>
</div>
</div>
<div class="sect2">
<h3 id="_thông_số_phần_cứng">Thông số phần cứng</h3>
<div class="ulist">
<ul>
<li>
<p>32-bit RISC CPU : Tensilica Xtensa LX106 chạy ở xung nhịp 80 MHz</p>
</li>
<li>
<p>Hổ trợ Flash ngoài từ 512KiB đến 4MiB</p>
</li>
<li>
<p>64KBytes RAM thực thi lệnh</p>
</li>
<li>
<p>96KBytes RAM dữ liệu</p>
</li>
<li>
<p>64KBytes boot ROM</p>
</li>
<li>
<p>Chuẩn wifi EEE 802.11 b/g/n, Wi-Fi 2.4 GHz</p>
<div class="ulist">
<ul>
<li>
<p>Tích hợp TR switch, balun, LNA, khuếch đại công suất và matching network</p>
</li>
<li>
<p>Hổ trợ WEP, WPA/WPA2, Open network</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tích hợp giao thức TCP/IP</p>
</li>
<li>
<p>Hổ trợ nhiều loại anten</p>
</li>
<li>
<p>16 chân GPIO</p>
</li>
<li>
<p>Hổ trợ SDIO 2.0, UART, SPI, I²C, PWM,I²S với DMA</p>
</li>
<li>
<p>1 ADC 10-bit</p>
</li>
<li>
<p>Dải nhiệt độ hoạt động rộng : -40C ~ 125C</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/01.ESP-12E.jpg" alt="Module ESP12E" width="300">
</div>
<div class="title">Hình 4. Một module tích hợp phổ biến (Module ESP12E)</div>
</div>
</div>
<div class="sect2">
<h3 id="_sdk_hỗ_trợ_chính_thức_từ_hãng">SDK hỗ trợ chính thức từ hãng</h3>
<div class="paragraph">
<p>Espressif hiện đã hỗ trợ 3 nền tảng SDK (Software Development Kit - Gói phát triển phần mềm) độc lập, là: <strong>NONOS SDK</strong>, <strong>RTOS SDK</strong> và <strong>Arduino</strong>. Cả 3 đều có những ưu điểm riêng phù hợp với từng ứng dụng nhất định, và sử dụng chung nhiều các hàm điều khiển phần cứng. Hiện nay <strong>Arduino</strong> đang được sử dụng rộng rãi bởi tính dễ sử dụng, kiến trúc phần mềm tốt và tận dụng được nhiều thư viện cộng đồng</p>
</div>
<div class="sect3">
<h4 id="_esp8266_nonos_sdk">ESP8266 NONOS SDK</h4>
<div class="paragraph">
<p>Hiện nay, <strong>NONOS SDK</strong> phiên bản từ <strong>2.0.0</strong> trở lên đã ổn định và cung cấp gần như là đầy đủ tất cả các tính năng mà ESP8266 có thể thực hiện:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Các API cho Timer, System, Wifi, đọc ghi SPI Flash, Sleep và các Module phần cứng: GPIO, SPI, I²C, PWM, I²S với DMA.</p>
</li>
<li>
<p><code>Smartconfig</code>: Hỗ trợ cấu hình thông số Wi-Fi cho ESP8266 nhanh chóng.</p>
</li>
<li>
<p><code>Sniffer</code> API: Bắt các gói tin trong mạng không dây 2.4Ghz.</p>
</li>
<li>
<p><code>SNTP</code> API: Đồng bộ thời gian với Máy chủ thời gian.</p>
</li>
<li>
<p><code>WPA2 Enterprise</code> API: Cung cấp việc quản lý kết nối Wi-Fi bằng tài khoản sử dụng các máy chủ RADIUS.</p>
</li>
<li>
<p><code>TCP/UDP</code> API: Cho kết nối internet và hỗ trợ các Module dựa trên các giao thức như: HTTP, MQTT, CoAP.</p>
</li>
<li>
<p><code>mDNS</code> API: Giúp tìm ra <strong>IP</strong> của thiết bị trong mạng nội bộ bằng tên (hostname).</p>
</li>
<li>
<p><code>MESH</code> API: Liên kết các module ESP8266 với cấu trúc mạng MESH</p>
</li>
<li>
<p><code>FOTA</code> API: Firmware Over The Air - cập nhật firmware từ xa cho thiết bị .</p>
</li>
<li>
<p><code>ESP-Now</code> API: Sử dụng các gói tin Wireless 2.4GHz trao đổi trực tiếp với ESP8266 khác mà không cần kết nối tới Access Point.</p>
</li>
<li>
<p><code>Simple Pair</code> API: Thiết lập kết nối bảo mật giữa 2 thiết bị tự động.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_esp8266_rtos_sdk">ESP8266 RTOS SDK</h4>
<div class="paragraph">
<p><strong>RTOS SDK</strong> sử dụng <strong>FreeRTOS</strong> làm nền tảng, đồng thời hầu hết các API của <strong>NON OS</strong> SDK đều có thể sử dụng với <strong>RTOS SDK</strong>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_esp8285">ESP8285</h3>
<div class="paragraph">
<p>ESP8285 là một phiên bản khác sau này của ESP8266EX, giống hoàn toàn ESP8266EX ngoại trừ việc thay vì dùng SPI FLASH bên ngoài thì ESP8285 tích hợp 1MiB Flash bên trong giúp giảm diện tích phần cứng và đơn giản hóa quá trình sản xuất.</p>
</div>
</div>
<div class="sect2">
<h3 id="_module_và_board_mạch_phát_triển">Module và Board mạch phát triển</h3>
<div class="paragraph">
<p>ESP8266 cần ít nhất thêm 7 linh kiện nữa mới có thể hoạt động, trong đó phần khó nhất là Antena. Đòi hỏi phải được sản xuất, kiểm tra với các thiết bị hiện đại. Do đó, trên thị trường xuất hiện nhiều Module và Board mạch phát triển đảm đương hết để người dùng đơn giản nhất trong việc phát triển ứng dụng. Một số Module và Board phát triển phổ biến:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Bảng 1. Một số module ESP8266 trên thị trường</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tên</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Số chân</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pitch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LEDs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Antenna</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shielded</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dimensions</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.1"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14.3 × 24.8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-02</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.1"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U-FL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14.2 × 14.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-03</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ceramic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17.3 × 12.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-04</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14.7 × 12.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-05</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.1"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U-FL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14.2 × 14.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-06</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">misc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14.2 × 14.7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-07</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ceramic+U-FL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20.0 × 16.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-08</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17.0 × 16.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-09</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">misc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.0 × 10.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14.2 × 10.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.05"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ceramic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17.3 × 12.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24.0 × 16.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-12E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24.0 × 16.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-12F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24.0 × 16.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18.0 x 20.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ESP-14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24.3 x 16.2</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_board_mạch_phát_triển_esp8266">Board mạch phát triển ESP8266</h3>
<div class="paragraph">
<p>Module ESP8266 chỉ bao gồm Chip ESP8266 và các linh kiện giúp chip có thể hoạt động được, tuy nhiên, trong quá trình phát triển sản phẩm, chúng ta cần phải <strong>nạp</strong> chương trình cho chip trước khi đưa vào hoạt động thực tế. Quá trình này là quá trình gởi dữ liệu Binary (đã biên dịch trên máy tính) xuống bộ nhớ Flash của ESP8266.
Để đưa ESP8266 vào chế độ <strong>Nạp</strong> (Program) thì cần phải đặt mức logic 0 (0V - GND) vào chân <strong>GPIO0</strong>, đồng thời RESET chip. Rồi sau đó có thể dùng các công cụ nạp để gởi Firmware từ máy tính xuống.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/auto-program.jpg" alt="Mạch nạp tự động" width="500">
</div>
<div class="title">Hình 5. Một mạch nạp tự động sử dụng chip USB CDC</div>
</div>
<div class="paragraph">
<p>Hiện nay các Board mạch phát triển đều tích hợp các mạch nạp tự động, nghĩa là phần mềm sẽ tự động điều chỉnh các chân DTR và RTS của chip USB CDC, đưa ESP8266 vào chế độ nạp, sau đó sẽ gởi firmware xuống. Arduino IDE cũng vậy, nó sẽ điều chỉnh dựa trên việc khai báo Board mạch sử dụng.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Nếu bạn là người mới bắt đầu và chưa rõ về phần cứng, thì tốt nhất nên sử dụng một Board mạch phát triển sẵn có các chế độ nạp tự động. Khi bạn chuyển sang sản xuất phần cứng cho các ứng dụng cụ thể, thì có thể tách rời phần nạp tự động này ra để tiết giảm chi phí. Các mạch điện này đều được công bố rộng rãi.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_arduino_là_gì">Arduino là gì?</h2>
<div class="sectionbody">
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/01.arduino.png" alt="01.arduino" width="300">
</div>
<div class="title">Hình 6. Board mạch Arduino</div>
</div>
<div class="paragraph">
<p><a href="https://arduino.cc"><strong>Arduino</strong></a> là một IDE tích hợp sẵn editor, compiler, programmer và đi kèm với nó là các firmware có bootloader, các bộ thư viện được xây dựng sẵn và dễ dàng tích hợp. Ngôn ngữ sử dụng là <code>C/C++</code>. Tất cả đều opensource và được đóng góp, phát triển hàng ngày bởi cộng đồng. Triết lý thiết kế và sử dụng của Arduino giúp cho người mới, không chuyên rất dễ tiếp cận, các công ty, hardware dễ dàng tích hợp. Tuy nhiên, với trình biên dịch <code>C/C++</code> và các thư viện chất lượng được xây dựng bên dưới thì mức độ phổ biến ngày càng tăng và hiệu năng thì không hề thua kém các trình biên dịch chuyên nghiệp cho chip khác.</p>
</div>
<div class="paragraph">
<p>Đại diện cho <strong>Arduino</strong> ban đầu là chip AVR, nhưng sau này có rất nhiều nhà sản xuất sử dụng các chip khác nhau như <strong>ARM, PIC, STM32</strong> gần đây nhất là <a href="https://arduino.esp8266.vn"><strong>ESP8266</strong></a>, <a href="https://esp32.vn"><strong>ESP32</strong></a>, và <a href="http://riscv.vn"><strong>RISCV</strong></a> với năng lực phần cứng và phần mềm đi kèm mạnh mẽ hơn nhiều.</p>
</div>
<div class="sect2">
<h3 id="_một_số_đặc_điểm_của_arduino">Một số đặc điểm của Arduino</h3>
<div class="ulist">
<ul>
<li>
<p>Arduino che dấu đi sự phức tạp của điện tử bằng các khái niệm đơn giản, che đi sự phức tạp của phần mềm bằng các thủ tục ngắn gọn. Việc setup output cho 1 MCU bằng cách setup thanh ghi rõ ràng phức tạp đến độ người chuyên cũng phải lật datasheet ra xem, nhưng với Arduino thì chỉ cần gọi 1 hàm.</p>
</li>
<li>
<p>Bởi vì tính phổ biến và dễ dùng, với các thư viện được tích hợp sẵn. Bạn chỉ cần quan tâm đến tính năng sản phẩm mà bỏ qua các tiểu tiết (protocol, datasheet &#8230;&#8203;) Nên giúp các newbie không chuyên dễ dàng tiếp cận và làm ra các sản phẩm tuyệt vời mà không cần phải biết nhiều về điện tử.</p>
</li>
<li>
<p>Chính vì không quan tâm nhiều đến cách thức hoạt động của các Module đi kèm, nên đa phần người dùng sẽ khó xử lý được khi có các vấn đề phát sinh ngoài tầm của thư viện.</p>
</li>
<li>
<p>Các module prototype làm sẵn cho Arduino có độ bền không cao, mục tiêu đơn giản hóa quá trình làm sản phẩm.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_các_lợi_ích_khi_sử_dụng_arduino">Các lợi ích khi sử dụng Arduino</h3>
<div class="ulist">
<ul>
<li>
<p>Thiết kế IDE tốt, có thể dễ dàng tích hợp nhiều loại compiler, nhiều loại hardware mà không hề giảm hiệu năng. Ví dụ: Arduino gốc cho AVR, nhưng có nhiều phiên bản cho STM32, PIC32, ESP8266, ESP32&#8230;&#8203; tận dụng tối đa các thư viện sẵn có.</p>
</li>
<li>
<p>Các thư viện được viết dựa trên lớp API trên cùng, nên đa số các thư viện cho Arduino có thể dùng được cho tất cả các chip. Điển hình là Arduino cho ESP8266 có thể tận dụng trên 90% các thư viện cho Arduino khác</p>
</li>
<li>
<p>Trình biên dịch cho Arudino là C/C++, bạn có biết là khi biên dịch ESP8266 non-os SDK và ESP8266 Arduino cùng dùng chung trình biên dịch? Vậy thì hiệu năng không hề thua kém</p>
</li>
<li>
<p>Cách tổ chức các thư viện C/C++ theo dạng OOP giúp phân lớp, kế thừa và quản lý cực kỳ tốt cho các ứng dụng lớn .Các MCU ngày càng mạnh mẽ và ứng dụng cho nó sẽ ngày càng lớn. Các mô hình quản lý code đơn giản trước đây (thuần C) sẽ khó.</p>
</li>
<li>
<p>Các project cho Arduino đều opensource, bạn dễ dàng lấy nó và đưa vào sản phẩm production với chất lượng tốt và học hỏi được nhiều từ cách thức thiết kế chương trình của các bậc thầy.</p>
</li>
<li>
<p>Arduino chú trọng tính đa nền tảng, module hóa cao, phù hợp với các ứng dụng từ phức tạp tới cực kỳ phức tạp. Các ứng dụng kiểu này rất phổ biến trong thực tế. Nếu bạn không dùng C++, hoặc arduino mà gặp vấn đề về overcontrol thì nên thử qua Arduino.</p>
</li>
<li>
<p>Bạn sẽ tiết kiệm được rất rất nhiều thời gian cho việc tập trung vào tính năng sản phẩm đấy. Thời buổi này, thời gian là tiền và có quá nhiều thứ để học, làm thì nên ưu tiên đúng chỗ.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_cộng_đồng_arduino_trên_thế_giới">Cộng đồng Arduino trên thế giới</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.arduino.cc"><strong>Arduino chính thức(IDE &amp; AVR/ARM/x86 Board)</strong></a> <a href="https://www.arduino.cc" class="bare">www.arduino.cc</a></p>
</li>
<li>
<p><a href="https://github.com/esp8266/Arduino"><strong>Arduino cho ESP8266</strong></a> <a href="https://github.com/esp8266/Arduino" class="bare">github.com/esp8266/Arduino</a></p>
</li>
<li>
<p><a href="https://github.com/espressif/arduino-esp32"><strong>Arduino cho ESP32</strong></a> <a href="https://github.com/espressif/arduino-esp32" class="bare">github.com/espressif/arduino-esp32</a></p>
</li>
<li>
<p><a href="http://chipkit.net/"><strong>Arduino cho PIC32</strong></a> <a href="http://chipkit.net/" class="bare">chipkit.net/</a></p>
</li>
<li>
<p><a href="http://www.stm32duino.com/"><strong>Arduino cho STM32</strong></a> <a href="http://www.stm32duino.com/" class="bare">www.stm32duino.com/</a></p>
</li>
<li>
<p><a href="https://www.hackster.io/arduino">*Các dự án Arduino</a> <a href="https://www.hackster.io/arduino" class="bare">www.hackster.io/arduino</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_arduino_cho_esp8266_board_mạch_esp8266_wifi_uno">Arduino cho ESP8266 &amp; board mạch ESP8266 WiFi Uno</h3>
<div class="paragraph">
<p><a href="https://github.com/iotmakervn/iot-wifi-uno-hw">Board mạch ESP8266 WiFi Uno</a> là một dự án mã nguồn mở giúp hỗ trợ môi trường phát triển Arduino cho ESP8266. Giúp bạn có thể viết 1 Sketch sử dụng các thư viện và hàm tương tự của Arduino, có thể chạy trực tiếp trên ESP8266 mà không cần bất kỳ vi điều khiển nào khác.</p>
</div>
<div class="paragraph">
<p>ESP8266 Arduino core đi kèm với thư viện kết nối WiFi hỗ trợ TCP, UDP và các ứng dụng HTTP, mDNS, SSDP, DNS Servers. Ngoài ra còn có thể thực hiện cập nhật OTA, sử dụng Filesystem dùng bộ nhớ Flash hay thẻ SD, điều khiển servos, ngoại vi SPI, I2C.</p>
</div>
<div class="paragraph">
<p>Link: <a href="https://github.com/iotmakervn/iot-wifi-uno-hw" class="bare">github.com/iotmakervn/iot-wifi-uno-hw</a></p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/01-intro/01.Iot-wifi-uno-hw-pinout.png" alt="01.Iot wifi uno hw pinout" width="400">
</div>
<div class="title">Hình 7. PINOUT</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_node_js">Node.js</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Node.js là một Javascript Run time Cross Platform (chạy đa hệ điều hành) được xây dựng dựa trên mã nguồn mở Google&#8217;s V8 JavaScript engine cho Chrome (Browser). Node.js cho phép các lập trình viên có thể xây dựng ứng dụng Server Side, truy cập vào tài nguyên hệ thống và thực hiện được phần lớn các tác vụ hệ điều hành có thể thực hiện bằng ngôn ngữ Javascript, hoặc liên kết C++.</p>
</div>
<div class="paragraph">
<p>Hiện nay trên thế giới đã có nhiều công ty ứng dụng Node.js xây dựng các hệ thống production lớn, như Paypal, hoặc các microservice dựa trên Node.js cũng được triển khai ở đa số các hãng hàng đầu về công nghệ.</p>
</div>
<div class="paragraph">
<p>Nền tảng Cloud của gần như tất cả các nhà phát triển lớn hiện nay đều hỗ trợ thực thi Node.js, điển hình như Amazon Lambda, Google Script, IBM Blumix, Microsoft Azure &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Ngôn ngữ lập trình Javascript được cải tiến liên tục, hiện nay là Ecmascript 6 (ES5, ES2015) và đang được cải tiến rất nhanh, với nhiều ưu điểm như dễ học, xúc tích, OOP&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Một lý do Node.js được ưa chuộng nữa là đa phần các lập trình viên viết Web, Mobile đều biết, và giờ đây, nhờ Node.js mà họ có thể triển khai các ứng dụng Server Side bằng Javascript, mà không cần dùng ngôn ngữ nào khác (như trước kia phải cần Java, PHP &#8230;&#8203;)</p>
</div>
<div class="sect2">
<h3 id="_lý_do_sử_dụng_node_js_trong_cuốn_sách_này">Lý do sử dụng Node.js trong cuốn sách này</h3>
<div class="paragraph">
<p>Một hệ thống Internet Of Things đầy đủ khá phức tạp, bao gồm thiết bị, Server xử lý kết nối, Server dữ liệu (Database), các hệ thống cân bằng tải, các hệ thống phân thích, báo cáo dữ liệu, trí tuệ nhân tạo. Mô hình ví dụ của Google IoT Core</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/benefits-diagram-2x.png" alt="benefits diagram 2x" width="500">
</div>
<div class="title">Hình 8. Google IoT Core Diagram</div>
</div>
<div class="paragraph">
<p><code>Server</code> là một thành phần không thể thiếu trong hệ thống IoT. Với nhiều ưu điểm của Node.js thì nó rất phù hợp trong việc phát triển các Server cho IoT trong tương lai. Ngoài ra, Node.js được cộng đồng hỗ trợ rất nhiều, và không khó để tìm thấy 1 package cần thiết, tiết kiệm rất nhiều thời gian phát triển ứng dụng.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cuốn_sách_này_có_hướng_dẫn_node_js">Cuốn sách này có hướng dẫn Node.js ?</h3>
<div class="paragraph">
<p><strong>Không</strong>, nhưng bạn đừng vội thất vọng, các ứng dụng Node.js sử dụng để thực hiện các bài tập trong cuốn sách này khá đơn giản và <code>ít</code> mã nguồn, đủ cho bạn vẫn hiểu dù cho trước đây chưa bao giờ lập trình với Node.js.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sublime_text">Sublime Text</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nếu ở phần Chip, lập trình cho ESP8266 bạn đã có Arduino IDE, bao gồm cả trình soạn thảo. Nhưng với Node.js thì bạn cần 1 trình soạn thảo khác. Ngoài Sublime Text, bạn có thể lựa chọn các trình soạn thảo phổ biến hiện nay như <code>Atom</code>, <code>Visual Code</code>, nhưng đừng dại sử dụng Nodepad, mặc dù là vẫn được.</p>
</div>
<div class="paragraph">
<p>Sublime Text là một trình soạn thảo được nhiều lập trình viên ưu thích hàng đầu hiện nay, bởi nhiều lý do, trong đó tốc độ là quan trọng nhất. Nó thực sự nhanh, nhanh gần như là số 1 trong số các trình soạn thảo hiện nay. Ngoài ra nó miễn phí (lâu lâu nhắc mua, khung thoại mà nhiều lập trình viên bảo thiếu thì buồn).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/sublime.png" alt="Sublime Text" width="600">
</div>
<div class="title">Hình 9. Sublime Text</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cài_đặt_và_chuẩn_bị">Cài đặt và chuẩn bị</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_arduino_ide">Arduino IDE</h3>
<div class="paragraph">
<p><strong>Bước 1</strong>: Cài đặt Arduino IDE.</p>
</div>
<div class="paragraph">
<p>Download và cài đặt arduino từ trang chủ của arduino. Link donwload:
<a href="https://www.arduino.cc/en/Main/Software" class="bare">www.arduino.cc/en/Main/Software</a>.</p>
</div>
<div class="paragraph">
<p>Tùy hệ điều hành mà chọn gói cài đặt thích hợp.</p>
</div>
<div class="paragraph">
<p><strong>Bước 2</strong>: Cài đặt bộ công cụ, trình biên dịch, SDK hỗ trợ chip ESP8266 trong Arudino IDE.</p>
</div>
<div class="paragraph">
<p>Với bộ công cụ này, chúng ta có thể dễ dàng lập trình, biên dịch và sử dụng các thư viện dành cho ESP8266 trực tiếp trên Arduino IDE. Mở Arduino IDE, trên thanh Menu chọn <code>File</code> &#8594; <code>Preferecens</code>, trong tab <code>settings</code> chọn các tùy chọn như hình dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/preferences.png" alt="Thêm file hỗ trợ cài đặt board ESP8266" width="400">
</div>
<div class="title">Hình 10. Thêm file thông tin board ESP8266</div>
</div>
<div class="paragraph">
<p><code>Sketchbook location</code> là đường dẫn mà bạn muốn lưu Sketch (file chương trình), trên các hệ điều hành Unix liked đường dẫn mặc định là: <code>/home/name_your_computer/Arduino</code>. Đây cũng sẽ là vị trí lưu những thư viện mà chúng ta sẽ thêm vào sau này.</p>
</div>
<div class="paragraph">
<p>Mục <code>Additional Board Manager URLs field</code> nhập đường dẫn <code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code>.</p>
</div>
<div class="paragraph">
<p><strong>Bước 3</strong>: Cài đặt board ESP8266.</p>
</div>
<div class="paragraph">
<p>Mở <code>Boards Manager</code> ở mục <code>Tools</code> trên thanh menu-bar &#8594; tìm board cần sử dụng với keyword <code>Generic 8266</code> &#8594; chọn board cần cài đặt như hình và nhấn vào install.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/install_board_generic8266.png" alt="Board manager" width="400">
</div>
<div class="title">Hình 11. Cài đặt board ESP8266</div>
</div>
</div>
<div class="sect2">
<h3 id="install-library">Cài đặt thư viện Arduino</h3>
<div class="paragraph">
<p>Một số thư viện do các nhà phát triển khác công bố và được tự do sử dụng có thể cài đặt trực tiếp bằng công cụ Library Manager của Arduino.</p>
</div>
<div class="paragraph">
<p>Khởi động arduino IDE và chọn mục <code>Sketch</code> &#8658; <code>include library</code> &#8658; <code>Manage libraries</code>:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/library.png" alt="Khởi động Library Manager" width="400">
</div>
<div class="title">Hình 12. Khởi động Library Manager</div>
</div>
<div class="paragraph">
<p>Trong mục <code>libbrary manager</code> nhập nội dung thư viện cần tìm tại hộp thoại text box, chọn phiên bản, rồi nhấn <code>install</code>, Những thư viện đã được cài đặt sẽ có text hiển thị <code>INSTALLED</code> ở đầu mỗi thư viện.
Ví dụ tìm thư viện OLED liên quan đến ESP8266:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/library-1.png" alt="Cài đặt thư viện" width="400">
</div>
<div class="title">Hình 13. Cài đặt thư viện</div>
</div>
</div>
<div class="sect2">
<h3 id="_usb_cdc_driver">USB CDC driver.</h3>
<div class="paragraph">
<p>Board ESP8266 WiFi Uno được kết nối với máy tính qua cổng USB MicroB và sử dụng chip <strong>CH340</strong> để chuyển đổi USB sang UART. Vì vậy cần cài USB driver để máy tính và board có thể giao tiếp với nhau.</p>
</div>
<div class="paragraph">
<p>Thực hiện kết nối cable USB với board, đảm bảm đèn LED khoanh tròn sáng như ở hình dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/connect_USB.jpg" alt="Connect USB" width="400">
</div>
<div class="title">Hình 14. Connect USB</div>
</div>
<div class="sect3">
<h4 id="_windows_linux">Windows &amp; Linux</h4>
<div class="paragraph">
<p>Tải bản cài đặt USB driver cho Windows <a href="http://www.wch.cn/download/CH341SER_ZIP.html" class="bare">www.wch.cn/download/CH341SER_ZIP.html</a> và cho Linux <a href="http://www.wch.cn/download/CH341PAR_LINUX_ZIP.html" class="bare">www.wch.cn/download/CH341PAR_LINUX_ZIP.html</a> Làm theo các yêu cầu cài đặt.
Sau khi cài đặt, kết quả hiển thì trên Arduino như hình:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/connect_ok.png" alt="Kết nối thành công" width="400">
</div>
<div class="title">Hình 15. Kết nối thành công</div>
</div>
</div>
<div class="sect3">
<h4 id="_mac_os">Mac OS</h4>
<div class="paragraph">
<p>Tải bản cài đặt: <a href="https://arduino.esp8266.vn/_static/download/CH34x_Install_V1.3.pkg" class="bare">arduino.esp8266.vn/_static/download/CH34x_Install_V1.3.pkg</a></p>
</div>
<div class="paragraph">
<p>Đối với <strong>Mac OS Sierra</strong> trở về sau nếu gặp vấn đề bị RESET máy thì xử lý như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mở ứng dụng "Terminal" <code>cmd + space</code> -&#8594; Enter Terminal</p>
</li>
<li>
<p>Xóa driver: <code>sudo rm -rf /System/Library/Extensions/usb.kext</code></p>
</li>
<li>
<p>Với một số máy, bạn phải thực thi thêm <code>sudo rm -rf /Library/Extensions/usbserial.kext</code></p>
</li>
<li>
<p>Nếu không thể thực hiện được lệnh trên, bạn cần phải thay đổi <code>Security and Privacy</code> trong phần <code>System Preference</code>. Chọn <code>Allow Apps Downloaded From</code> từ <code>Mac App Store and Identified Developers</code> sang <code>Anywhere</code> - Và tải <a href="https://arduino.esp8266.vn/_static/download/CH34x_Install_V1.3.pkg">CH34x_Install_V1.3.pkg</a> về cài đặt lại.</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/mac.png" alt="Lựa chọn Allow Apps Downloaded From Anywhere" width="400">
</div>
<div class="title">Hình 16. Lựa chọn Allow Apps Downloaded From Anywhere</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</h3>
<div class="paragraph">
<p>Sau khi kết nối và cài đặt xong, sẽ xuất hiện cổng COM ảo trên máy tính (Tùy từng loại hệ điều hành mà có những tên cổng như: <code>COM1</code>, <code>COM2</code> &#8230;&#8203; đối với Windows, <code>/dev/tty.wchusbserial1420</code> trên Mac OS, <code>/dev/ttyUSB0</code> trên Linux)
Mở Arduino IDE và lựa chọn (tham khảo cấu hình kết nối như hình dưới):</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/port-setup.png" alt="Cấu hình Board ESP8266 WiFi Uno" width="400">
</div>
<div class="title">Hình 17. Cấu hình Board ESP8266 WiFi Uno</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Board: <code>Generic ESP8266 Module</code>.</p>
</li>
<li>
<p>Flash Size: <code>4M (3M SPIFFS)</code>.</p>
</li>
<li>
<p>Port: chọn cổng khi gắn thiết bị vào sẽ thấy xuất hiện.</p>
</li>
<li>
<p>Upload speed: Chọn cao nhất, nếu nạp không được chọn thấp dần.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</h3>
<div class="paragraph">
<p>Trên giao diện Arduino có 2 nút, ngoài cùng bên trái là nút <code>Verify</code>, để biên dịch chương trình, tương đương với <code>Sketch &gt; Verify/Compile</code>, nút tiếp theo là <code>Upload</code>, tương đương <code>Sketch &gt; Upload</code>. Khi đã lựa chọn board phù hợp, chương trình không có lỗi, thì nhấn <code>Upload</code> sẽ nạp chương trình vào board và thực thi sau đó.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/program.png" alt="Nạp chương trình xuống board dùng Arduino IDE" width="400">
</div>
<div class="title">Hình 18. Nạp chương trình</div>
</div>
</div>
<div class="sect2">
<h3 id="export-binary">Xuất firmware binary trong Arduino IDE</h3>
<div class="paragraph">
<p>Với bất kỳ tình huống nào cần file Binary, bạn có thể được xuất ra bằng cách <code>Sketch &gt; Export compiled Binary</code>, và file .bin sẽ nằm trong thư mục của Sketch.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/export-fw.png" alt="export fw" width="400">
</div>
<div class="title">Hình 19. Xuất file Binary</div>
</div>
</div>
<div class="sect2">
<h3 id="_serial_terminal">Serial Terminal</h3>
<div class="paragraph">
<p>Có nhiều ứng dụng miễn phí để tương tác với cổng Serial trên máy tính:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Windows: PuTTY, realterm</p>
</li>
<li>
<p>Linux: minicom, screen</p>
</li>
<li>
<p>MacOS: minicom, screen</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="arudino-term">Sử dụng Arduino IDE Serial Monitor</h4>
<div class="paragraph">
<p>Arduino có tích hợp sẵn Serial Monitor, khi chọn đúng cổng Serial, thì có thể nhấn biểu tượng Serial trên IDE để mở:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/01-intro/term.png" alt="Nạp chương trình xuống board dùng Arduino IDE" width="400">
</div>
<div class="title">Hình 20. Arduino IDE Serial Monitor</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_node_js_2">Node.js</h3>
<div class="paragraph">
<p>Tải và cài đặt Node.js tại: <a href="https://nodejs.org/en/download/" class="bare">nodejs.org/en/download/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_sublime_text_2">Sublime Text</h3>
<div class="paragraph">
<p>Tải và cài đặt tại: <a href="https://www.sublimetext.com/" class="bare">www.sublimetext.com/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_git">Git</h3>
<div class="paragraph">
<p>Một công cụ hỗ trợ khác bạn cũng nên cài đặt và tập sử dụng, nó không giúp bạn trở thành 1 lập trình viên, nhưng nó giúp 1 lập trình viên trở nên chuyên nghiệp và làm việc hiệu quả: <a href="https://git-scm.com/" class="bare">git-scm.com/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tổng_kết">Tổng kết</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tới lúc này, bạn có thể đã có cái nhìn tổng quan về hệ sinh thái, công cụ và phương thức làm việc với ESP8266 cũng như tổng quan về hệ thống <strong>IoT</strong>. Đồng thời đã có thể bắt đầu việc phát triển ứng dụng cho ESP8266 ngay lập tức. Các công cụ được lựa chọn đều là đa nền tảng, dễ dàng được sử dụng cho các hệ điều hành Mac OS, Windows, hay Linux</p>
</div>
</div>
</div>
<h1 id="_hello_world" class="sect0">Hello World</h1>
<div class="openblock partintro">
<div class="content">
Bất kỳ một chương trình học nào cũng cần nên bắt đầu một cách từ từ. Bởi vì thời điểm này chúng ta đều mới bắt đầu, nhiều khái niệm, kiến thức về lĩnh mực này gần như không có nhiều. <code>Helloworld</code> giúp các bạn có thể nắm được các kiến thức cơ bản, làm sao để biên dịch, nạp được chương trình. Làm sao để sử dụng các thư viện công cộng. Cũng như nắm được một số kiến thức về kiến trúc chương trình Arduino.
</div>
</div>
<div class="sect1">
<h2 id="_chớp_tắt_bóng_led">Chớp tắt bóng LED</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_kiến_thức">Kiến thức</h3>
<div class="paragraph">
<p><strong>Đèn LED</strong> viết tắt (Light Emitting Diodes) - là bóng bán dẫn có thể phát sáng với màu sắc khác nhau tùy thuộc vào chất liệu bán dẫn. Để điều khiển được bóng LED cần cung cấp mức điện áp chênh lệch giữa cực âm và cực dương của bóng LED cao hơn mức điện áp Vf (datasheet), thường là 3.2v, và dòng điện nhỏ hơn mức chịu đựng của nó, thường là 15mA.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/LED_symbol.svg" alt="LED symbol" width="200">
</div>
<div class="title">Hình 21. Ký hiệu LED trên mạch điện (Cathode+, Anode-)</div>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/led.png" alt="led" width="400">
</div>
<div class="title">Hình 22. Mạch có thể chạy được như sau</div>
</div>
<div class="paragraph">
<p><strong>Arduino IDE</strong></p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/arduino-ide.png" alt="arduino ide" width="400">
</div>
<div class="title">Hình 23. Arduini IDE</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Biên dịch chương trình (kiểm tra có lỗi hay không).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Biên dịch và nạp chương trình.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Tab tên file.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Khu vực nội dung file <code>ino</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_Đấu_nối">Đấu nối</h3>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/btn-led.png" alt="btn led" width="300">
</div>
<div class="title">Hình 24. Mạch ESP8266 WiFi Uno có đấu nối sẵn LED vào Pin 16, và nút nhất vào Pin 0</div>
</div>
<div class="paragraph">
<p>Với mã nguồn bên dưới, sau khi kiểm tra chương trình, bạn cần chắc chắn đã <a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a> và <a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_mã_nguồn_chớp_tắt_dùng_delay">Mã nguồn chớp tắt dùng Delay</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int pin_led = 16;
/* hàm này được gọi 1 lần duy nhất khi khởi động */
void setup() {

  pinMode(pin_led, OUTPUT);    // cấu hình pin 16 là ngõ ra
}

/* hàm loop sẽ được gọi liên tục */
void loop() {
  digitalWrite(pin_led, HIGH); // tắt LED (HIGH - có nghĩa là mức cao)
  delay(1000);                 // chờ 1 giây
  digitalWrite(pin_led, LOW);  // bật LED bởi mức điện áp LOW
  delay(1000);                 // chờ 1 giây
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mã_nguồn_chớp_tắt_dùng_định_thời">Mã nguồn chớp tắt dùng định thời</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ledPin = 16;
int ledState = LOW;
unsigned long previousMillis = 0;
const long interval = 1000;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis &gt;= interval) {
    previousMillis = currentMillis;
    if (ledState == LOW)
      ledState = HIGH;  // Đổi trạng thái
    else
      ledState = LOW;   // Đổi trạng thái
    digitalWrite(ledPin, ledState);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_digital_io">Digital IO</h3>
<div class="paragraph">
<p>Tên Pin trong Arduino (Pin number) giống với thứ tự chân của ESP8266. <code>pinMode</code>, <code>digitalRead</code>, và <code>digitalWrite</code> đều sử dụng Pin Number như nhau, ví dụ như đọc GPIO2, gọi hàm digitalRead(2).</p>
</div>
<div class="paragraph">
<p>Các chân GPIO0 đến GPIO15 có thể là <code>INPUT</code>, <code>OUTPUT</code>, hay <code>INPUT_PULLUP</code>. Chân <code>GPIO16</code> có thể là <code>INPUT</code>, <code>OUTPUT</code> hay <code>INPUT_PULLDOWN_16</code>. Khi khởi động, tất cả các chân sẽ được cấu hình là <code>INPUT</code>.</p>
</div>
<div class="paragraph">
<p>Mỗi chân có thể phục vụ cho một tính năng nào đó, ví dụ <code>Serial</code>, <code>I2C</code>, <code>SPI</code>. Và tính năng đó sẽ được cấu hình đúng khi sử dụng thư viện.</p>
</div>
<div class="paragraph">
<p><code>GPIO6</code> và <code>GPIO11</code> không được thể hiện bởi vì nó được sử dụng cho việc kết nối với Flash. Việc sử dụng 2 chân này có thể gây lỗi chương trình.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Một số board và module khác (ví dụ ESP-12ED, NodeMCU 1.0) không có GPIO9 và GPIO11, họ sử dụng với chế độ DIO cho Flash, trong khi ESP12 chúng ta nói bên trên sử dụng chế độ QIO
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ngắt GPIO hỗ trợ thông qua các hàm <code>attachInterrupt</code>, <code>detachInterrupt</code> Ngắt GPIO có thể gán cho bất kỳ GPIO nào, ngoại trừ GPIO16 và đều hỗ trợ các ngắt tiêu chuẩn của Arduino như: <code>CHANGE</code>, <code>RISING</code>, <code>FALLING</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tổng_kết_2">Tổng kết</h3>
<div class="paragraph">
<p>Các ứng dụng mở rộng</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fading LED (sáng dần hay tắt dần)</p>
</li>
<li>
<p>Chớp tắt LED dùng Ticker
== Nút nhấn</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_kiến_thức_2">Kiến thức</h3>
<div class="paragraph">
<p>Nút nhấn sẽ giúp việc ESP8266 khởi động một hành động nào đó khi cần thiết. Trong nhiều ứng dụng chúng ta hầu như đều cần những kích hoạt từ bên ngoài. Xuyên suốt cuốn sách này, sẽ dùng nút nhấn để kích hoạt chạy các ứng dụng mẫu cũng như đèn LED để thông báo các trạng thái. Trong phần này, nhấn nút đèn LED sẽ chuyển trạng thái (từ sáng &#8594; tắt và ngược lại).</p>
</div>
<div class="paragraph">
<p>Đây là ví dụ đơn giản, trong thực tế việc xử lý nút nhấn khá phiền phức. Bởi vì nút nhấn vật lý khi được nhấn sẽ tạo ra hàng loạt các xung lên xuống (nhiễu, bouncing&#8230;&#8203;). Thường thì chỉ cần đảm bảo mức Logic của chân đo được đã được giữ ổn định trong khoảng 100 mili giây là được xem đã ổn định.</p>
</div>
<div class="paragraph">
<p>Ngoài cách dùng ngắt để xác định nút nhấn có được nhấn hay không - cách này sẽ tiết kiệm tài nguyên tính toán của CPU, nó chỉ được gọi khi có sự kiện xảy ra, thì còn một cách nữa là hỏi vòng: Cách này đỏi hỏi CPU liên tục kiểm tra xem mức Logic của nút nhấn. Đồng thời việc đáp ứng cũng không nhanh bằng sử dụng ngắt.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/button-circuit.jpg" alt="button circuit" width="300">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Yêu cầu: Nhấn nút (GPIO0) thì chớp tắt đèn LED (GPIO6) và in ra cổng Serial
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Mạch ESP8266 WiFi Uno đấu sẵn nút nhấn vào GPIO0
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_mã_nguồn_dùng_hỏi_vòng">Mã nguồn dùng hỏi vòng</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ledPin = 16;                 // LED nối vào chân 16
int btnPin = 0;                  // Nút nhấn nối vào chân 0
int ledState = LOW;

void blink()
{
  if (ledState == LOW) {
    ledState = HIGH;
  } else {
    ledState = LOW;
  }
  digitalWrite(ledPin, ledState); //Đảo trạng thái LED &amp; in ra serial
  Serial.println("Pressed, value=" + String(ledState));
}

bool isPressed()
{
  return (digitalRead(btnPin) == 0);
}
void setup()
{
  pinMode(ledPin, OUTPUT);       // Cấu hình LED là ngõ ra
  pinMode(btnPin, INPUT_PULLUP); // Cấu hình nút nhấn là ngõ vào pull-up

  Serial.begin(115200);
}

void loop()
{
  if (isPressed()) {
    blink();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mã_nguồn_dùng_ngắt">Mã nguồn dùng ngắt</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">int ledPin = 16;                 // LED nối vào chân 16
int btnPin = 0;                  // Nút nhấn nối vào chân 0
int ledState = LOW;

void blink()
{
  if (ledState == LOW) {
    ledState = HIGH;
  } else {
    ledState = LOW;
  }
  digitalWrite(ledPin, ledState);
  Serial.println("Pressed, value=" + String(ledState));
}
void setup()
{
  pinMode(ledPin, OUTPUT);      // sets the digital pin as output
  pinMode(btnPin, INPUT_PULLUP); // Cấu hình nút nhấn là ngõ vào pull-up
  attachInterrupt(btnPin, blink, FALLING); //cài đặt ngắt cho chân LED
  Serial.begin(115200);
}

void loop()
{
  //Không phải làm gì
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_các_khái_niệm">Các khái niệm</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Ngắt</strong> Ngắt là một khái niệm liên quan nhiều đến phần cứng, một sự kiện nào đó xảy ra, bắt buộc CPU phải dừng các tác vụ bình thường khác đang thực thi để thực hiện tác vụ Ngắt. Ví dụ, cấu hình ngắt khi có thay đổi mức logic từ 1 về 0 (cạnh xuống) của GPIO, thì khi mức logic thay đổi trên GPIO đó, CPU sẽ ngay lập tức dừng và lưu các trạng thái tại chương trình chính và nhảy vào hàm ngắt để thực thi các lệnh trong đó.</p>
</li>
<li>
<p><strong>pull-up/pull-down</strong> Đa số các chân GPIO của Chip đều có thể có 3 trạng thái, trạng thái là ngõ ra mức cao (logic 1), trạng thái là ngõ ra mức thấp (logic 0) và trạng thái ngõ vào (input). Ở trạng thái Input, thì các GPIO được cấu hình trở kháng cao (Hi-Z), hay còn gọi là trạng thái cách ly, không cho dòng điện đi qua, nhưng vẫn cảm nhận được điện áp. Ở trạng thái Hi-Z, nếu không xác định mức logic trước cho GPIO thì GPIO này bị thả trôi, nghĩa là rất dễ ảnh hưởng bởi môi trường, khi đọc về sẽ không đoán định được mức Logic. Pull-up là nối 1 điện trở với GPIO này lên mức logic 1, xác định trước 1 điện áp cho nó để đảm bảo không không có tác động điện nào thì nó là mức logic 1. Tương tự, pull-down xác định trước mức logic 0 cho GPIO.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oled">OLED</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_màn_hình_oled">Màn hình OLED</h3>
<div class="paragraph">
<p>OLED (Organic Light Emitting Diode) là loại màn hình hiển thị bao gồm một lớp vật liệu hữu cơ với chủ yếu là cacbon nằm giữa hai điện cực anot và catot sẽ tự động phát sáng mỗi khi có dòng điện chạy qua. OLED sử dụng đi-ốt phát quang hữu cơ, chính vì thế nó không cần tới đèn nền chiếu sáng, do đó có lợi thế về kích thước cũng như tiết kiệm điện hơn so với các loại LCD. Và độ sáng tương đối tốt ở môi trường sáng tự nhiên</p>
</div>
</div>
<div class="sect2">
<h3 id="_màn_hình_oled_ssd1306">Màn hình OLED SSD1306</h3>
<div class="paragraph">
<p>Là màn hình loại nhỏ, kích thước tầm 0.96 inch cho tới 1.25 inch, được dùng khá rộng rãi trong các sản phẩm điện tử. Tấm nền được điều khiển bằng chip driver SSD1306. Chip này giao tiếp với các bộ điều khiển/MCU khác bằng giao tiếp LCD</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/01-intro/oled.jpg" alt="OLED SSD1306" width="400">
</div>
<div class="title">Hình 25. OLED SSD1306</div>
</div>
</div>
<div class="sect2">
<h3 id="_giao_tiếp_i2c">Giao tiếp I2C</h3>
<div class="paragraph">
<p>I2C (Inter-Integrated Circuit) là một loại bus nối tiếp được phát triển bởi hãng Philips nhằm truyền nhận dữ liệu giữa các IC. I2C sử dụng 2 đường truyền tín hiệu, 1 đường xung nhịp đồng hồ (SCL) do Master phát đi và 1 đường truyền dữ liệu theo 2 hướng (SDA)</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/i2cClock.png" alt="i2cClock" width="600">
</div>
<div class="title">Hình 26. I2C Clock</div>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/01-intro/i2c-network.png" alt="Mô hình mạng I2C" width="400">
</div>
<div class="title">Hình 27. Mô hình mạng I2C</div>
</div>
<div class="paragraph">
<p>Mạch vật lý I2C là mạch cực thu hở, do đó để mạng I2C có thể hoạt động được, cần tối thiểu 2 cặp điện trở pull-up như trên hình. Thông thường 4k7, hoặc 1k2. Tùy thuộc vào tốc độ truyền và khoảng cách truyền.</p>
</div>
</div>
<div class="sect2">
<h3 id="_hiển_thị_màn_hình_oled_với_esp8266">Hiển thị màn hình OLED với ESP8266</h3>
<div class="paragraph">
<p><strong>Bước 1: Đấu nối</strong> nối chân GPIO4 của ESP8266 với chân SDA của OLED, chân GPIO5 với SCL. Cấp nguồn 3v3 vào VCC và đấu GND cho OLED. Tuy nhiên với board ESP8266 IoT Uno thì phần đấu nối đã ra sẵn header, bạn chỉ cần cắm OLED vào như hình</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/01-intro/oled-esp.png" alt="ESP8266 với OLED" width="814">
</div>
<div class="title">Hình 28. ESP8266 với OLED</div>
</div>
<div class="paragraph">
<p><strong>Bước 2: Cài đặt thư viện</strong> <code>ESP8266 and ESP32 OLED driver for SSD1306 display</code>, xem thêm <a href="#install-library">Cài đặt thư viện Arduino</a></p>
</div>
<div class="paragraph">
<p><strong>Bước 3: Lập trình</strong> Chúng ta sẽ thực hiện hiển thị giả lập đồng hô trên màn hình OLED</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;Wire.h&gt;
#include "SSD1306.h"

SSD1306  display(0x3c, 4, 5);
int thoi_gian = 0;
void setup()
{
  Serial.begin(115200);
  display.init();
  //display.flipScreenVertically(); //đảo chiều
  display.setFont(ArialMT_Plain_10);
  display.drawString(0, 0, "Hello world");
  display.display();
  delay(1000);
  display.clear();
}

void loop()
{
  int gio, phut, giay;


  delay(1000);
  thoi_gian ++;

  gio = thoi_gian/3600;
  phut = (thoi_gian%3600)/60;
  giay = thoi_gian % 60;
  display.clear();
  display.drawString(0, 0, String(gio) + ":" + String(phut) + ":" + String(giay));
  display.display();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tổng_kết_3">Tổng kết</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thông qua các ví dụ mẫu về điều khiển đèn LED, nút nhấn và OLED, chúng ta có thể triển khai thêm nhiều ví dụ khác sử dụng GPIO của ESP8266, cũng như hiểu rõ hơn về cách làm việc của Arduino IDE, cách nạp chương trình, sử dụng thư viện &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Một trong những ứng dụng có thể sử dụng các kiến thức này như là trò chơi Flappy Bird, bạn có thể thử nghiệm tại đây: <a href="https://github.com/esp8266vn/arduino-flappybird">https://github.com/esp8266vn/arduino-flappybird</a></p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/02-helloworld/arduino-flappybird.jpg" alt="Aduino Flappybird" width="400">
</div>
<div class="title">Hình 29. Arduino FlappyBird</div>
</div>
</div>
</div>
<h1 id="_wifi" class="sect0">ESP8266 WiFi</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Kết nối WiFi chính điểm mạnh nhất của chip ESP8266, nó có thể kết nối đến các Router sẵn có trong gia đình, các Access Point với các tiêu chuẩn kết nối thông dụng hiện nay ở tần số 2.4GHz - ở chế độ STA. Ngoài ra, ESP8266 còn hỗ trợ chế độ AP (Access Point), tức là nó có thể khởi động một (hoặc nhiều) Access Point và cho phép các client khác có thể kết nối vào, hoặc chạy đồng thời cả chế độ STA và AP.</p>
</div>
<div class="paragraph">
<p>Trong đa phần các ứng dụng thì chế độ STA được sử dụng rất nhiều, nó giúp thiết bị kết nối đến  mạng WiFi cục bộ, có internet để kết nối đến Server và gởi dữ liệu. Một số trường hợp khác thì chế độ AP được sử dụng để trao đổi dữ liệu với ESP8266 và máy tính (hoặc thiết bị có hỗ trợ trình duyệt). Ví dụ như điều khiển đóng tắt đèn thông qua Web Server chạy trên ESP8266.</p>
</div>
<div class="paragraph">
<p>WiFi Access Point là một thiết bị xử lý kết nối trung tâm và phân phối các luồng dữ liệu. Như là việc xử lý các gói tin IP để định địa chỉ mạng LAN, định tuyến các gói tin từ Internet về các máy trạm (Station).</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/router.jpg" alt="WiFi Access Point" width="400">
</div>
<div class="title">Hình 30. WiFi Access Point</div>
</div>
<div class="paragraph">
<p>Thiết bị kết nối đến Access Point được gọi là Station, các máy tính Laptop, máy tính có card WiFi khi kết nối vào Access Point thì đều được gọi là Station</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/ap-sta.png" alt="WiFi Network" width="400">
</div>
<div class="title">Hình 31. Mạng WiFi</div>
</div>
<div class="paragraph">
<p>Các Station khi muốn kết nối vào Access Point thì cần xác định thông qua <code>BSSID</code>, thông thường chúng ta hay gọi là <code>SSID</code> - hay mạng WiFi. Bạn có thể dễ dàng xem danh sánh SSID xung quanh mình khi scan wifi trên máy tính để kết nối mạng Internet.</p>
</div>
<div class="paragraph">
<p>Trong phần này chúng ta sẽ tìm hiểu về các chế độ WiFi của ESP8266</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Chế độ <code>Station - STA</code> kết nối tới Access Point sẵn có.</p>
</li>
<li>
<p>Sử dụng <code>HTTPClient</code> để gởi và lấy dữ liệu từ Internet.</p>
</li>
<li>
<p>Chế độ <code>Access Point - AP</code> cho phép Client khác kết nối vào.</p>
</li>
<li>
<p><code>Web Server</code> chạy trên ESP8266, dùng để bật tắt đèn LED.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_chế_độ_wifi_station">Chế độ WiFi Station</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_kiến_thức_3">Kiến thức</h3>
<div class="paragraph">
<p>Để kết nối được vào mạng Internet, thì đầu tiên ESP8266 phải kết nối vào mạng WiFi nội bộ, và mạng WiFi nội bộ phải có kết nối WAN Internet. Đa phần các Modem hiện nay đều tích hợp luôn cả WiFi Access Point, do đó khá dễ dàng trong việc triển khai các ứng dụng IoT.</p>
</div>
<div class="paragraph">
<p>Khi muốn kết nối vào mạng WiFi cục bộ thì ESP8266 cần phải hoạt động ở chế độ Station (STA), đồng thời nó phải được cung cấp tên (SSID) và mật khẩu mạng WiFi.</p>
</div>
<div class="paragraph">
<p>Mỗi Access Point đều yêu cầu một phương thức mã hóa để Station sử dụng nhằm tạo kết nối - ví dụ các phương thức <code>WEP</code>, <code>WPA2</code>, tuy nhiên chúng ta có lẽ không cần quan tâm nhiều, vì ESP8266 sẽ tự động thực hiện các thao tác lựa chọn phương thức mã hóa.</p>
</div>
<div class="paragraph">
<p>Khi kết nối thành công vào mạng WiFi thì ESP8266 sẽ khởi động DHCP Client (mặc định) để xin cấp phát địa chỉ IP trước khi bắt đầu các kết nối IP. Do đó, nếu như vì lý do gì đó, mà Access Point của bạn không có DHCP Server để cấp phát IP thì bạn phải cấu hình IP tĩnh cho ESP8266.</p>
</div>
</div>
<div class="sect2">
<h3 id="_kết_nối_vào_mạng_wifi_nội_bộ">Kết nối vào mạng WiFi nội bộ</h3>
<div class="paragraph">
<p>Với đoạn code này, nếu bạn cung cấp đúng <code>SSID</code> và <code>PASSWORD</code>, đồng thời Access Point hoạt động thì thiết bị sẽ kết nối và in ra Serial Terminal địa chỉ IP của ESP8266 trong mạng LAN</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;

const char* ssid     = "your-ssid";
const char* password = "your-password";

void setup() {

  // Thiết lập truyền dữ liệu nối tiếp ở tốc độ 115200 bits/s
  Serial.begin(115200);
  delay(10);
  Serial.print("Connecting to ");

  // In ra tên mạng wifi sẽ kết nối đến
  Serial.println(ssid);

  // Thiết lập ESP8266 ở chế độ station và kết nối đến mạng wifi đã chỉ định
  WiFi.begin(ssid, password);
  // Đoạn code in ra dấu . nếu ESP8266 chưa được kết nối
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  // In ra dòng "WiFi connected" và địa chỉ IP của ESP8266
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void loop() {

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sử_dụng_wifimulti">Sử dụng WiFiMulti</h3>
<div class="paragraph">
<p>Tuy nhiên, đôi lúc ứng dụng bạn cần <code>nồi đồng cối đá</code>, thì có 2-3 mạng WiFi để backup là bình thường, class WiFiMulti sẽ giúp bạn điều đó. Cùng với một hàm monitor đơn giản để báo cho các chức năng khác biết khi mạng đã được thiết lập.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266WiFiMulti.h&gt;
// Khai báo biến wifiMulti thuộc class ESP8266WiFiMulti để sử dụng các chức năng của class này.
ESP8266WiFiMulti wifiMulti;
// Biến connectioWasAlive nhằm kiểm tra kết nối của ESP8266 đến mạng wifi.
boolean connectioWasAlive = true;

void setup()
{
  Serial.begin(115200);
  Serial.println();
  // Add vào các mạng wifi mà ESP8266 được chỉ định sẽ kết nối
  wifiMulti.addAP("primary-network-name", "pass-to-primary-network");
  wifiMulti.addAP("secondary-network-name", "pass-to-secondary-network");
  wifiMulti.addAP("tertiary-network-name", "pass-to-tertiary-network");
}

void monitorWiFi()
{
  // Kiểm tra nếu chưa kết nối đến 1 mạng wifi nào sẽ cài đặt connectioWasAlive = false
  // đồng thời in ra dấu "." sau mỗi 500ms nếu chưa được kết nối.
  if (wifiMulti.run() != WL_CONNECTED)
  {
    if (connectioWasAlive == true)
    {
      connectioWasAlive = false;
      Serial.print("Looking for WiFi ");
    }
    Serial.print(".");
    delay(500);
  }
  // Nếu đã kết nối đến 1 trong các mạng wifi sẽ in ra tên mạng wifi và set connectioWasAlive = true
  // để khi mất kết nối chương trình sẽ vào phần if (connectioWasAlive == true) nhằm thông báo đang
  // tìm kiếm mạng wifi
  else if (connectioWasAlive == false)
  {
    connectioWasAlive = true;
    Serial.printf(" connected to %s\n", WiFi.SSID().c_str());
  }
}

void loop()
{
  monitorWiFi();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_http_client">HTTP Client</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_giao_thức_http">Giao thức HTTP</h3>
<div class="paragraph">
<p><code>HTTP</code> - Hypertext Transfer Protocol (giao thức truyền dẫn siêu văn bản), là giao thức để truyền dữ liệu giữa các máy tính qua <code>www</code> (World Wide Web), với dữ liệu có thể là dạng text, file, ảnh, hoặc video.</p>
</div>
<div class="paragraph">
<p>HTTP được thiết kế để trao đổi dữ liệu giữa Client và Server trên nền TCP/IP, nó vận hành theo cơ chế <code>yêu cầu/trả lời</code>, <code>stateless - không lưu trữ trạng thái</code>. Trình duyệt Web chính là Client, và một máy chủ chứa Web Site là Server. Client sẽ kết nối tới Server, gởi dữ liệu đến server bao gồm các thông tin header. Server nhận được thông tin và căn cứ trên đó gởi phản hồi lại cho Client. Đồng thời đóng kết nối.</p>
</div>
<div class="paragraph">
<p>Một ví dụ điển hình là khi bạn gõ địa chỉ vào thanh địa chỉ của trình duyệt và nhấn <code>Enter</code>, thì ngay lập tức Web Client sẽ thực hiện việc gởi yêu cầu tới Web Server có địa chỉ mà bạn vừa gõ. Web Server sẽ trả lời bằng nội dung Web Site mà bạn cần xem.</p>
</div>
<div class="paragraph">
<p>Trong giao thức HTTP, việc thiết lập kết nối chỉ có thể xuất phát từ phía client ( lúc này có thể gọi là HTTP Client ). Khi client gửi yêu cầu, cùng với <strong>URL</strong> và payload ( dữ liệu muốn lấy ) tới server. Server ( HTTP Server ) lắng nghe mọi yêu cầu từ phía client và trả lời các yêu cầu ấy. Khi trả lời xong kết nối được chấm dứt.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/http1-req-res-details.png" alt="Cách thức HTTP hoạt động" width="400">
</div>
<div class="title">Hình 32. Cách thức HTTP hoạt động</div>
</div>
<div class="paragraph">
<p>Khi nhắc tới HTTP thì Hyperlink, hay URL (Uniform Resource Locator) là những khái niệm được thấy hàng ngày</p>
</div>
<div class="paragraph">
<p><strong>URL</strong> được dùng để định dạng địa chỉ Website, chứa các thông tin yêu cầu từ client và server dựa vào đó xử lý, cấu trúc của nó như hình:</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/http1-url-structure.png" alt="URL" width="400">
</div>
<div class="title">Hình 33. Cấu trúc 1 URL</div>
</div>
<div class="paragraph">
<p>Ví dụ bạn có thể gởi thông tin về nhiệt độ đến server thông qua đường dẫn: <code>http://esp8266.vn/log.php?nhiet_do=30</code></p>
</div>
<div class="listingblock">
<div class="title">Cấu trúc 1 URL</div>
<div class="content">
<pre class="highlightjs highlight"><code>|scheme  | host      |port |path            |query                |fragment|
 http:// server.com: 8080  /path/to/log.php ?nhiet_do=30&amp;do_am=80 #test</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>scheme</code> xác định giao thức truyền tới server, nếu là <code>https</code> thì sẽ được mã hóa.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>host</code> địa chỉ server.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>port</code> port server dùng để phục vụ, nếu ko có thì mặc định là <code>80</code> cho web.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>path</code> thông tin client muốn truy suất.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>query</code> thông tin client muốn gởi lên.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>fragment</code> thuộc tính này giúp browser đi đến vị trí của trang.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Với đường dẫn như trên, khi bạn gõ vào trình duyệt, thì trình duyệt sẽ thực hiện kết nối và gởi dữ liệu như sau.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>GET /log.php?nhiet_do=30 HTTP/1.1
Host: esp8266.vn
User-Agent: curl/7.49.1
Accept: */*</pre>
</div>
</div>
<div class="paragraph">
<p>Dữ liệu trả về:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive

data</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Trên linux, bạn có thể sử dụng curl để xem chi tiết dữ liệu raw truyền nhận, gõ lệnh  <code>curl -v http://esp8266.vn/log.php?nhiet_do=30</code> trên terminal
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_giao_thức_http_định_nghĩa_một_số_phương_thức_method_truyền_đến_server">Giao thức HTTP định nghĩa một số phương thức (method) truyền đến Server:</h4>
<div class="ulist">
<ul>
<li>
<p><code>GET</code> là phương thức yêu cầu dữ liệu đơn giản và thường sử dụng nhất của HTTP. Phương thức <strong>GET</strong> yêu cầu server chỉ trả về dữ liệu bằng việc cung cấp các thông tin truy vấn trên URL, thông thường Server căn cứ vào thông tin truy vấn đó trả về dữ liệu mà không thay đổi nó. <code>path</code> và <code>query</code> trong <strong>URL</strong> chứa thông tin truy vấn.</p>
</li>
<li>
<p><code>POST</code> tương tự như <code>GET</code>, nhưng <code>POST</code> có thể gởi dữ liệu về Server.</p>
</li>
<li>
<p><code>PUT</code> là phương thức yêu cầu tạo mới một dữ liệu, giống <code>POST</code> nhưng đánh dấu cho Server biết, nếu dữ liệu không tồn tại trong cơ sở dữ liệu thì tạo mới, hoặc sửa đổi nó.</p>
</li>
<li>
<p><code>DELETE</code> Tương tự như <code>GET</code>, nhưng báo cho Server biết về việc xóa dữ liệu thông qua URL.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Các phương thức thông thường chỉ dùng <code>GET</code> và <code>POST</code>, các phương thức còn lại thường sử dụng trong API server (RESTful). Một số điểm khác biệt giữ <code>POST</code> và <code>GET</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>GET</code> có thể bị cache (lưu trữ ở trình duyệt và sử dụng lại sau đó), nội dung request có thể lưu trữ ở lịch sử trình duyệt, có thể được đánh dấu (bookmark).</p>
</li>
<li>
<p><code>GET</code> không nên sử dụng để gởi các dữ liệu nhạy cảm.</p>
</li>
<li>
<p><code>GET</code> bị giới hạn độ lớn dữ liệu cần gởi.</p>
</li>
<li>
<p><code>GET</code> chỉ nên dùng để lấy dữ liệu về.</p>
</li>
<li>
<p><code>POST</code> không bị catch, không tồn tại dữ liệu gởi trong lịch sử trình duyệt, không thể đánh dấu (bookmark).</p>
</li>
<li>
<p><code>POST</code> không giới hạn bởi độ lớn dữ liệu cần gởi.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_http_header_status_code">HTTP Header &amp; Status Code</h4>
<div class="paragraph">
<p>Dữ liệu trả về bao giờ cũng có phần thông tin header với dòng đầu tiên chưa Status Code <code>HTTP/1.1 200 OK</code> có nghĩa là status code = 200, request được trả về phù hợp.
Theo sau đó là các cặp header chứa thông tin Server muốn trao đổi với Client, mà nếu là trình duyệt thì nó bị ẩn đi (người dùng bình thường không thể thấy). Các cặp header này định dạng theo kiểu <code>name: value</code> và kết thúc bằng ký tự xuống dòng không thấy bằng mắt thường (<code>0x0D 0x0A</code> hay <code>\r\n</code>).
Trong ví dụ trên, thông tin header <code>Content-Type: text/html; charset=utf-8</code> báo cho trình duyệt biết rằng định dạng dữ liệu gởi về là dạng text, mã hóa utf-8. <code>Transfer-Encoding: chunked</code> chiều dài dữ liệu không được biết trước và gởi cho tới khi server đóng kết nối.</p>
</div>
<div class="paragraph">
<p>Một số HTTP status code thường thấy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>1xx</strong>: Mã trạng thái thông tin. Bản chất của mã trạng thái này, chỉ để thông báo với client rằng request đã được chấp nhận. Các mã trạng thái thông tin này được quy định trong <strong>HTTP/1.1</strong>, còn phiên bản <strong>HTTP/1.0</strong> hay trước đó thì không có, có thể bỏ qua phần mã trạng thái này. Các mã hay gặp:</p>
<div class="ulist">
<ul>
<li>
<p><strong>100 Continue</strong>: Thông báo cho Client biết là có thể gửi tiếp phần request còn lại nếu còn, kết thúc nếu đã hết. Nếu trong request POST, phần thân request lớn sẽ bị server từ chối và để giải quyết điều này thì client phải gửi <strong>Expect: 100-continue</strong> theo sau phần header ban đầu.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>2xx</strong>: Nhóm mã trạng thái này thông báo với Client rằng request đã được nhận, hiểu và xử lý thành công. Với một số mã thường thấy:</p>
<div class="ulist">
<ul>
<li>
<p><strong>200 OK</strong>: Thông báo cho Client biết là request đã gửi thành công. Có thể thấy mã trạng thái này trong các phương thức <strong>GET</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>TRACE</strong>.</p>
</li>
<li>
<p><strong>201 Created</strong>: Cho biết request đã xử lý thành công và tài nguyên đã được khởi tạo. Được sử dụng để xác nhận sự thành công của một request <strong>PUT</strong> hoặc <strong>POST</strong>.</p>
</li>
<li>
<p><strong>204 No Content</strong>: Thông báo không có phần thân message trong response.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>3xx</strong>: Nhóm mã trạng thái thông báo Client còn phải thực hiện thêm hành động để hoàn thành request. Mã trạng thái thường gặp trong nhóm:</p>
<div class="ulist">
<ul>
<li>
<p><strong>301 Moved Permanently</strong>: Thông báo tài nguyên được yêu cầu đã được chuyển hướng sang một URL mới và server sẽ gửi URL mới này trong response cho Client biết.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>4xx</strong>: Nhóm mã thông báo các lỗi từ phía Client. Được sử dụng khi server cho rằng phía Client đang xảy ra lỗi, với một request, hoặc tài nguyên không hợp lệ, hoặc một request không đúng. Các mã thông dụng:</p>
<div class="ulist">
<ul>
<li>
<p><strong>400 Bad Request</strong>: Thông báo request đã gửi là sai.</p>
</li>
<li>
<p><strong>401 Unauthorized</strong>: Chỉ ra rằng request cần được xác thực. Client có thể gửi lại request với header đã được xác thực. Trường hợp đã đính kèm header xác thực nhưng vẫn nhận được thông báo này tức là header xác thực chưa hợp lệ.</p>
</li>
<li>
<p><strong>403 Forbidden</strong>: Server từ chối quyền truy cập của Client.</p>
</li>
<li>
<p><strong>404 Not Found</strong>: Thông báo tài nguyên không hợp lệ và không tồn tại trên server.</p>
</li>
<li>
<p><strong>409 Conflict</strong>: Server không thể hoàn thành yêu cầu vì Client cố chỉnh sửa tài nguyên mới hơn so với <strong>timestamp</strong> của Client. Xung đột xảy ra chủ yếu trong các request <strong>PUT</strong> trong quá trình hợp tác chỉnh sửa tài nguyên.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>5xx</strong>: Nhóm lệnh thông báo server đang ở trong tình trạng lỗi hoặc không có khả năng thực hiện yêu cầu. Một số mã thường gặp:</p>
<div class="ulist">
<ul>
<li>
<p><strong>500 Internal Server Eror</strong>: Cho biết là không thể thực hiện request của Client.</p>
</li>
<li>
<p><strong>501 Not Implemented</strong>: Thông báo server không có phương thức được yêu cầu hoặc không có khả năng hổ trợ chức năng mà Client đã request.</p>
</li>
<li>
<p><strong>503 Service Unavailable</strong>: Xảy ra khi hệ thống của server đang bảo dưỡng hoặc quá tải.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_json">JSON</h3>
<div class="paragraph">
<p>JSON (JavaScript Object Notation) là 1 định dạng trao đổi dữ liệu để giúp việc đọc và viết dữ liệu trở nên dễ dàng hơn, máy tính cũng sẽ dễ phân tích và tạo ra JSON. Chúng là cơ sở dựa trên tập hợp của ngôn ngữ lập trình JavaScript. JSON là 1 định dạng kiểu text mà hoàn toàn độc lập với các ngôn ngữ hoàn chỉnh, thuộc họ hàng với các ngôn ngữ trong họ hàng của C, gồm có C, C++, C#, Java, JavaScript, Perl, Python, và nhiều ngôn ngữ khác. Những đặc tính đó đã tạo nên JSON 1 ngôn ngữ hoán vị dữ liệu lý tưởng.</p>
</div>
<div class="paragraph">
<p>JSON được xây dựng trên 2 cấu trúc:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Là tập hợp của các cặp tên và giá trị name-value. Trong những ngôn ngữ khác nhau, đây có thể là 1 object, record, struct, dictionary, hash table, keyed list hay associative array.</p>
</li>
<li>
<p>Là 1 tập hợp các giá trị đã được sắp xếp. Trong hầu hết các ngôn ngữ, dữ liệu này được xem như array, véc tơ, list hay sequence.
Đây là 1 cấu trúc dữ liệu phổ dụng. Hầu như tất cả các ngôn ngữ lập trình hiện đại đều hổ trợ. Chúng tạo nên ý nghĩa của 1 định dạng hoán vị dữ liệu với các ngôn ngữ lập trình cũng đã được cơ sở hoá trên cấu trúc này.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cú pháp</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dữ liệu nằm trong các cặp name/value</p>
</li>
<li>
<p>Các dữ liệu được ngăn cách bởi dấy phẩy <code>,</code></p>
</li>
<li>
<p>Các đối tượng (name/value) nằm giữa hai dấu ngoặc kép <code>"</code></p>
</li>
<li>
<p>Tất cả các đối tượng nằm bên trong hai dấu ngoặc nhọn <code>{}</code></p>
</li>
<li>
<p>Dữ liệu của JSON được viết theo từng cặp name/value. Một cặp name/value bao gồm trường <code>name</code> ( nằm trong hai dấu ngoặc kép <code>"</code>, theo sau là dấu hai chấm <code>:</code>, và sau cùng là trường <code>value</code> (cũng được nằm trong hai dấu ngoặc kép <code>"</code>. Ví dụ: <code>"name":"John"</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "username" : "your-user-name",
    "email" : "your-email@email.com",
    "website" : "iota.edu.vn",
    "title" : "IoT Stater Cource"
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Ứng_dụng_xem_giá_bitcoin">Ứng dụng xem giá Bitcoin</h3>
<div class="paragraph">
<p>Một ứng dụng đơn giản sử dụng giao thức HTTP để lấy tỉ giá Bitcoin (BTC)/USD từ các trang Web giao dịch, hiển thị lên màn hình OLED.</p>
</div>
<div class="paragraph">
<p>Chúng ta có rất nhiều nguồn lấy tỉ giá, một trong số đó là <a href="https://www.cryptocompare.com/" class="bare">www.cryptocompare.com/</a>. Với tài liệu được cung cấp, và nhu cầu là chỉ lấy tỉ giá Bitcoin/USD, chúng ta chỉ cần ESP8266 gởi 1 HTTP Request đến <a href="https://min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD" class="bare">min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD</a> thì sẽ nhận được một chuỗi JSON dạng như:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{"USD":4731.44}</code></pre>
</div>
</div>
<div class="paragraph">
<p>và giá trị của trường <code>USD</code> chính là giá trị chúng ta muốn hiển thị.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Đa số các dịch vụ Web hiện nay đều sử dụng giao thức bảo mật <code>HTTPS</code>, về cơ bản nó cũng là HTTP, nhưng quá trình truyền nhận được mã hóa dữ liệu, thực hiện xác thực trước khi gửi giữa Client và Server.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Khi dùng HTTPS, chúng ta cần cung cấp SHA1 Fingerpint để Client có thể xác thực server. Bạn có thể dùng trình duyệt để truy cập trước để lấy. Nếu là <code>Chrome</code>, sau khi truy cập vào địa chỉ <a href="https://min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD" class="bare">min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD</a>, Nhấn Ctrl+Shift+I (Shift + ⌘ + I với MacOS) và đi đến <code>Security &gt; View Certificate &gt; Details &gt; Thumbprint</code>. Bạn sẽ thấy hình như bên dưới, và copy nó.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/fingerprint.png" alt="HTTPS Finger print" width="500">
</div>
<div class="title">Hình 34. HTTPS Fingerprint</div>
</div>
<div class="paragraph">
<p>Đây là đoạn Code lấy giá Bitcoin, cứ mỗi 5 giây, ESP8266 sẽ kết nối đến Cryptocompare server để lấy thông tin và hiển thị lên OLED.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266HTTPClient.h&gt;
#include &lt;ArduinoJson.h&gt; //https://github.com/bblanchon/ArduinoJson
#include "SSD1306.h" //https://github.com/squix78/esp8266-oled-ssd1306

const char* ssid = ".....";
const char* password = "....";
SSD1306  display(0x3c, 4, 5);
/* xem thêm https://www.cryptocompare.com/api/ */
const char* host = "https://min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD";
/*SHA1 fingerprint*/
const char* fingerprint = "61 DE E9 FF BB 6B AD AA E4 9A 38 95 DC EC 74 2C 61 4B 7D 07";

void getBitcoin()
{
  HTTPClient http;
  Serial.print("connecting to ");
  Serial.println(host);

  http.begin(host, fingerprint);
  int httpCode = http.GET();
  if (httpCode == HTTP_CODE_OK) {
    String payload = http.getString();
    Serial.println(payload);
    StaticJsonBuffer&lt;512&gt; jsonBuffer;
    JsonObject&amp; root = jsonBuffer.parseObject(payload);
    if (!root.success()) {
      Serial.println("parseObject() failed");
      return;
    }

    double priceUSD = root["USD"];
    display.clear();
    display.drawString(0, 0, "Bitcoin price");
    display.drawString(0, 18, String(priceUSD));
    display.display();
    Serial.println(priceUSD);
  }
  http.end();
}

void setup() {
  Serial.begin(115200);
  display.init();
  display.clear();
  display.setFont(ArialMT_Plain_16);
  display.drawString(0, 0, "Connecting to");
  display.drawString(0, 18, ssid);
  display.display();
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  display.clear();
  display.drawString(0, 0, "Connected");
  display.display();
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    getBitcoin();
  }
  delay(5000);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/btc.png" alt="BTC Price" width="500">
</div>
<div class="title">Hình 35. Kết quả lấy giá Bitcoin và hiện thị mỗi 5 giây</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_chế_độ_wifi_access_point">Chế độ WiFi Access Point</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_esp8266_hoạt_động_ở_chế_độ_access_point">ESP8266 hoạt động ở chế độ Access Point</h3>
<div class="paragraph">
<p>ESP8266 có khả năng cho phép các thiết bị khác (Station - STA) truy cập vào và hoạt động như là 1 Access Point, có thể tự thiết lập 1 mạng WiFi nội bộ, với khả năng khởi động DHCP Client và cung cấp được IP cho các Client kết nối tới. Do giới hạn về RAM, nên số lượng tối đa các STA có thể kết nối đến một ESP8266 hiện tại là 5.</p>
</div>
<div class="sect3">
<h4 id="_khởi_tạo_mạng">Khởi tạo mạng</h4>
<div class="paragraph">
<p>Đầu tiên bạn cần include <code>&lt;ESP8266WiFi.h&gt;</code>, thư viện này chứa hàm <code>softAP</code> dùng để cấu hình Access Point mềm (soft AP) để khởi tạo một mạng WiFi.</p>
</div>
<div class="paragraph">
<p>Một mạng WiFi đơn giản nhất chỉ cần cung cấp tên SSID và không mật khẩu <code>WiFi.softAP(ssid)</code>. Phức tạp hơn, bạn cung cấp mật khẩu cho mạng WiFi <code>WiFi.softAP(ssid, password)</code>, hoặc chi tiết <code>WiFi.softAP(ssid, password, channel, hidden)</code> khi cung cấp chính xác kênh truyền (1..13), mặc định 1 và ẩn nó đi, không hiển thị ra khi <code>hidden = true</code></p>
</div>
<div class="paragraph">
<p>Nhớ rằng <code>ssid</code> sử dụng chuỗi ký tự không quá 63, và mật khẩu (có thể không cần) với tối thiểu 8 ký tự cho mạng WPA2-PSK</p>
</div>
<div class="paragraph">
<p>Hàm <code>softAP</code> sẽ trả về <code>true</code> nếu khởi tạo thành công mạng WiFi</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Lưu ý rằng, mạng WiFi khởi tạo bởi hàm <code>softAP</code> sẽ sử dụng địa chỉ IP mặc định là <code>192.168.4.1</code>, và chạy 1 DHCP Server cung cấp dải IP cho client kết nối tới là <code>192.168.1.x</code>. Bạn có thể thay đổi địa chỉ IP mặc định này bằng hàm <code>softAPConfig</code>. Ngoài ra, ESP8266 có thể chạy được song song 2 chế độ Station và Access Point, nhưng lưu ý, chỉ được 1 channel, và channel của softAP sử dụng bởi channel của Station.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>WiFi.softAPConfig (local_ip, gateway, subnet)</code> dùng để cấu hình IP cho Access Point</p>
</div>
<div class="listingblock">
<div class="title">Cấu hình địa chỉ IP cho ESP8266 AP là <code>192.168.4.22</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">IPAddress local_IP(192,168,4,22);
IPAddress gateway(192,168,4,9);
IPAddress subnet(255,255,255,0);
WiFi.softAPConfig(local_IP, gateway, subnet)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WiFi.softAPgetStationNum()</code> sẽ trả về số lượng client đang kết nối tới Access Point</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_khởi_tạo_mạng_wifi_sử_dụng_esp8266">Khởi tạo mạng WiFi sử dụng ESP8266</h3>
<div class="paragraph">
<p>Với đoạn code này, bạn có thể tạo ra một mạng WiFi cục bộ có SSID là <code>AP-XXXXXX</code> và có thể dùng máy tính để kết nối trực tiếp vào với password là <code>password</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;

const char *password = "password";

void setup() {
  Serial.begin(115200);
  Serial.print("Configuring access point...");
  char ssid[64];
  sprintf(ssid, "AP-%06X", ESP.getChipId());
  WiFi.softAP(ssid, password);

  IPAddress myIP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(myIP);
}

void loop() {
  Serial.printf("Stations connected = %d\n", WiFi.softAPgetStationNum());
  delay(3000);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/03-wifi/ap.png" alt="WiFiAccesspoint" width="200">
</div>
<div class="title">Hình 36. Khi khởi động 1 WiFiAccesspoint</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="web-server">Web Server</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_web_server_là_gì">Web Server là gì?</h3>
<div class="paragraph">
<p>Web Server là một máy chủ Web mà khi có bất kỳ một Web Client nào (chẳng hạn Web Browser) truy cập vào, thì nó sẽ căn cứ trên các thông tin yêu cầu truy cập để xử lý, và phản hồi lại nội dung. Đa phần các nội dung Web Server phục vụ là HTML, Javascript, CSS, JSON và bao gồm cả các dữ liệu Binary.</p>
</div>
<div class="paragraph">
<p>Mặc định các Web Server phục vụ trên Port 80, và 443 cho dịch vụ Web có bảo mật <code>HTTPS</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_html_javascript_css">HTML - Javascript - CSS</h3>
<div class="paragraph">
<p>HTML, Javascript và CSS là ba ngôn ngữ để xây dựng và phát triển Web. Những hiểu biết cơ bản về chúng sẽ tạo điều kiện thuận lợi cho các quá trình tiếp theo sau được dễ dàng hơn.</p>
</div>
<div class="sect3">
<h4 id="_html">HTML</h4>
<div class="paragraph">
<p>Viết đầy đủ là <strong>Hyper Text Markup Language</strong> - ngôn ngữ đánh dấu siêu văn bản dùng để cấu trúc nội dung của một trang Web, ví dụ như: chỉ định các đoạn văn bản, tiêu đề, bảng dữ liệu, hoặc nhúng hình ảnh hoặc video vào Web. Mỗi trang Web chứa một loạt các liên kết đến các trang khác được gọi là <code>hyperlinks</code> (siêu liên kết). Mỗi trang được tạo ra từ nhiều <code>tag</code> (thẻ) khác nhau, với cấu trúc một <code>tag</code> như sau</p>
</div>
<div class="listingblock">
<div class="title">Cấu trúc 1 tag</div>
<div class="content">
<pre class="highlightjs highlight"><code>&lt;tagname&gt; nội dung tag...&lt;/tagname&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Các tag thường đi theo cặp, bắt đầu bởi &lt;tagname&gt; và kết thúc bằng &lt;/tagname&gt;</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Tag kết thúc phải có dấu gạch chéo <code>/</code> phía trước tên thẻ.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Trang HTML cơ bản có thể được thấy như sau:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;Page Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

	&lt;h1&gt;This is a Heading&lt;/h1&gt;
	&lt;p&gt;This is a paragraph.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Với một số tag cơ bản như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;!DOCTYPE html&gt;</code> cho biết là HTML5.</p>
</li>
<li>
<p><code>&lt;html&gt;</code> root của trang HTML.</p>
</li>
<li>
<p><code>&lt;head&gt;</code> chứa thông tin về tài liệu.</p>
</li>
<li>
<p><code>&lt;title&gt;</code> phần tiêu đề trang.</p>
</li>
<li>
<p><code>&lt;body&gt;</code> phần chứa nội dung trang hiển thị.</p>
</li>
<li>
<p><code>&lt;h1&gt;</code> nơi chứa phần tiêu đề chính.</p>
</li>
<li>
<p><code>&lt;p&gt;</code> phần ghi các đoạn văn bản.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_javascript">Javascript</h4>
<div class="paragraph">
<p>Javascript là một ngôn ngữ được thiết kế chủ yếu để thêm tương tác vào các trang Web, và tạo ra các ứng dụng Web.</p>
</div>
<div class="paragraph">
<p>Các chương trình Javascript có thể được nhúng trực tiếp vào HTML của Web. Và tùy vào mục đích cụ thể, script có thể chạy khi mở trang Web, nhấp chuột, gõ phím, gửi biểu mẫu, cập nhật dữ liệu, giao tiếp với cơ sở dữ liệu&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Để nhúng chương trình viết bằng Javascript vào trang HTML, chỉ cần thêm tag <code>&lt;script&gt;</code> và thuộc tính <code>type</code>. Có thể thêm phần này ở phần <code>&lt;head&gt;</code> hoặc phần <code>&lt;body&gt;</code> của HTML. Ví dụ sau đây minh họa việc thêm một chương trình Javascript vào phần thân (&lt;body&gt;) của HTML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;My first JavaScript page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


  &lt;script type="text/javascript"&gt;
    // chương trình Javascript nên được viết ở đây
    // ngay trước &lt;/body&gt;
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_css">CSS</h4>
<div class="paragraph">
<p>CSS là từ viết tắt của <strong>Cascading Style Sheets</strong>, là một ngôn ngữ được thiết kế để xử lý giao diện Web, giúp các trang Web được đẹp hơn. CSS có thể kiểm soát được màu sắc của văn bản, phong chữ, kích cỡ chữ, khoảng cách giữa các đoạn văn, hình nền hoặc màu nền, và nhiều hiệu ứng khác.</p>
</div>
<div class="paragraph">
<p>Một đoạn CSS bao gồm 4 phần như thế này:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-css hljs" data-lang="css">vùng-chọn {
   thuộc-tính-a: giá-trị-x;
   thuộc-tính-b: giá-trị-y;
   .....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ví dụ về sử dụng CSS trong HTML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My first JavaScript page&lt;/title&gt;
  &lt;style&gt;
    .class-select {
      background-color: red;
    }

    #id-select {
      background-color: green;
    }

    div {
      color: blue;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="id-select"&gt; css select by id &lt;/div&gt;
  &lt;div class="class-select"&gt; css select by class &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Với đoạn HTML bên trên, thì màu nền của tag div có id = <code>id-select</code> sẽ có màu xanh lá cây, tag div có class = <code>class-select</code> sẽ có màu đỏ, và chữ của tất cả những thẻ div có màu xanh nước biển.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Ứng_dụng_điều_khiển_đèn_led_thông_qua_webserver">Ứng dụng điều khiển đèn LED thông qua Webserver</h3>
<div class="paragraph">
<p>ESP8266 hoàn toàn có thể thực hiện vai trò Web Server để phục vụ cho một vài kết nối đến, tận dụng giao diện Web để điều khiển, cấu hình cho nó.</p>
</div>
</div>
<div class="sect2">
<h3 id="_esp8266_web_server">ESP8266 Web Server</h3>
<div class="paragraph">
<p>Với ứng dụng này, ESP8266 sẽ khởi tạo 1 Web Server, khi có bất kỳ client nào kết nối tới (Web Browser) thì ESP8266 sẽ gởi về 1 trang HTML với các thông tin để Client có thể điều khiển chớp tắt đèn LED của board.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266WebServer.h&gt;

const char* ssid = "........";
const char* password = "........";
const int led = 16; //LED pin = gpio16
/* HTML sẽ được gởi xuống client */
const char *html = \
"&lt;html&gt;\
  &lt;head&gt;\
    &lt;title&gt;ESP8266 Webserver&lt;/title&gt;\
  &lt;/head&gt;\
  &lt;body&gt;\
    &lt;a href=\"/on\"&gt;ON&lt;/a&gt;\
    &lt;a href=\"/off\"&gt;OFF&lt;/a&gt;\
  &lt;/body&gt;\
&lt;/html&gt;";

/* Web Server lắng nghe ở port 80 */
ESP8266WebServer server(80);

/* hàm này được gọi khi trình duyệt truy vấn đến '/on'
 * sẽ bật đèn LED (0 = on), sau đó chuyển hướng trình duyệt
 * về lại trang chủ '/'
 */
void handleOn() {
  digitalWrite(led, 0);
  server.sendHeader("Location","/");
  server.send(301);
}

/* hàm này được gọi khi trình duyệt truy vấn đến '/off'
 * sẽ tắt đèn LED (1 = off), sau đó chuyển hướng trình duyệt
 * về lại trang chủ '/'
 */
void handleOff() {
  digitalWrite(led, 1);
  server.sendHeader("Location","/");
  server.send(301);
}

/* hàm này được gọi khi trình duyệt truy vấn đến trang chủ '/'
 * sẽ gởi dữ liệu HTML, cung cấp các thông tin để bật, tắt LED
 */
void handleRoot() {
  server.send(200, "text/html", html);
}

void setup(void){
  pinMode(led, OUTPUT);
  digitalWrite(led, 0);
  Serial.begin(115200);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");

  /* Chúng ta có thể biết IP của ESP8266
   * để kết nối tới nhờ gọi hàm này
   */
  Serial.println(WiFi.localIP());

  server.on("/", handleRoot);
  server.on("/on", handleOn);
  server.on("/off", handleOff);
  server.begin();
  Serial.println("HTTP server started");
}

void loop(void){
  server.handleClient();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_kết_hợp_wifi_ap_và_web_server">Kết hợp WiFi AP và Web Server</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_trao_đổi_dữ_liệu_giữa_2_esp8266">Trao đổi dữ liệu giữa 2 ESP8266</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thông thường, muốn hai hay nhiều ESP8266 có thể liên lạc, trao đổi dữ liệu với nhau sẽ cần đến một router hay access-point, các module ESP8266 này sẽ kết nối vào Access Point rồi sau đó giao tiếp với nhau.</p>
</div>
<div class="paragraph">
<p>Có một số ứng dụng đơn giản để kết nối 2 ESP8266 với nhau mà không cần Access Point, chúng ta có thể khởi tạo 1 board hoạt động như là  WiFi Access Point, đồng thời khởi tạo 1 TCP Server. Board khác hoạt động như 1 WiFi client thông thường, kết nối vào mạng WiFi đã được tạo, và khởi động 1 TCP Client kết nối vào TCP Server kia.</p>
</div>
<div class="sect2">
<h3 id="_yêu_cầu">Yêu cầu</h3>
<div class="ulist">
<ul>
<li>
<p>Không cần bất kỳ một Router, hay Access Point nào, thực hiện việc kết nối giao tiếp giữa 2 ESP8266 thông qua mạng WiFi, 2 Board này sẽ truyền dữ liệu với nhau mỗi giây, và hiển thị lên Serial Terminal</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_hướng_dẫn_thực_hiện">Hướng dẫn thực hiện</h3>
<div class="paragraph">
<p>Để trao đổi dữ liệu giữa 2 ESP8266 cần đáp ứng các điều kiện sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1 ESP8266 sẽ khởi động <em>SoftAP</em> để tạo mạng WiFi, đồng thời khởi động 1 TCP Server để làm Server.</p>
</li>
<li>
<p>1 ESP8266 phải là client với chế độ <em>WiFi Station</em> và kết nối đến ESP8266 server đã tạo ở trên.</p>
</li>
<li>
<p>Sau mỗi giây, Board ESP8266 này sẽ gởi dữ liệu vào Board kia, board nhận được dữ liệu sẽ in ra cổng Serial và gởi ngược lại.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_code">Code</h3>
<div class="listingblock">
<div class="title">P2P server</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;

#define PORT  23
// Gioi han so luong clients ket noi
#define MAX_CLIENTS 3

// Ten va mat khau cua ESP8266 AP se tao
const char *ssid = "yourSSID";
const char *password = "yourPassword";

//khoi tao IP adress
IPAddress local_IP(192, 168, 4, 1);
IPAddress gateway(192, 168, 4, 1);
IPAddress subnet(255, 255, 255, 0);

// Khoi tao port de clients ket noi.
WiFiServer server(PORT);
WiFiClient clients[MAX_CLIENTS];

void setup() {
  Serial.begin(115200);
  Serial.println();
  Serial.print("Setting soft-AP configuration ... ");

  //Cau hinh acces point, cai dat soft AP de client ket noi vao.
  WiFi.softAPConfig(local_IP, gateway, subnet);
  WiFi.softAP(ssid, password);

  //In ra local_IP cua AP.
  Serial.print("AP IP address: ");
  Serial.println(WiFi.softAPIP());
  Serial.println("Telnet server started");
  server.begin();
}

void loop() {
  uint8_t i;
  // kiem tra co client moi ket noi khong
  if (server.hasClient())  {
    for (i = 0; i &lt; MAX_CLIENTS; i++) {
      if (!clients[i] || !clients[i].connected())
      { if (clients[i]) clients[i].stop();
        clients[i] = server.available();
        Serial.print("New client: "); Serial1.print(i);
        continue;
      }
    }
    WiFiClient serverClient = server.available();
    serverClient.stop();
  }
  // Kiem tra neu so client ket noi MAX_CLIENTS
  // co client, client duoc ket noi va o trang thai available
  // doc du lieu tu client, va gui lai du lieu cho client do.
  for (i = 0; i &lt; MAX_CLIENTS; i++) {
    if (clients[i] &amp;&amp; clients[i].connected()) {
      if (clients[i].available()) {
        String line = clients[i].readStringUntil('\r');
        Serial.print("Server receive from Client:");
        Serial.println(line);

        //Gui thong tin hoai dap cho client
        String resp = String(line.reserve(line.length() - 1));
        Serial.print(" Then, response back to client:");
        Serial.println(resp);
        clients[i].write(resp.c_str());
        Serial.println();
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">P2P client</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include "ESP8266WiFi.h"
// Ten va mat khau cua ESP8266 AP lam server se vao
const char *ssid = "yourSSID";
const char *password = "yourPassword";

IPAddress server_ip(192, 168, 4, 1);
#define PORT  23
// port 23 la port cua esp8226 lam AP da khoi tao.
WiFiClient client;

void setup() {
  uint8_t i = 0;
  Serial.begin(115200);
  WiFi.begin(ssid, password);

  Serial.print("\nConnecting to ");
  Serial.println(ssid);

  // Kiem tra tình trang ket noi, neu chua ket noi duoc
  // se in chuoi "connecting..." tren man hinh serial terminal.
  while (WiFi.status() != WL_CONNECTED) {
    Serial.println("Connecting...");
    delay(500);
  }
}

unsigned long previousMillis = 0;
void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    // Kiem tra neu client(STA) chua duoc ket noi.
    // Kiem tra tiep tuc neu khong duoc ket noi den IP va PORT cua server(AP
    // thi in ra serial terminal chuoi "connection failed".
    while (!client.connected()) {
      if (!client.connect(server_ip, PORT)) {
        Serial.println("connection failed");
        delay(1000);
        return;
      }
    }
    // Neu client(STA) duoc ket noi thi se doc du lieu tu server(AP)
    // den khi gap ki tu \r va in ra seria terminal du lieu nhan duoc.
    while (client.available()) {

      String line = client.readStringUntil('\r');
      Serial.print("Client receive from Server:");
      Serial.println(line);
    }
    //Send PING to server every 1000ms.
    unsigned long currentMillis = millis();
    if (currentMillis - previousMillis &gt;= 1000) {
      previousMillis = currentMillis;
      client.write("PING\r");
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tổng_kết_4">Tổng kết</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Trong phần này, chúng ta đã nắm rõ các chế độ hoạt động của ESP8266, các giao thức truyền TCP/IP, HTTP và các định dạng HTML, CSS, Javascript. Ngoài các ví dụ thực tiễn sử dụng ESP8266 như HTTP Client ở hướng dẫn trên, bạn có thể sử dụng HTTPClient để kết nối đến các Server tự tạo, gởi dữ liệu cảm biến đến Server, cũng như lấy dữ liệu từ Server để thực thi các tác vụ.</p>
</div>
<div class="paragraph">
<p>Chế độ WiFi Access Point và Web Server chạy trên ESP8266 thường sử dụng để cấu hình các thông số cho sản phẩm, sử dụng giao diện Web có ở bất kỳ máy tính nào để cung cấp các thông số phức tạp cho ứng dụng một cách dễ dàng.</p>
</div>
</div>
</div>
<h1 id="_DHT11_logger" class="sect0">Dự án đọc cảm biến DHT11 và gởi về Server</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Trong bài này chúng ta sẽ xây dựng ứng dụng dùng cảm biến DHT11 để thu thập nhiệt độ, độ ẩm của môi trường. Thông tin về nhiệt độ và độ ẩm sẽ được hiển thị trên máy tính và hiển thị trên trình duyệt web bằng cách truy cập vào 1 địa chỉ URL được chỉ định. Một số kiến thức cần thiết :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Nhiệt độ</strong> là đại lượng thể hiện tính chất vật lý <code>nóng, lạnh</code> của vật chất. Nhiệt độ được đo bằng các đơn vị khác nhau và có thể biến đổi bằng các công thức. Trong hệ đo lường quốc tế, nhiệt độ được đo bằng đơn vị Kelvin, ký hiệu là K. Trong đời sống ở Việt Nam và nhiều nước, nó được đo bằng độ C.</p>
</li>
<li>
<p><strong>Độ ẩm tương đối</strong> là tỷ số của áp suất hơi nước hiện tại của bất kỳ một hỗn hợp khí nào với hơi nước so với áp suất hơi nước bão hòa tính theo đơn vị là %. Định nghĩa khác của độ ẩm tương đối là tỷ số giữa khối lượng nước trên một thể tích hiện tại so với khối lượng nước trên cùng thể tích đó khi hơi nước bão hòa</p>
</li>
<li>
<p><strong>DHT11</strong> là một cảm biến có khả năng đo nhiệt độ và độ ẩm không khí với độ chính xác vừa phải, giá cả phải chăng. Có thể lấy dữ liệu đo được của cảm biến bằng giao thức OneWire.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_thiết_kế_ứng_dụng">Thiết kế ứng dụng</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hình ảnh bên dưới mô tả tổng quan dự án</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/projectIntro.png" alt="projectIntro" height="596">
</div>
<div class="title">Hình 37. Tổng quan mô hình của dự án</div>
</div>
<div class="paragraph">
<p>Trong thực tế, khi thiết kế ứng dụng, người dùng cần một giao diện giám sát và điều khiển thân thiện, đồng thời có thể phát triển thêm các tính năng như hiển thị kết quả dưới dạng đồ thị (chart), lưu trữ dữ liệu theo thời gian chỉ định hay điều khiển trạng thái các thiết bị chỉ với 1 click chuột trên máy tính. Các dự án với mô hình phức tạp sẽ cần quản lí các kết nối cũng như dữ liệu của các thiết bị&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Chúng ta sẽ giải quyết những vấn đề trên thông qua ứng dụng đọc nhiệt độ, độ ẩm của môi trường và gửi về server. Đây là một ứng dụng khá đơn giản, hữu ích và dễ làm. Thông qua phần này chúng ta có thể xây dựng được một ứng dụng <strong>IoT</strong> thực tế, nắm bắt được các kiến thức cơ bản về thu thập dữ liệu, xây dựng thiết bị và server.</p>
</div>
<div class="sect2">
<h3 id="_yêu_cầu_2">Yêu cầu</h3>
<div class="ulist">
<ul>
<li>
<p>Dùng cảm biến DHT11 để thu thập nhiệt độ, độ ẩm của môi trường và kết nối với board mạch ESP8266</p>
</li>
<li>
<p>Board mạch ESP8266 sẽ kết nối không dây đến mạng WiFi và gởi dữ liệu về HTTP Server</p>
</li>
<li>
<p>Phần cơ bản: HTTP Server hiển thị dữ liệu nhiệt độ, độ ẩm ra màn hình Log trên máy tính</p>
</li>
<li>
<p>Phần nâng cao: HTTP Server lưu trữ dữ liệu, và cung cấp file HTML cho người dùng có thể xem qua Browser</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_phân_tích">Phân tích</h3>
<div class="ulist">
<ul>
<li>
<p>Chúng ta cần 1 Web Server viết bằng Javascript, thực thi bởi Node.js, lắng nghe ở Port được chỉ định trên máy tính cá nhân. Ở đây là port 8000</p>
</li>
<li>
<p>Máy tính phải có kết nối cùng mạng WiFi nội bộ với ESP8266 và cần biết địa chỉ IP của máy tính để ESP8266 có thể truy cập, ví dụ IP là <code>192.168.1.102</code></p>
</li>
<li>
<p>ESP8266 sau khi kết nối vào mạng WiFi nội bộ, sẽ tiến hành đọc thông số nhiệt độ, độ ẩm từ cảm biến DHT11 và gởi về Server sau mỗi 2 giây.</p>
</li>
<li>
<p>Quá trình gởi được thực hiện bởi phương thức <code>GET</code>, ví dụ <code>http://192.168.1.102/update?temp=25&amp;humd=80</code> với <code>192.168.1.102</code> là địa chỉ Web Server, <code>/update</code> là đường dẫn, <code>temp=20</code> và <code>humd=80</code> chứa thông tin nhiệt độ 20 độ C và độ ẩm 80%.</p>
</li>
<li>
<p>Web Server trả về trạng thái HTTP status = 200 (OK), cùng với việc hiển thị ra cửa sổ log giá trị nhiệt độ, độ ẩm.</p>
</li>
<li>
<p>Ở phần nâng cao:&#8201;&#8212;&#8201;Web Server lưu trữ dữ liệu nhiệt độ, độ ẩm trong mảng, chứa ở bộ nhớ RAM&#8201;&#8212;&#8201;Web Server còn cung cấp 1 file <code>index.html</code> chứa mã Javascript có thể yêu cầu lấy dữ liệu nhiệt độ, độ ẩm lưu trong RAM, và hiển thị lên biểu đồ</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_kiến_thức_4">Kiến thức</h3>
<div class="paragraph">
<p>Sẽ dễ dàng hơn nếu chúng ta có những kiến thức cơ bản về</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Chuẩn truyền dữ liệu OneWire giữa các IC</p>
</li>
<li>
<p>Ngôn ngữ Javascript để xây dựng server bằng cách dùng Node.js</p>
</li>
<li>
<p>Ngôn ngữ HTML để xây dựng 1 trang html đơn giản nhằm hiển thị dữ liệu</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tuy nhiên cũng đừng quá lo lắng nếu bạn chưa từng dùng những thứ này, chúng ta sẽ hiểu nó khi đọc các phần tiếp theo.</p>
</div>
<div class="paragraph">
<p><strong>Cảm biến DHT 11 và chuẩn dữ liệu OneWire</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>DHT11 là cảm biến có chức năng đo nhiệt độ, độ ẩm của môi trường, được dùng khá phổ biến vì giá thành thấp và độ ổn định cao. Cảm biến sử dụng chuẩn truyền dữ liệu OneWire. Thông tin chi tiết về DHT11 có thể xem tại <a href="http://www.micropik.com/PDF/dht11.pdf"><strong>Datasheet</strong></a></p>
</li>
<li>
<p>OneWire là chuẩn giao tiếp nối tiếp được thiết kế bởi hãng Dallas. Đó là hệ thống bus nhằm kết nối các thiết bị với nhau để truyền hoặc nhận dữ liệu.Trong chuẩn giao tiếp này thường chỉ sử dụng 1 chân đồng thời là vừa là nguồn cung cấp vừa là chân truyền nhận dữ liệu. Cũng giống như các chuẩn giao tiếp khác, OneWire cũng gồm 3 giai đoạn reqquest (hỏi) &#8594; respond (đáp) &#8594; data reading (truyền nhận dữ liệu).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hình ảnh mô tả quá trình truyền,nhận dữ liệu của DHT11 như hình bên dưới</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/DHT11TimingDialog.png" alt="DHT11TimingDialog" width="981">
</div>
<div class="title">Hình 38. Quá trình truyền nhận dữ liệu trong chuẩn OneWire</div>
</div>
<div class="paragraph">
<p>Tóm tắt</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Master (ESP8266) gửi tín hiệu <code>START</code>, DHT11 sẽ chuyển từ chế độ tiết kiệm năng lượng (low-power mode) sang chế độ làm việc bình thường (high-speed mode)</p>
</li>
<li>
<p>DHT11 nhận được tín hiệu và phản hồi đến master, master nhận tín hiệu và bắt đầu quá trình truyền dữ liệu.</p>
</li>
<li>
<p>DHT11 sẽ gửi dữ liệu lên bus, mỗi lần gửi là 1 gói 40 bits data.</p>
</li>
<li>
<p>Khi muốn kết thúc, Master sẽ gửi tín hiệu <code>STOP</code>, kết thúc quá trình truyền nhận dữ liệu</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Chi tiết về chuẩn OneWire xem tại <a href="https://www.maximintegrated.com/en/app-notes/index.mvp/id/1796"><strong>maximintegrated.com</strong></a></p>
</div>
<div class="paragraph">
<p><strong>Ngôn ngữ HTML</strong></p>
</div>
<div class="paragraph">
<p>Một trong những địa chỉ web để học HTML cho người mới bắt đầu là <a href="https://www.w3schools.com/html/default.asp"><strong>w3school.com/HTML</strong></a>, lưu ý rằng chúng ta sẽ không đi quá sâu vào việc học HTML, bởi việc này có thể ảnh hướng đến tiến độ thực hiện của project, tại thời điểm này chúng ta chỉ cần học đủ để xây dựng project hoàn chỉnh.</p>
</div>
<div class="paragraph">
<p><strong>Node.js và Javascript</strong></p>
</div>
<div class="paragraph">
<p>Để tạo server dùng Node.js cần trang bị một số kiến thức cơ bản về  Javascript và Node.js, để học Javascript chúng ta có thể truy cập địa chỉ URL <a href="https://www.w3schools.com/js/default.asp"><strong>w3school.com/Javascrpit</strong></a>, với Node.js thì <a href="https://www.codeschool.com/courses/real-time-web-with-node-js"><strong>codeschool.com</strong></a> thật sự hữu ích với người mới bắt đầu.</p>
</div>
</div>
<div class="sect2">
<h3 id="_thực_hiện">Thực hiện</h3>
<div class="paragraph">
<p><strong>Linh kiện cần có</strong></p>
</div>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p><i class="fa fa-check-square-o"></i> Cảm biến DHT11</p>
</li>
<li>
<p><i class="fa fa-check-square-o"></i> Board ESP8266 WiFi Uno</p>
</li>
<li>
<p><i class="fa fa-check-square-o"></i> Dây nối male-female header</p>
</li>
<li>
<p><i class="fa fa-check-square-o"></i> Điện trở 5K Ohm</p>
</li>
<li>
<p><i class="fa fa-check-square-o"></i> Cable kết nối giữa board ESP8266 và máy tính</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Đấu nối</strong></p>
</div>
<div class="paragraph">
<p>Kết nối sơ đồ mạch điện như hình bên dưới</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/DHT11Connect.png" alt="DHT11Connect" height="511">
</div>
<div class="title">Hình 39. Kết nối DHT11 và ESP8266 WiFi Uno</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server-nodejs">Server Nodejs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Về phía Web Server, chúng ta cần đảm bảo nó có thể phục vụ cho nhiều Client, với <code>path</code> là:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/update</code> thì sẽ thêm mới dữ liệu để lưu trữ, và in ra màn hình</p>
</li>
<li>
<p><code>/get</code> trả về dữ liệu đã lưu trữ định dạng JSON</p>
</li>
<li>
<p><code>/</code> và còn lại thì trả về file <code>index.html</code></p>
</li>
<li>
<p>Mảng dữ liệu lưu trữ có định dạng: <code>[{"temp": 25, "humd":80, time: "time"}, ...]</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Mã nguồn file <code>server.js</code></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">//---------------------------------------------------------------------------------------------
var fs = require('fs');
var url = require('url');
var http = require('http');<i class="conum" data-value="1"></i><b>(1)</b>
var querystring = require('querystring');
var db = []; //database
//---------------------------------------------------------------------------------------------
// function gửi yêu cầu(response) từ phía server hoặc nhận yêu cầu (request) của client gửi lên
function requestHandler(request, response) {

    // Giả sử địa chỉ nhận được http://192.168.1.7:8000/update?temp=30&amp;humd=40
    var uriData = url.parse(request.url);
    var pathname = uriData.pathname;          // /update?
    var query = uriData.query;                // temp=30.5&amp;hum=80
    var queryData = querystring.parse(query); // queryData.temp = 30.5, queryData.humd = 40
    //-----------------------------------------------------------------------------------------
    if (pathname == '/update') {
        var newData = {
            temp: queryData.temp,
            humd: queryData.humd,
            time: new Date()<i class="conum" data-value="2"></i><b>(2)</b>
        };
        db.push(newData);
        console.log(newData);
        response.end();
    //-----------------------------------------------------------------------------------------
    } else if (pathname == '/get') {<i class="conum" data-value="3"></i><b>(3)</b>
        response.writeHead(200, {
            'Content-Type': 'application/json'
        });
        response.end(JSON.stringify(db));
        db = [];
    //-----------------------------------------------------------------------------------------
    } else { <i class="conum" data-value="4"></i><b>(4)</b>
        fs.readFile('./index.html', function(error, content) {
            response.writeHead(200, {
                'Content-Type': 'text/html'
            });
            response.end(content);
        });
    }
    //-----------------------------------------------------------------------------------------
}
var server = http.createServer(requestHandler);
server.listen(8000); <i class="conum" data-value="5"></i><b>(5)</b>
console.log('Server listening on port 8000');</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Giải thích mã nguồn</strong></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>require dùng để load các thư viện hoặc module cần thiết cho dự án
<div class="ulist">
<ul>
<li>
<p><code>fs</code>: Module giúp đọc file từ server hoặc upload file lên server</p>
</li>
<li>
<p><code>url</code>: Chia nhỏ URL thành những thành phần để dễ dàng truy xuất</p>
</li>
<li>
<p><code>http</code>: Phương thức truyền nhận dữ liệu dùng http</p>
</li>
<li>
<p><code>querystring</code>: Module giúp chuyển string sang object</p>
</li>
<li>
<p><code>db = []</code>: Biến kiểu mảng nhằm chứa dữ liệu nhiệt độ, độ ẩm</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>So sánh giá trị pathname để xử lí dữ liệu. Nếu <code>pathname =/update</code> thì sẽ tạo biến newData nhằm lấy dữ liệu client gửi lên thông qua URL, sau đó đẩy dữ liệu vào mảng db thông qua lệnh <code>db.push(newData)</code> , giá trị được hiển thị qua Log khi dùng lệnh <code>console.log(newData)</code>. Hàm <code>Date()</code> giúp lấy thời gian hiện tại.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Trả về định dạng JSON <code>('Content-Type': 'application/json')</code> của mảng db nếu pathname = /get, sau đó xóa giá trị của mảng. Hàm <code>response.end()</code> sẽ trả về HTTP code (mã 200 là kết quả OK)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Trả về nội dung của file index.html khi không xảy ra 2 trường hợp &lt;2&gt; và &lt;3&gt;. Dùng <code>fs</code> để đọc file index.html và gán nội dung vào content thông qua lệnh <code>fs.readFile('./index.html', function(error, content)</code>. Hàm <code>response.writeHead(200, {'Content-Type': 'text/html' })</code> nhằm khai báo mã HTTP code, định dạng trả về là HTML để đọc file</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Khởi tạo một server HTTP và mở port 8000 để các client truy cập</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bạn có thể truy cập đến đường dẫn của file server.js và thực thi đoạn code trên với dòng lệnh <code>node server.js</code>, sau đó thử truy vập vào <a href="http://localhost:8000" class="bare">localhost:8000</a> để xem trang <code>index.html</code>. Hoặc truy cập vào <a href="http://localhost:8000/update?temp=20&amp;humd=60" class="bare">localhost:8000/update?temp=20&amp;humd=60</a> để xem màn hình Log in ra kết quả nhiệt độ và độ ẩm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{ temp: '20', humd: '60', time: 2017-08-21T16:56:23.358Z }
{ temp: '20', humd: '60', time: 2017-08-21T16:57:06.277Z }
{ temp: '20', humd: '60', time: 2017-08-21T16:57:17.708Z }</pre>
</div>
</div>
<div class="paragraph">
<p>Ở phần cơ bản chúng ta chưa cần phải quan tâm đến file <code>index.html</code> và đoạn code Javascript trong đó. Cũng nhưng chưa quan tâm tới việc xử lý khi đường dẫn là <code>/get</code> hoặc <code>/\*</code>, mà chỉ quan tâm duy nhất khi nhận được với đường dẫn <code>/update</code>.</p>
</div>
<div class="paragraph">
<p>Khi đã hoàn thành phần cơ bản chúng ta sẽ đi đến một ứng dụng khá phổ biến, người dùng cần hiển thị các dữ liệu thu thập một cách trực quan thông qua trình duyệt Web. Vì vậy chúng ta sẽ làm 1 file <code>index.html</code> chứa mã nguồn Javascript có thể yêu cầu Server trả về dữ liệu mỗi giây để hiển thị lên 1 biểu đồ canvas.</p>
</div>
<div class="paragraph">
<p><strong>Mã nguồn file <code>index.html</code></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;<i class="conum" data-value="1"></i><b>(1)</b>
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;DHT11&lt;/title&gt;
    &lt;!-- Nhúng file Javasript tại đường dẫn src để có thể xây dựng 1 graph --&gt;
    &lt;script type="text/javascript" src="https://canvasjs.com/assets/script/canvasjs.min.js"&gt;&lt;/script&gt;<i class="conum" data-value="2"></i><b>(2)</b>
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt; 1. THONG SO NHIET DO, DO AM&lt;/h&gt;&lt;br&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        &lt;h2&gt; Temprature&lt;/h2&gt; &lt;input type="text" size="6" id="temp"&gt;&amp;#176;C&lt;br&gt;
        &lt;h2&gt; Humidity&lt;/h2&gt; &lt;input type="text" size="6" id="humd"&gt;%&lt;br&gt;
        &lt;h1&gt; 2. DO THI&lt;/h1&gt;&lt;br&gt;
        &lt;!-- thiết lập kích thước cho graph thông qua id ChartContainer đã thiết lập ở trên  --&gt;
        &lt;div id="ChartContainer" style="height: 300px; width:80%;"&gt;&lt;/div&gt;
        &lt;script type="text/javascript"&gt;
            function httpGetAsync(theUrl, callback) { <i class="conum" data-value="4"></i><b>(4)</b>
                        var xmlHttp = new XMLHttpRequest();
                        xmlHttp.onreadystatechange = function() {
                    if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)
                        callback(JSON.parse(xmlHttp.responseText));
                }
                xmlHttp.open("GET", theUrl, true); // true for asynchronous
                xmlHttp.send(null);
            }

            window.onload = function() {
                var dataTemp = [];
                var dataHumd = [];

                var Chart = new CanvasJS.Chart("ChartContainer", {
                    zoomEnabled: true, // Dùng thuộc tính có thể zoom vào graph
                    title: {
                        text: "Temprature &amp; Humidity" // Viết tiêu đề cho graph
                    },
                    toolTip: { // Hiển thị cùng lúc 2 trường giá trị nhiệt độ, độ ẩm trên graph
                        shared: true
                    },
                    axisX: {
                        title: "chart updates every 2 secs" // Chú thích cho trục X
                    },
                    data: [{
                            // Khai báo các thuộc tính của dataTemp và dataHumd
                            type: "line", // Chọn kiểu dữ liệu đường
                            xValueType: "dateTime", // Cài đặt kiểu giá trị tại trục X là thuộc tính thời gian
                            showInLegend: true, // Hiển thị "temp" ở mục chú thích (legend items)
                            name: "temp",
                            dataPoints: dataTemp // Dữ liệu hiển thị sẽ lấy từ dataTemp
                        },
                        {
                            type: "line",
                            xValueType: "dateTime",
                            showInLegend: true,
                            name: "humd",
                            dataPoints: dataHumd
                        }
                        ],
                    });
                var yHumdVal = 0; // Biến lưu giá trị độ ẩm (theo trục Y)
                var yTempVal = 0; // Biến lưu giá trị nhiệt độ (theo trục Y)
                var updateInterval = 2000; // Thời gian cập nhật dữ liệu 2000ms = 2s
                var time = new Date(); // Lấy thời gian hiện tại

                var updateChart = function() {
                    httpGetAsync('/get', function(data) {

                        // Gán giá trị từ localhost:8000/get vào textbox để hiển thị
                        document.getElementById("temp").value = data[0].temp;
                        document.getElementById("humd").value = data[0].humd;

                        // Xuất ra màn hình console trên browser giá trị nhận được từ localhost:8000/get
                        console.log(data);
                        // Cập nhật thời gian và lấy giá trị nhiệt độ, độ ẩm từ server
                        time.setTime(time.getTime() + updateInterval);
                        yTempVal = parseInt(data[0].temp);
                        yHumdVal = parseInt(data[0].humd);
                        dataTemp.push({ // cập nhât dữ liệu mới từ server
                            x: time.getTime(),
                            y: yTempVal
                        });
                        dataHumd.push({
                            x: time.getTime(),
                            y: yHumdVal
                        });
                        Chart.render(); // chuyển đổi dữ liệu của của graph thành mô hình đồ họa
                    });
                };
                updateChart(); // Chạy lần đầu tiên
                setInterval(function() { // Cập nhật lại giá trị graph sau thời gian updateInterval
                    updateChart()
                }, updateInterval);
            }
        &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Giải thích mã nguồn</strong></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Những tag cơ bản khi khởi tạo 1 trang HTML
<div class="ulist">
<ul>
<li>
<p><code>&lt;!DOCTYPE html&gt;</code>          cho trình duyệt biết phiên bản HTML được sử dụng</p>
</li>
<li>
<p><code>&lt;html&gt;</code>                   cho trình duyệt biết đây là văn bản HTML</p>
</li>
<li>
<p><code>&lt;head&gt;</code>                   khai báo thông tin cho trang HTML</p>
</li>
<li>
<p><code>&lt;meta charset="UTF-8"&gt;</code>   cung cấp dữ liệu về văn bản HTML, dạng mã hóa charset="UTF-8"</p>
</li>
<li>
<p><code>&lt;title&gt;DHT11&lt;/title&gt;</code>     tiêu đề của trang</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sử dụng CanvasJS Chart để vẽ biểu đồ nhiệt độ, độ ẩm.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Tạo 2 textbox tại tag tiêu đề phụ &lt;h1&gt; để hiển thị nhiệt độ, độ ẩm. Mỗi textbox sẽ có 1 <code>id</code> để cập nhật giá nhiệt độ, độ ẩm từ server. Mã định dạng <code>&amp;#176;C</code> là của kí tự độ C</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Hàm giúp lấy dữ liệu từ server</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Phân tích phần vẽ biểu đồ</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Chúng ta sẽ lấy dữ liệu từ server gửi xuống và vẽ biểu đồ dùng mã Javascrpit, sử dụng tag
<code>&lt;scrpit&gt;code JS &lt;/scrpit&gt;</code> để chèn nội dung code Javascrpit vào file HTML.</p>
</li>
<li>
<p>Việc lấy dữ liệu được thực thi bằng hàm <code>httpGetAsync()</code>. Hàm này sử dụng đối tượng <code>XMLHttpRequest</code> để lấy dữ liệu từ server mà không cần phải load lại trang, dữ liệu <code>xmlHttp.responseText</code> lấy từ server tại địa chỉ <code>localhost:8000/get</code> ở định dạng JSON nên cần phải chuyển sang dạng Object bằng hàm JSON.parse().</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Cần phải có dữ liệu từ ESP8266 gửi lên server thì tại địa chỉ localhost:8000/get mới có dữ liệu.
</td>
</tr>
</table>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/imageJSON.png" alt="imageJSON" width="487">
</div>
<div class="title">Hình 40. Hình ảnh dữ liệu tại địa chỉ <code>localhost:8000/get</code></div>
</div>
<div class="ulist">
<ul>
<li>
<p>Sử dụng <code>window.onload = function()</code> để load lại nội dung của graph, các lệnh trong hàm đã được giải thích trong code.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Truy cập vào trang <a href="https://canvasjs.com/javascript-charts/" class="bare">canvasjs.com/javascript-charts/</a> để lựa chọn và xây dựng những đồ thị phù hợp với mục đích của bạn.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Hình ảnh trang HTML sau khi xây dựng</strong></p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/graphHtml.png" alt="graphHtml" width="437">
</div>
<div class="title">Hình 41. Hình ảnh giao diện HTML</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_esp8266">Code ESP8266</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ESP8266 sử dụng thư viện HTTPClient để kết nối tới Web Server và lấy dữ liệu nhiệt độ, đổ ẩm thông qua phương thức GET với query là <code>temp</code> và <code>humd</code>.</p>
</div>
<div class="sect2">
<h3 id="_chuẩn_bị_2">Chuẩn bị</h3>
<div class="ulist">
<ul>
<li>
<p>Cung cấp SSID và PASSWORD WiFi cho board mạch ESP8266 để kết nối vào mạng nội bộ với Web Server.</p>
</li>
<li>
<p>Cung cấp địa chỉ IP, port của Web Server.</p>
</li>
<li>
<p>Thư viện hỗ trợ lấy dữ liệu của DHT11. Dựa theo chuẩn truyền nhận 1 wire và sự phổ biến của dòng sensor DHTXX (DHT11, DHT22,&#8230;&#8203;), có rất nhiều thư viện được xây dựng lên để việc lập trình với DHT11 trở nên dễ dàng hơn. Trong bài này chúng ta sẽ cài đặt và sử dụng thư viện <code>DHT sensor library</code> của Adafruit.</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/install-lib.png" alt="install lib" height="900">
</div>
<div class="title">Hình 42. Hình ảnh thư viện DHT sensor library</div>
</div>
<div class="paragraph">
<p><strong>Mã nguồn ESP8266</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;DHT.h&gt;            // Khai báo sử dụng thư viện DHT
#include &lt;ESP8266WiFi.h&gt;    // Khai báo sử dụng thư viện ESP8266WiFi.h để thiết lập chế độ HTTP client cho ESP8266
#define DHTPIN 4            // Chân dữ liệu của DHT11 kết nối với GPIO4 của ESP8266
#define DHTTYPE DHT11       // Loại DHT được sử dụng

DHT dht(DHTPIN, DHTTYPE);
WiFiClient client;          // Tạo 1 biến client thuộc kiểu WiFiClient
const char* ssid = "YOUR-WIFI-SSID";      // Tên mạng Wifi được chỉ định sẽ kết nối (SSID)
const char* password = "YOUR-WIFI-PASS";  // Password của mạng Wifi được chỉ định sẽ kết nối
const char* server = "Your-local-IP";     // Địa chỉ IP của máy khi truy cập cùng mạng WiFi
const int port = 8000;                    // Port của server đã mở
const int sendingInternval = 2 * 1000;    // Biến cập nhật dữ liệu sau mỗi 2s

void setup() {
  Serial.begin(115200);
  dht.begin();                            // Khởi tạo DHT1 11 để truyền nhận dữ liệu
  Serial.println("Connecting");

  // Thiết lập ESP8266 là Station và kết nối đến Wifi. in ra dấu `.` trên terminal nếu chưa được kết nối
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(100);
  }
  Serial.println("\r\nWiFi connected");
}

void loop() {

// Đọc gía trị nhiệt độ (độ C), độ ẩm. Xuất ra thông báo lỗi và thoát ra nếu dữ liệu không phải là số
  float temp = dht.readTemperature();
  float humi = dht.readHumidity();
  if (isnan(temp) || isnan(humi)) {
    Serial.println("Failed to read from DHT sensor!");
    return;
  }

  if (client.connect(server, port)) {       // Khởi tạo kết nối đến server thông qua IP và PORT đã mở
  //---------------------------------------------------------------------------------------
    String req_uri = "/update?temp=" + String(temp, 1) + "&amp;humd=" + String(humi, 1);
    client.print("GET " + req_uri + " HTTP/1.1\n" + "Host: "+ server +"\n" + "Connection: close\n" + "Content-Length: 0\n" +"\n\n");   <i class="conum" data-value="1"></i><b>(1)</b>
  //---------------------------------------------------------------------------------------

  // temp, humi chuyển từ định dạng float sang định dạng string và in ra màn hình serial      // terminal trên Arduino.
    Serial.printf("Nhiet do %s - Do am %s\r\n", String(temp, 1).c_str(), String(humi, 1).c_str());
  }
  client.stop();                          // Ngắt kết nối đến server

  delay(sendingInternval);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ESP8266 sẽ gửi dữ liệu lên server sau khi kết nối thành công đến server thông qua lệnh <code>client.print()</code>. Nội dung gửi :
<div class="ulist">
<ul>
<li>
<p>GET /update?temp=30.6&amp;humd=60 HTTP/1.1 với :</p>
<div class="ulist">
<ul>
<li>
<p><code>GET</code> là phương thức gửi dữ liệu.</p>
</li>
<li>
<p><code>/update?temp=30.6&amp;humd=60</code> là nội dung cần gửi bao gồm cả pathname và dữ liệu.</p>
</li>
<li>
<p><code>HTTP/1.1</code> khai báo sử dụng giao thức HTTP version 1.1 để có thể tạo 1 HTTP request</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Host: 192.168.1.7:8000</code> thông tin về địa chỉ IP và port của server.</p>
</li>
<li>
<p><code>Connection, Content-Length</code></p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Có thể xem thông các thông tin của quá trình truyền nhận dữ liệu với lệnh:
<code>curl -v http://192.168.1.7:8000/update?temp=28.0&amp;humd=45.0</code>. Thông tin hiển thị như bên dưới:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">name@yourname:~$ curl -v http://192.168.1.7:8000/update?temp=28.0&amp;humd=45.0
[1] 9277
name@yourname:~$ *   Trying 192.168.1.7...
* Connected to 192.168.1.7 (192.168.1.7) port 8000 (#0)
&gt; GET /update?temp=28.0 HTTP/1.1    // &gt; Thông tin gửi từ ESP8266
&gt; Host: 192.168.1.7:8000
&gt; User-Agent: curl/7.47.0
&gt; Accept: */*
&gt;                                  // &lt; Thông tin gửi từ server
&lt; HTTP/1.1 200 OK
&lt; Date: Wed, 23 Aug 2017 17:22:49 GMT
&lt; Connection: keep-alive
&lt; Content-Length: 0
&lt;
* Connection #0 to host 192.168.1.7 left intact</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kết quả hiển thị trên Arduino IDE và màn hình Log của máy tính:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/esp8266-server.png" alt="esp8266 server" height="366">
</div>
<div class="title">Hình 43. Hình ảnh trên Arduino và terminal sau khi kết nối</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Ứng_dụng_mở_rộng">Ứng dụng mở rộng</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dùng_esp8266_như_1_web_server">Dùng ESP8266 như 1 Web Server</h3>
<div class="paragraph">
<p>Xây dựng 1 dự án giám sát và điều khiển nhiệt độ, độ ẩm hiển thị trên web với giao diện điều khiển :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hiển thị giá trị nhiệt độ, độ ẩm.</p>
</li>
<li>
<p>Hiển thị chart nhiệt độ, độ ẩm theo thời gian.</p>
</li>
<li>
<p>Có 2 chế độ Auto và Manual.</p>
<div class="ulist">
<ul>
<li>
<p>Với chế độ Auto, nhiệt độ &gt; 35ºC sẽ tự động bật quạt, độ ẩm &gt; 50% sẽ bật máy phun sương.</p>
</li>
<li>
<p>Với chế độ manual có thể điều khiển quạt và máy phun sương bằng các nút nhấn ở ON/OFF</p>
</li>
</ul>
</div>
</li>
<li>
<p>Có tùy chọn hiển thị lịch sử nhiệt độ, độ ẩm theo thời gian từ ngày aa/bb/cccc đến ngày xx/yy/zzzz</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hình ảnh thiết kế giao diện như bên dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/04-dht11/control%20interface.png" alt="control interface" width="500">
</div>
<div class="title">Hình 44. Giao diện điều khiển trên trang HTML</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tổng_kết_5">Tổng kết</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sau khi hoàn thành dự án, chúng ta đã có cái nhìn tổng quan về trình tự các bước để xây dựng một dự án hoàn chỉnh trong việc thu thập dữ liệu của cảm biến cũng như xây dựng server để quản lí các máy khách. Từ đó là bước đệm để giúp bạn phát triển thêm nhiều các dự án thu thập và xử lí dữ liệu trong tương lai.</p>
</div>
</div>
</div>
<h1 id="_wifi_config" class="sect0">Các chế độ cấu hình WiFi</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Thông thường, khi bắt đầu kết nối wifi cho ESP8266, ta phải cấu hình cho thiết bị các thông số của Access Point cũng như SSID và password nếu mạng wifi được thiết lập các bảo mật như WEP/WPA/WPA2. Tuy nhiên, các ứng dụng nhúng sử dụng Wi-fi thường ít chú trọng đến giao diện người dùng (user interface), không có bàn phím hay touchscreen,.. để giao tiếp. Vì thế, mỗi khi muốn kết nối thiết bị ESP với một Access Point nào đó, bạn cần phải có một máy tính đã cài đặt sẵn phần mềm biên dịch, tiếp theo là viết code cấu hình lại thông số wifi cho thiết bị, sau đó nạp code cho thiết bị thông qua một cable USB.</p>
</div>
<div class="paragraph">
<p>Điều này làm cho việc kết nối wifi trở nên khá bất tiện và phức tạp. Do vậy ESP8266 cung cấp các phương pháp thay thế khác giúp đơn giản hóa việc kết nối trạm ESP (chế độ Station) với một điểm truy cập. Đó là kết nối bằng <code>SmartConfig</code>, <code>WPS</code> hay <code>Wifi Manager</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_smartconfig">Smartconfig</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_kiến_thức_5">Kiến thức</h3>
<div class="paragraph">
<p>SmartConfig là một giao thức được tạo ra nhằm cấu hình cho các thiết bị kết nối với mạng WiFi một cách dễ dàng nhất bằng smart phone. Nói một cách đơn giản, để kết nối WiFi cho thiết bị ESP8266, ta chỉ cần cung cấp thông tin mạng wifi (bao gồm SSID và password) cho ESP thông qua 1 ứng dụng trên smart phone.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/05-wificonfig/smart-config.png" alt="SmartConfig" width="400">
</div>
<div class="title">Hình 45. SmartConfig với ESP8266</div>
</div>
<div class="paragraph">
<p>Chúng ta nên biết rằng, khi 1 điện thoại thông minh đã kết nối vào mạng WiFi có mật khẩu, thì toàn bộ dữ liệu trao đổi giữa Điện thoại và đầu mối khác trong mạng sẽ được mã hóa. Nghĩa là các thiết bị chưa được kết nối mạng và không có mật khẩu thì không thể giải mã được dữ liệu. Vậy làm thế nào để Ứng dụng trên điện thoại gởi thông tin kết nối này đến 1 thiết bị khác chưa hề kết nối mạng. Để làm được điều này, thì nhờ vào 2 đặc điểm sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ESP8266 có khả năng <code>lắng nghe</code> tất cả các gói tin không dây WiFi xung quanh nó, bao gồm cả các gói tin đã được mã hóa.</p>
</li>
<li>
<p>Các gói tin gởi trong mạng WiFi được mã hóa và không thể đọc được nội dung, tuy nhiên độ dài gói tin là một hằng số. Ví dụ, gói tin A chưa mã hóa có chiều dài là <code>x</code>, khi mã hóa gói tin A thành gói tin B, thì gói tin B sẽ có chiều dài là <code>x + n</code>, thì n là hằng số.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cách thức để giao thức ESPTOUCH thực hiện việc gởi thông tin SSID và mật khầu cho thiết bị như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ESP8266 sẽ vào chế độ lắng nghe, lần lượt từng kênh.</p>
</li>
<li>
<p>Điện thoại phải kết nối vào mạng WiFi được mã hóa.</p>
</li>
<li>
<p>Ứng dụng trên điện thoại sẽ tiến hành gởi các gói tin với nội dung bất kỳ, nhưng có độ dài <code>n</code> theo từng ký tự của <code>SSID</code> và mật khẩu. Ví dụ, ssid của mạng là <code>mynetwork</code> thì sẽ có ký tự <code>m</code>, với ký tự ascii = 109, Ứng dụng sẽ gởi gói tin có độ dài 109 với nội dung bất kỳ, và lặp lại cho đến hết ký tự <code>k</code>, cũng như mật khẩu, và các ký tự khác như CRC.</p>
</li>
<li>
<p>Có thể giao thức ESPTOUCH sẽ mã hóa cả các thông số gởi đi, nhưng vẫn giữ nguyên tắc như trên.</p>
</li>
<li>
<p>ESP8266 sẽ phát hiện ra các gói tin với độ dài thay đổi này và ghép nối lại thành <code>SSID</code> và <code>password</code> để kêt nối vào mạng.</p>
</li>
<li>
<p>Khi ESP8266 kết nối thành công đến mạng, ESP8266 sẽ kết nối đến IP của Điện thoại, được cung cấp thông qua ESPTOUCH, và gởi thông tin kết nối thành công đến ứng dụng trên điện thoại.</p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/05-wificonfig/data_packet.png" alt="Cấu trúc gói tin UDP" width="400">
</div>
<div class="title">Hình 46. Gói tin UDP</div>
</div>
<div class="paragraph">
<p>Lưu ý:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Khoảng cách giữa thiết bị và router càng xa thì thời gian kết nối sẽ càng lâu.</p>
</li>
<li>
<p>Nếu thiết bị không thể kết nối với router trong khoảng thời gian quy định thì ứng dụng sẽ trả về thông báo cấu hình thất bại. Người dùng có thể cài đặt thời gian timeout này thông qua lệnh esptouch_set_timeout(uint8 time_s)</p>
</li>
<li>
<p>Trong quá trình cấu hình kết nối thiết bị bằng SmartConfig, thiết bị phải được cài đặt ở chế độ Station.</p>
</li>
<li>
<p>Người dùng có thể cấu hình cho nhiều thiết bị kết nối chung vào một router cùng lúc.</p>
</li>
<li>
<p>ESP Touch hiện nay hỗ trợ đối với Access Point chuẩn 802.11n 2.4Ghz</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_thực_hiện_smartconfig_với_esp8266">Thực hiện SmartConfig với ESP8266</h3>
<div class="paragraph">
<p>Trong ví dụ dưới đây, chúng ta sẽ tiến hành kết nối wifi cho board ESP8266 bằng SmartConfig. Sử dụng ứng dụng ESP8266 SmartConfig (Android). Bạn có thể dễ dàng tìm thấy ứng dụng này cũng như các ứng dụng tương tự trên Play Store (Android) hay iTunes (iOS) để thực hiện việc kết nối bằng SmartConfig này.</p>
</div>
<div class="paragraph">
<p>Trước tiên, ta sẽ nạp chương trình cho ESP8266. Điểm mấu chốt trong chương trình này chính là hàm <code>WiFi.beginSmartConfig()</code> được cung cấp trong thư viện ESP8266WiFi. Hàm này cho phép thiết bị khởi động chế độ SmartConfig, thu thập các thông tin từ các gói tin và giải mã chúng để có thể kết nối vào mạng Wifi.</p>
</div>
<div class="paragraph">
<p>Sau khi nạp xong chương trình, ta nhấn giữ button (GPIO0) trong 3s để thiết bị đi vào chế độ smartconfig. (Lúc này bạn sẽ thấy led trên board nhấp nháy nhanh hơn). Dùng smart phone của bạn truy cập vào wifi muốn kết nối, sau đó mở ứng dụng smartconfig và nhập các thông tin SSID và PASSWORD (nếu có) của wifi. Nhấn <strong>CONFIRM</strong> để xác nhận.</p>
</div>
<div class="videoblock">
<div class="title">Video Demo</div>
<div class="content">
<iframe src="https://www.youtube.com/embed/-RqMKvMLPi0?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_code_2">Code</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;Arduino.h&gt;
#include &lt;ESP8266WiFi.h&gt;
#include &lt;Ticker.h&gt;
#include &lt;time.h&gt;

#define PIN_LED 16
#define PIN_BUTTON 0

#define LED_ON() digitalWrite(PIN_LED, HIGH)
#define LED_OFF() digitalWrite(PIN_LED, LOW)
#define LED_TOGGLE() digitalWrite(PIN_LED, digitalRead(PIN_LED) ^ 0x01)

Ticker ticker;

/* Hàm kiểm tra trạng thái của button*/
bool longPress()
{
  static int lastPress = 0;
  if (millis() - lastPress &gt; 3000 &amp;&amp; digitalRead(PIN_BUTTON) == 0) { // Nếu button được nhấn và giữ trong 3s thì
    return true;                  // trả về "true".
  } else if (digitalRead(PIN_BUTTON) == 1) { // Nếu button không được nhấn và giữ đủ 3s thì
    lastPress = millis();         // gán biến lastPress bằng thời điểm khi gọi hàm, và trả về "false".
  }                               //
  return false;                   //
}

void tick()
{
  int state = digitalRead(PIN_LED); // Lấy trạng thái hiện tại của LED (GPIO16)
  digitalWrite(PIN_LED, !state);  // Đảo trạng thái LED.
}

bool in_smartconfig = false;      // Biến trạng thái kiểm tra thiết bị có đang trong chế độ smartconfig hay không.

/* Vào chế độ Smartconfig*/
void enter_smartconfig()
{
  if (in_smartconfig == false) {  // Kiểm tra tra biến trạng thái, nếu không ở chế độ smartconfig thì
    in_smartconfig = true;        // Gán biến trạng thái bằng "true", nghĩa là đang trong smartconfig
    ticker.attach(0.1, tick);     // Nhấp nháy led chu kì 0.1s.
    WiFi.mode(WIFI_STA);          // Thiết lập kết nối cho thiết bị ở chế độ Station mode
    WiFi.beginSmartConfig();      // Bắt đầu chế độ smartconfig
    Serial.println("Enter smartconfig");  // In thông báo "Enter smartconfig" ra màn hình
  }
}

/* Thoát chế độ smartconfig*/
void exit_smart()
{
  ticker.detach();              // Ngừng nháy led
  LED_ON();                     // Bật LED
  in_smartconfig = false;       // Gán biến trạng thái trở về ban đầu.
  Serial.println("Connected, Exit smartconfig");  // In thông báo ra màn hình.
}

/* Cài đặt các thông số ban đầu*/
void setup() {
  Serial.begin(115200);         // Tốc độ baud = 115200
  Serial.setDebugOutput(true);  // hiển thị các thông tin debug hệ thống lên màn hình qua serial

  pinMode(PIN_LED, OUTPUT);     // Cấu hình GPIO cho các chân LED và button
  pinMode(PIN_BUTTON, INPUT);   // Chớp tắt led chu kì 1s
  Serial.println("Setup done"); // In thông báo đã cài đặt xong
}

/* Chương trình chính*/
void loop() {
  if (longPress()) {            // Gọi hàm longPress kiểm tra trạng thái button
    enter_smartconfig();        // Nếu button được nhấn giữ trong 3s thì vào trạng thái smartconfig
  }
  if (WiFi.status() == WL_CONNECTED &amp;&amp; in_smartconfig &amp;&amp; WiFi.smartConfigDone()) { //Kiểm tra trạng thái kết nối wifi,
                                // các thông số cấu hình cũng như trạng thái smartconfig
    exit_smart();               // khi thiết bị đã hết nối wifi thành công, thoát chế độ smartconfig
  }
  if (WiFi.status() == WL_CONNECTED) {
    //Chương trình của bạn khi thiết bị đã được kết nối wifi
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wps">WPS</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_wps_là_gì">WPS là gì?</h3>
<div class="paragraph">
<p>Nếu đã từng cấu hình cho một router wifi, sẽ gặp qua các thuật ngữ WPS trong các menu cấu hình của router. Hoặc từng nhìn thấy một nút nhấn trên các router với chữ viết bên cạnh WPS. Vậy WPS là gì ? Quá trình thực hiện kết nối như thế nào ? Cũng như thực hiện WPS với ESP8266, là những những nội dung sẽ được nói đến ở phần này.</p>
</div>
<div class="paragraph">
<p>WPS là từ viết tắc của Wifi Protected Setup, một phương thức giúp việc kết nối với mạng không dây giữa router và thiết bị kết nối không dây một cách nhanh chóng và dễ dàng, thay vì làm một cách thủ công: tìm mạng wifi cần kết nối và nhập mật khẩu để vào mạng wifi. WPS chỉ hoạt động khi cả hai thiết bị là router và thiết bị cần kết nối đến router có hổ trợ chuẩn bảo mật cá nhân WPA/WPA2.</p>
</div>
<div class="paragraph">
<p>WPS có ba chế độ hoạt động : chế độ kết nối với mã PIN, chế độ kết nối bằng nút nhấn, và chế độ kết nối NFC - Near Field Communication (chưa phổ biến). Một trong những chế độ phổ biến và sẽ thực hiện trong phần này là chế độ kết nối bằng nút nhấn.</p>
</div>
<div class="paragraph">
<p>Ở chế độ kết nối bằng nút nhấn, điều trước tiên cần thực hiện :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nhấn nút WPS trên router, để giúp router vào chế độ bảo mật đặc biệt, ở chế độ này router sẽ cho phép các yêu cầu kết nối đến router từ các thiết bị WPS (các thiết bị có hổ trợ WPS).</p>
</li>
<li>
<p>Tiếp theo là nhấn nút nhấn ở thiết bị WPS. Nút nhấn này giúp thiết bị WPS kết nối đến router, việc kết nối này có thể thất bại nếu quá thời gian. Thời gian này được nhà sản xuất các thiết bị hổ trợ chế độ này quy đinh, khoảng từ 1 phút đến 5 phút.</p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/05-wificonfig/wps_button.jpg" alt="WPS button" width="400">
</div>
<div class="title">Hình 47. Nút nhấn WPS trên router</div>
</div>
</div>
<div class="sect2">
<h3 id="_thực_hiện_wps_với_esp8266">Thực hiện WPS với ESP8266</h3>
<div class="paragraph">
<p>ESP8266 hổ trợ hàm <code>WiFi.beginWPSConfig()</code> trong thư viện ESP8266WiFi. Với hàm này giúp ESP8266 vào chế độ cấu hình với WPS và kết nối đến mạng wifi của router. Ví dụ này ESP8266 sẽ được đưa sẳn vào chế độ WPS, mà không cần thêm nút nhấn nào.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>- WPS chỉ có thể thực hiện khi ESP8266 ở chế độ STA (Station)
- Router phải ở trong chế độ WPS trước</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_code_3">Code</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;

void setup()
{
  // Cài đặt các thông số ban đầu
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  // Kết nối với AP cũ đã vào trước đó, SSID và password được lưu trong bộ nhớ flash của thiết bị
  WiFi.begin("", "");
  delay(4000);

  // Kiểm tra xem wifi đã được kết nối chưa, nếu chưa, bắt đầu kết nối bằng WPS
  // Lưu ý, cần phải đảm bảo rằng Router của bạn đang ở trong trạng thái WPS.
  while (WiFi.status() != WL_CONNECTED)
  {
    Serial.println("\nAttempting connection ...");
    WiFi.beginWPSConfig();
    delay(6000);
  }
  // Khi kết nối thành công, in thông báo ra màn hình cùng với các thông số của Wifi vừa kết nối.
  Serial.println("\nConnection already established.");
  Serial.println(WiFi.localIP());
  Serial.println(WiFi.SSID());
  Serial.println(WiFi.macAddress());
}

void loop()
{
  // chương trình chính
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wifi_manager">Wifi Manager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WifiManager là một thư viện cấu hình ESP8266 kết nối vào mạng WiFi cục bộ sử dụng giao diện Web. Bằng cách khởi động 1  mạng WiFi riêng với Captive Portal, ESP8266 sẽ cho phép các thiết bị khác như máy tính, điện thoại thông minh kết nối vào, đồng thời chuyển hướng mọi kết nối đến giao diện Web do ESP8266 tạo nên. Trên giao diện này, sẽ cung cấp các trường để người dùng có thể dễ dàng quét mạng xung quanh, chọn mạng WiFi, nhập mật khẩu, lưu cấu hình.</p>
</div>
<div class="sect2">
<h3 id="_hoạt_động_cơ_bản_wifimanager">Hoạt động cơ bản WifiManager</h3>
<div class="ulist">
<ul>
<li>
<p>Khi ESP8266 khởi động, ESP8266 sẽ vào chế độ STATION và sẽ tự động kết nối đến một Access Point với các thông tin kết nối đã được lưu vào ESP8266 ở lần kết nối thành công trước đó.</p>
</li>
<li>
<p>Nếu như kết nối không thành công (có thể là Access Point lần trước không còn nữa, hay sai mật khẩu, hoặc chưa có thông tin của bất cứ Access Point nào trong ESP8266 ), lúc này ESP8266 sẽ vào chế độ AP với một DNS trỏ về chính nó (có thể thiết lập DNS trỏ về địa chỉ khác) và khởi động Web Server (với địa chỉ mặc định là 192.168.4.1)</p>
</li>
<li>
<p>Sử dụng các thiết bị có hổ trợ wifi, và có trình duyệt web (điện thoại thông minh, laptop, máy tính bảng&#8230;&#8203;) để kết nối đến AP của ESP8266 vừa mới tạo ra. Có thể thấy một giao diện (với tên AP của ESP8266 là mặc định và không cài đặt mật khẩu cho ESP8266 AP) tương tự như sau :</p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/05-wificonfig/wifi_manager.png" alt="kết nối bằng wifi manager" width="400">
</div>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/05-wificonfig/wifi_manager1.png" alt="Giao diện wifi manager" width="400">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Sau khi vào được giao diện option của ESP8266 AP ở địa chỉ 192.168.4.1, chọn mục cấu hình cho wifi cho ESP8266 (như ví dụ trên là Configure WiFi hoặc Configure WiFi (No Scan)), có thể sẽ thấy giao diện tiếp theo tương tự như sau :</p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/05-wificonfig/wifi_manager2.png" alt="Kết nối bằng wifi manager" width="400">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Chọn mạng wifi cần kết nối và nhập mật khẩu để vào wifi.</p>
</li>
<li>
<p>Nếu ESP8266 kết nối thành công, ta sẽ không thấy tên của ESP8266 AP nữa. Nếu chưa thành công thì chỉ cần kết nối lại ESP8266 AP và cấu hình lại.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_chuẩn_bị_3">Chuẩn bị</h3>
<div class="ulist">
<ul>
<li>
<p>Cài đặt thư viện: <a href="https://github.com/tzapu/WiFiManager" class="bare">github.com/tzapu/WiFiManager</a>, xem thêm <a href="#install-library">Cài đặt thư viện Arduino</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_code_4">Code</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;          //https://github.com/esp8266/Arduino

//các thư viện cần thiết
#include &lt;DNSServer.h&gt;
#include &lt;ESP8266WebServer.h&gt;
#include "WiFiManager.h"          //https://github.com/tzapu/WiFiManager

void configModeCallback (WiFiManager *myWiFiManager)
{
  Serial.println("Entered config mode");
  Serial.println(WiFi.softAPIP());
  Serial.println(myWiFiManager-&gt;getConfigPortalSSID());
}

  // Cài đặt thông số ban đầu
void setup()
{
  Serial.begin(115200);

  //Khai báo wifiManager thuộc class WiFiManager, được quy định trong file WiFiManager.h
  WiFiManager wifiManager;
  //có thểreset các cài đặt cũ bằng cách gọi hàm:
  //wifiManager.resetSettings();

  //Cài đặt callback, khi kết nối với wifi cũ thất bại, thiết bị sẽ gọi hàm callback
  //và khởi động chế độ AP với SSID được cài tự động là "ESP+chipID"
  wifiManager.setAPCallback(configModeCallback);
  if (!wifiManager.autoConnect())
  {
    Serial.println("failed to connect and hit timeout");
  //Nếu kết nối thất bại, thử kết nối lại bằng cách reset thiết bị
    ESP.reset();
    delay(1000);
  }
  //Nếu kết nối wifi thành công, in thông báo ra màn hình
  Serial.println("connected...yeey :)");

}

void loop()
{
  // Chương trình chính
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_mở_rộng">Mở rộng</h3>
<div class="paragraph">
<p>Ngoài các chế độ cơ bản, thì thư viện WiFiManager còn nhiều tính năng hữu ích khác như <code>startConfigPortal</code> để khởi động cấu hình khi cần (ví dụ nhấn nút để cấu hình), bổ sung các trường tùy chọn trên giao diện Web, tùy chọn lại giao diện &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Các thông tin API và ví dụ bạn có thể dễ dàng tìm thấy tại <a href="https://github.com/tzapu/WiFiManager" class="bare">github.com/tzapu/WiFiManager</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tổng_kết_6">Tổng kết</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Để triển khai một ứng dụng IoT thực tế thì đòi hỏi rất nhiều vấn đề, một trong số những điều quan trọng là dễ dùng, dễ cấu hình cho người sử dụng và phải bảo mật trong quá trình cung cấp thông tin cho thiết bị. Tùy thuộc vào nhu cầu phát triển sản phẩm và tính năng của sản phẩm mà bạn có thể lựa chọn cho mình phương pháp cấu hình phù hợp. Ví dụ, nếu thiết bị có nút nhấn và có phần mềm trên điện thoại, thì SmartConfig và WPS là một sự lựa chọn. Nếu là 1 bóng đèn trống trơn không có gì cả, thì WiFiManager lại hữu hiệu.</p>
</div>
</div>
</div>
<h1 id="_mqtt" class="sect0">MQTT</h1>
<div class="openblock partintro">
<div class="content">
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/mqttorg-glow.png" alt="mqttorg glow" width="200">
</div>
</div>
<div class="paragraph">
<p>MQTT (Message Queuing Telemetry Transport) là một giao thức gởi dạng publish/subscribe sử dụng cho các thiết bị Internet of Things với băng thông thấp, độ tin cậy cao và khả năng được sử dụng trong mạng lưới không ổn định.</p>
</div>
<div class="paragraph">
<p>Bởi vì giao thức này sử dụng băng thông thấp trong môi trường có độ trễ cao nên nó là một giao thức lý tưởng cho các ứng dụng M2M.</p>
</div>
<div class="paragraph">
<p>MQTT cũng là giao thức sử dụng trong Facebook Messager.</p>
</div>
<div class="paragraph">
<p>Và MQTT là gì? Để có một cái nhìn toàn diện hoặc định nghĩa chi tiết, chỉ cần google "what is mqtt", "mqtt slides" &#8230;&#8203; Ở đây chúng ta chỉ nói ngắn gọn thôi, đủ để hiểu giao thức MQTT, bao gồm các định nghĩa <strong>"subscribe", "publish", "qos", "retain", "last will and testament (lwt)"</strong></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_publish_subscribe">Publish, subscribe</h3>
<div class="paragraph">
<p>Trong một hệ thống sử dụng giao thức MQTT, nhiều node trạm (gọi là mqtt client - gọi tắt là client) kết nối tới một MQTT Server (gọi là Broker). Mỗi client sẽ đăng ký một vài kênh (topic), ví dụ như "/client1/channel1", "/client1/channel2". Quá trình đăng ký này gọi là <strong>"subscribe"</strong>, giống như chúng ta đăng ký nhận tin trên một kênh Youtube vậy. Mỗi Client sẽ nhận được dữ liệu khi bất kỳ trạm nào khác gởi dữ liệu vào kênh đã đăng ký. Khi một Client gởi dữ liệu tới kênh đó, gọi là <strong>"publish"</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_qos">QoS</h3>
<div class="paragraph">
<p>Ở đây có 3 tuỳ chọn <strong>QoS (Qualities of service)</strong> khi "publish" và "subscribe":</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>QoS0</strong> Broker/Client sẽ gởi dữ liệu đúng 1 lần, quá trình gởi được xác nhận bởi chỉ giao thức TCP/IP, giống kiểu đem con bỏ chợ.</p>
</li>
<li>
<p><strong>QoS1</strong> Broker/Client sẽ gởi dữ liệu với ít nhất 1 lần xác nhận từ đầu kia, nghĩa là có thể có nhiều hơn 1 lần xác nhận đã nhận được dữ liệu.</p>
</li>
<li>
<p><strong>QoS2</strong> Broker/Client đảm bảm khi gởi dữ liệu thì phía nhận chỉ nhận được đúng 1 lần, quá trình này phải trải qua 4 bước bắt tay.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Xem thêm QoS</strong>: <a href="https://code.google.com/p/mqtt4erl/wiki/QualityOfServiceUseCases" class="bare">code.google.com/p/mqtt4erl/wiki/QualityOfServiceUseCases</a></p>
</div>
<div class="paragraph">
<p>Một gói tin có thể được gởi ở bất kỳ QoS nào, và các Client cũng có thể subscribe với bất kỳ yêu cầu QoS nào. Có nghĩa là Client sẽ lựa chọn QoS tối đa mà nó có để nhận tin. Ví dụ, nếu 1 gói dữ liệu được publish với QoS2, và Client subscribe với QoS0, thì gói dữ liệu được nhận về Client này sẽ được broker gởi với QoS0, và 1 Client khác đăng ký cùng kênh này với QoS 2, thì nó sẽ được Broker gởi dữ liệu với QoS2.</p>
</div>
<div class="paragraph">
<p>Một ví dụ khác, nếu 1 Client subscribe với QoS2 và gói dữ liệu gởi vào kênh đó publish với QoS0 thì Client đó sẽ được Broker gởi dữ liệu với QoS0. QoS càng cao thì càng đáng tin cậy, đồng thời độ trễ và băng thông đòi hỏi cũng cao hơn.</p>
</div>
</div>
<div class="sect2">
<h3 id="_retain">Retain</h3>
<div class="paragraph">
<p>Nếu RETAIN được set bằng 1, khi gói tin được publish từ Client, Broker <strong>PHẢI</strong> lưu trữ lại gói tin với QoS, và nó sẽ được gởi đến bất kỳ Client nào subscribe cùng kênh trong tương lai. Khi một Client kết nối tới Broker và subscribe, nó sẽ nhận được gói tin cuối cùng có RETAIN = 1 với bất kỳ topic nào mà nó đăng ký trùng. Tuy nhiên, nếu Broker nhận được gói tin mà có QoS = 0 và RETAIN = 1, nó sẽ huỷ tất cả các gói tin có RETAIN = 1 trước đó. Và phải lưu gói tin này lại, nhưng hoàn toàn có thể huỷ bất kỳ lúc nào.</p>
</div>
<div class="paragraph">
<p>Khi publish một gói dữ liệu đến Client, Broker phải set RETAIN = 1 nếu gói được gởi như là kết quả của việc subscribe mới của Client (giống như tin nhắn ACK báo subscribe thành công). RETAIN phải bằng 0 nếu không quan tâm tới kết quả của việc subscribe.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lwt">LWT</h3>
<div class="paragraph">
<p>Gói tin LWT (last will and testament) không thực sự biết được Client có trực tuyến hay không, cái này do gói tin KeepAlive đảm nhận. Tuy nhiên gói tin LWT như là thông tin điều gì sẽ xảy đến sau khi thiết bị ngoại tuyến.</p>
</div>
<div class="paragraph">
<p><strong>Một ví dụ</strong></p>
</div>
<div class="paragraph">
<p>Tôi có 1 cảm biến, nó gởi những dữ liệu quan trọng và rất không thường xuyên. Nó có đăng ký trước với Broker một tin nhắn lwt ở topic <strong>/node/gone-offline</strong> với tin nhắn <strong>id</strong> của nó. Và tôi cũng đăng ký theo dõi topic <strong>/node/gone-offline</strong>, sẽ gởi SMS tới điện thoại thôi mỗi khi nhận được tin nhắn nào ở kênh mà tôi theo dõi.
Trong quá trình hoạt động, cảm biến luôn giữ kết nối với Broker bởi việc luôn gởi gói tin keepAlive. Nhưng nếu vì lý do gì đó, cảm biến này chuyển sang ngoại tuyến, kết nối tới Broker timeout do Broker không còn nhận được gói keepAlive.
Lúc này, do cảm biến của tôi đã đăng ký LWT, do vậy broker sẽ đóng kết nối của Cảm biến, đồng thời sẽ publish một gói tin là Id của cảm biến vào kênh <strong>/node/gone-offline</strong>, dĩ nhiên là tôi cũng sẽ nhận được tin nhắn báo cái cảm biến yêu quý của mình  đã ngoại tuyến.</p>
</div>
<div class="paragraph">
<p><strong>Ngắn gọn</strong></p>
</div>
<div class="paragraph">
<p>Ngoài việc đóng kết nối của Client đã ngoại tuyến, gói tin LWT có thể được định nghĩa trước và được gởi bởi Broker tới kênh nào đó khi thiết bị đăng ký LWT ngoại tuyến.</p>
</div>
</div>
<div class="sect1">
<h2 id="_mqtt_client">MQTT Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Như chúng ta đã tìm hiểu ở phần trước, 2 thành phần publisher và subscriber là đặc trưng tạo nên giao thức MQTT. Các MQTT Client không kết nối trực tiếp với nhau, mọi gói dữ liệu được gửi đi đều thông qua MQTT Broker. Để có thể triển khai các ứng dụng của MQTT Client, chúng ta cần MQTT Broker (sẽ được trình bày trong phần sau). Ở phần này chúng ta sẽ làm quen với giao thức MQTT bằng các ví dụ sử dụng MQTT Client thông dụng và các dịch vụ MQTT Broker miễn phí và phổ biến, 2 trong số chúng là <a href="http://test.mostquitto.org" class="bare">test.mostquitto.org</a> và <a href="http://cloudmqtt.com" class="bare">cloudmqtt.com</a></p>
</div>
<div class="sect2">
<h3 id="_mqtt_lens">MQTT Lens</h3>
<div class="paragraph">
<p><strong>Thông tin</strong></p>
</div>
<div class="paragraph">
<p>MQTT Lens là một tiện ích mở rộng của Chrome (Chrome Extension), nó sử dụng trình duyệt Chrome để kết nối đến  MQTT Broker cũng như test các tính năng publish/subcribe của giao thức MQTT. Đây là một công cụ rất hữu ích để kiểm tra kết nối đến MQTT Broker và kiểm tra việc gửi và nhận gói tin.</p>
</div>
<div class="paragraph">
<p>Một số thông tin của MQTT Lens được trình bày ở bảng dưới.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<caption class="title">Bảng 2. Short Profile</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chrome App</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">License</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MIT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operating Systems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows, Linux &amp; MacOSX</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Website</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"https</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Kết nối</strong></p>
</div>
<div class="paragraph">
<p>Chúng ta sẽ sử dụng công cụ này với dịch vụ MQTT Broker tại iot.eclipse.org được trình bày như các bước bên dưới:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bước 1: Cài đặt trình duyệt Chrome, thực hiện đăng nhập tài khoản của bạn vào chrome, truy cập vào địa chỉ <a href="https://chrome.google.com/webstore/category/extensions" class="bare">chrome.google.com/webstore/category/extensions</a> và gõ mqttlens vào mục tìm kiếm tiện ích như hình bên dưới.</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/searchMQTTlens.png" alt="searchMQTTlens" width="600">
</div>
<div class="title">Hình 48. Hình ảnh tìm kiếm tiện ích mqttlens trên chrome store</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Bước 2: Thêm và khởi chạy MQTT lens</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/addMQTTlens.png" alt="addMQTTlens" width="600">
</div>
<div class="title">Hình 49. Hình ảnh các bước thêm và khởi chạy tiện ích MQTT lens</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Bước 3 : Tạo 1 MQTT Client kết nối đến MQTT Broker eclipse như các bước bên dưới.</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/createATopic.png" alt="createATopic" width="600">
</div>
<div class="title">Hình 50. Hình ảnh tạo 1 MQTT client</div>
</div>
<div class="paragraph">
<p><strong>Giải thích</strong></p>
</div>
<div class="paragraph">
<p>Chúng ta sẽ tạo 1 connection có tên eclipse MQTT với host name của MQTT Broker là <code>iot.eclipse.org</code>, Broker này sẽ giúp trao đổi dữ liệu của các Client với nhau và lắng nghe các Client ở port 1883 (port sử dụng giao thức MQTT và không mã hóa dữ liệu, các port khác tham khảo tại <a href="https://test.mosquitto.org" class="bare">test.mosquitto.org</a>)
Ở connection này sẽ đăng kí nhận gói tin tại topic <code>Home/garden/sensor/#</code> (kí tự # cho phép subcribe các topic <code>Home/garden/sensor/1</code>, <code>Home/garden/sensor/2</code> vv&#8230;&#8203;). Tiếp theo chúng ta sẽ pulish 1 gói dữ liệu với nội dung <code>"Temp in garden: 27degree Celcius "</code> tại topic <code>Home/garden/sensor/1</code>.</p>
</div>
<div class="paragraph">
<p><strong>Kết quả</strong>: Tại mục subrcriptions, chúng ta sẽ nhận được gói dữ liệu đã publish do đã subcribe topic
<code>Home/garden/sensor/#</code> như hình bên dưới.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/connect2Clients.png" alt="connect2Clients" width="600">
</div>
<div class="title">Hình 51. Hình ảnh dữ liệu nhận được sau khi publish gói tin</div>
</div>
<div class="paragraph">
<p><strong>Mở rộng</strong></p>
</div>
<div class="paragraph">
<p>Tạo nhiều connection để subcribe và publish các gói tin với MQTT Broker iot.eclipse.org đồng thời test các gói tin với QoS và LWT</p>
</div>
</div>
<div class="sect2">
<h3 id="_mqtt_js">MQTT.js</h3>
<div class="paragraph">
<p>MQTT.js là một thư viện MQTT client, được viết bằng ngôn ngữ JavaScript trên nền tảng Node.js và hỗ trợ MQTT Over Websocket (MOW).</p>
</div>
<div class="paragraph">
<p>MQTT.js là dự án mã nguồn mở (open source), bạn có thể tải MQTT.js bản cập nhật mới nhất tại
<a href="https://github.com/mqttjs/MQTT.js.git" class="bare">github.com/mqttjs/MQTT.js.git</a></p>
</div>
<div class="paragraph">
<p><strong>Cài đặt</strong></p>
</div>
<div class="paragraph">
<p>Trước tiên ta cần kiểm tra hệ điều hành đã hỗ trợ Node.js trước khi cài đặt MQTT.js. Nếu chưa thì có thể tham khảo cách cài đặt tại <a href="https://nodejs.org/en/" class="bare">nodejs.org/en/</a></p>
</div>
<div class="paragraph">
<p>Khởi tạo một dự án Node.js. Để dễ quản lý, có thể tạo một thư mục riêng, ví dụ <code>mqtt-client</code> và một file javascrip trong đó, ví dụ như <code>client-a.js</code>. Đi đến thư mục này và mở terminal (linux OS) hoặc Command Prompt (trên Windowns OS) và dùng lệnh:</p>
</div>
<div class="paragraph">
<p><code>npm init</code></p>
</div>
<div class="paragraph">
<p>Khi chạy lệnh này, bạn cũng cần phải khai báo thêm một số thông tin cho dự án như tên, phiên bản, keywords, tác giả,&#8230;&#8203; Sau khi tạo xong, trong thư mục vừa tạo sẽ xuất hiện một file là <code>package.json</code> với nội dung là các phần đã khai báo. File này cũng chứa thuộc tính dùng để lưu trữ các package chúng ta đã cài đặt.</p>
</div>
<div class="paragraph">
<p>Tiếp theo chúng ta sẽ cài <code>MQTT.js</code>, sử dụng lệnh:</p>
</div>
<div class="paragraph">
<p><code>npm install mqtt --save</code></p>
</div>
<div class="paragraph">
<p>Sau khi cài đặt xong, bạn có thể sử dụng module <code>mqtt</code> để thực hiện việc kết nối MQTT Client với Broker, publish message hay subscribe topic. Tất nhiên, toàn bộ các file liên quan đến thư viện sẽ nằm trong thư mục <code>node_modules</code>, trong thư mục dự án.</p>
</div>
<div class="paragraph">
<p>Để hiểu rõ hơn cách hoạt động của MQTT.js, chúng ta sẽ tạo ra thêm 1 số file mã nguồn Javascript (file .js) là <code>client-a.js</code> và <code>client-b.js</code> thực hiện subcribe và puslish các gói tin.</p>
</div>
<div class="paragraph">
<p><strong>Nội dung thực hiện</strong></p>
</div>
<div class="paragraph">
<p>2 Client này sẽ kết nối vào cùng 1 MQTT Broker. Client A sẽ subscribe kênh <code>/client-a/sub</code>, nếu nhận bất kỳ dữ liệu nào được publish vào kênh này, client A sẽ public dữ liệu <code>Hello from client A</code> vào kênh <code>/client-b/sub</code> và đóng kết nối, kết thúc. Client B sẽ subscribe kênh <code>/client-b/sub</code>, nếu nhận bất kỳ dữ liệu nào được public vào kênh này, client B sẽ đóng kết nối và kết thúc. Ngay khi kết nối vào Broker, client B sẽ public 1 gói tin <code>Hello from client B</code> vào kênh <code>/client-a/sub</code></p>
</div>
<div class="paragraph">
<p><strong>Mã nguồn của client A</strong></p>
</div>
<div class="listingblock">
<div class="title">client-a.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">// tạo biến mqtt sử dụng các chức năng của module mqtt
var mqtt = require('mqtt')
// tạo biến client sử dụng thuộc tính connect để kết nối đến broket MQTT với hostname mqtt://iot.eclipse.org
var client = mqtt.connect('mqtt://iot.eclipse.org')
// function có chức năng subscribe 1 topic nếu đã kết nối thành công đến broker
client.on('connect', function() {
    console.log('Client A connected')
    // client subcribe topic /client-a/sub
    client.subscribe('/client-a/sub')
})
// function có chức năng gửi 1 gói tin đễn đến topic đã đăng kí
client.on('message', function(topic, message) {
	// in ra màn hình console 1 message ở định dạng string
    console.log(message.toString())
    // publish gói tin 'Hello from client A' đến topic /client-b/sub
    client.publish('/client-b/sub', 'Hello from client A')
    // đóng kết nối của client
    client.end()
})
console.log('Client A started')</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mã nguồn của client B</strong></p>
</div>
<div class="listingblock">
<div class="title">client-b.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">// tạo biến mqtt sử dụng các chức năng của module mqtt
var mqtt = require('mqtt')
// tạo biến client sử dụng thuộc tính connect để kết nối đến broket MQTT với hostname mqtt://iot.eclipse.org
var client = mqtt.connect('mqtt://iot.eclipse.org')
// function có chức năng subscribe 1 topic nếu đã kết nối thành công đến broker
client.on('connect', function() {
    console.log('Client B connected')
    // client subcribe topic /client-b/sub
    client.subscribe('/client-b/sub')
    // publish gói tin 'Hello from client B' đến topic /client-a/sub
    client.publish('/client-a/sub', 'Hello from client B')
})

client.on('message', function(topic, message) {
	// in ra màn hình console 1 message ở định dạng string
    console.log(message.toString())
    // đóng kết nối của client
    client.end()
})
console.log('Client B started')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kết quả hiển thị như hình bên dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/MQTTjsConsole.png" alt="MQTTjsConsole" width="511">
</div>
<div class="title">Hình 52. Hình ảnh kết quả khi khởi chạy các MQTT client</div>
</div>
<div class="paragraph">
<p>Ngoài ra, MQTT.js còn cung cấp thêm các lệnh để có thể tương tác với Broker thông qua terminal. Để làm được điều này, chúng ta cài đặt MQTT.js như một module toàn cục bằng cách sử dụng lệnh:</p>
</div>
<div class="paragraph">
<p><code>npm install mqtt -g</code>.</p>
</div>
<div class="paragraph">
<p>Bạn có thể kiểm tra bằng cách mở 2 màn hình terminal, ở màn hình 1 (tạm gọi là subscriber) sẽ subscribe vào topic tên là "topicA" bằng lệnh:</p>
</div>
<div class="paragraph">
<p><code>mqtt sub -t 'topicA' -h 'test.mosquitto.org' -v</code></p>
</div>
<div class="paragraph">
<p>Ở terminal thứ 2 (tạm gọi là publisher) thực hiện publish một tin nhắn với nội dung "hello subscriber" tới "topicA":</p>
</div>
<div class="paragraph">
<p><code>mqtt pub -t 'topicA' -h 'test.mosquitto.org' -m 'hello subscriber'</code></p>
</div>
<div class="paragraph">
<p>Các options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-t</code> : MQTT topic, nơi sẽ thực hiện pushlish 1 message.</p>
</li>
<li>
<p><code>-h</code> : Xác định máy chủ sẽ kết nối đến.</p>
</li>
<li>
<p><code>-m</code> : Gửi 1 message dùng command line.</p>
</li>
<li>
<p><code>-v</code> : verbose, option cho phép ghi lại nhật kí hoạt động của các tập tin trong file cấu hình.</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/MQTTjsCommand.png" alt="MQTTjsCommand" width="600">
</div>
<div class="title">Hình 53. Hình ảnh message được publish dùng command line</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Để xem thêm các API khác trong MQTT.js, bạn có thể sử dụng lệnh: <code>mqtt help [command]</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_esp8266_mqtt_client">ESP8266 MQTT Client</h3>
<div class="paragraph">
<p>Thực tế có khá nhiều thư viện MQTT cho ESP8266 trên Arudino, ở đây chúng ta chỉ đề cập đến 2 thư viện phổ biến là <code>PubSubClient</code> và <code>ESP8266MQTTClient</code></p>
</div>
<div class="sect3">
<h4 id="_pubsubclient">PubSubClient</h4>
<div class="paragraph">
<p>Trong phần này chúng ta sẽ thực hiện kết nối board ESP8266 WiFi Uno đến 1 broker sử dụng thư viện PubSubClient.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 1 :</strong> Download thư viện PubSubClient tại đường dẫn <a href="https://github.com/knolleary/pubsubclient" class="bare">github.com/knolleary/pubsubclient</a> và add vào chương trình Arduino. Ngoài ra có thể import thư viện này trong Arduino bằng cách tìm kiếm thư viện với từ khóa <code>PubSubClient</code>, chọn thư viện PubSubClient của tác giả Nick O&#8217;Leary và nhấn install.</p>
</li>
<li>
<p><strong>Bước 2 :</strong> Viết và nạp chương trình cho ESP8266. Mã nguồn được trình bày ở phía dưới</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;PubSubClient.h&gt;

const char* ssid = "........";
const char* password = ".........";
const char* mqtt_server = "broker.mqtt-dashboard.com";

WiFiClient espClient;
PubSubClient client(espClient);

void setup() {
  pinMode(16, OUTPUT);
  Serial.begin(115200);
  // hàm thực hiện chức năng kết nối Wifi và in ra địa chỉ IP của ESP8266
  setup_wifi();
  // cài đặt server là broker.mqtt-dashboard.com và lắng nghe client ở port 1883
  client.setServer(mqtt_server, 1883);
  // gọi hàm callback để thực hiện các chức năng publish/subcribe
  client.setCallback(callback);
  // gọi hàm reconnect() để thực hiện kết nối lại với server khi bị mất kết nối
  reconnect();
}

void setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  // kết nối đến mạng Wifi
  WiFi.begin(ssid, password);
  // in ra dấu . nếu chưa kết nối được đến mạng Wifi
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  // in ra thông báo đã kết nối và địa chỉ IP của ESP8266
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  //in ra tên của topic và nội dung nhận được từ kênh MQTT lens đã publish
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i = 0; i &lt; length; i++) {
    Serial.print((char)payload[i]);
  }
  // kiểm tra nếu dữ liệu nhận được từ topic ESP8266/LED_GPIO16/status là chuỗi "on"
  // sẽ bậtled GPIO16, nếu là chuỗi "off" sẽ tắt led GPIO16
  if ((char)payload[0] == 'o' &amp;&amp; (char)payload[1] == 'n') //on
    digitalWrite(16, LOW);
  else if ((char)payload[0] == 'o' &amp;&amp; (char)payload[1] == 'f' &amp;&amp; (char)payload[2] == 'f') //off
    digitalWrite(16, HIGH);
  Serial.println();
}

void reconnect() {
  // lặp cho đến khi được kết nối trở lại
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    if (client.connect("ESP8266")) {
      Serial.println("connected");
      // publish gói tin "Connected!" đến topic ESP8266/connection/board
      client.publish("ESP8266/connection/board", "Connected!");
      // đăng kí nhận gói tin tại topic ESP8266/LED_GPIO16/status
      client.subscribe("ESP8266/LED_GPIO16/status");

    } else {
      // in ra màn hình trạng thái của client khi không kết nối được với MQTT broker
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // delay 5s trước khi thử lại
      delay(5000);
    }
  }
}

void loop() {
  // kiểm tra nếu ESP8266 chưa kết nối được thì sẽ thực hiện kết nối lại
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Giải thích mã nguồn:</strong></p>
</div>
<div class="paragraph">
<p>Chúng ta sẽ tạo một biến <code>espClient</code> thuộc lớp <code>WiFiClient</code>, biến này được khai báo là MQTT Client và sử dụng các thuộc tính của thư viện <code>PubSubClient</code>. Tại hàm <code>setup()</code> sẽ thiết lập ESP8266 ở chế độ station, kết nối đến mạng wifi. Bên cạnh đó hàm <code>setup()</code> cũng sẽ thực hiện chức năng tự động kết nối lại với MQTT Broker khi xảy ra mất kết nối đồng thời thực hiện các chức năng publish, subscribe của 1 MQTT Client thông qua hàm <code>reconnect()</code>. Hàm <code>callback()</code> có nhiệm vụ lấy dữ liệu của các puslisher khi publish 1 message sau đó gửi đến các client đã subscribe topic đó và kiểm tra nội dung của message để điều khiển led ở GPIO16. Hàm <code>loop()</code> có chức năng kết nối Client là ESP8266 với Broker, thực  hiện chức năng publish 1 message và subscribe topic. <code>client.loop()</code> sẽ kiểm tra thời gian kết nối của Client với gói <code>KEEP_ALIVE</code> để đưa ra các thông tin về trạng thái kết nối của ESP8266 đồng thời lấy dữ liệu của message từ buffer để gửi đến các Client đã subcribe topic.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 3 :</strong> Mở MQTT lens trên trình duyệt Chrome, tạo 1 connection với host name <code>broker.mqtt-dashboard.com</code>, sử dụng port 1883. Thực hiện subscribe topic <code>ESP8266/connection/board</code>. Sau khi nhấn nút subscribe trên MQTT lens sẽ xuất hiện 1 message gửi từ esp8288 với nội dung <code>connnected</code>. Thực hiện pushlish các message vào topic <code>ESP8266/LED_GPIO16/status</code>. Nếu pushlish message với nội dung <code>on</code>, led GPIO16 trên board sẽ sáng, pushlish message <code>off</code> led GPIO16 trên board sẽ tắt. Các message với nội dung khác thì vẫn sẽ hiển thị dữ liệu nhận được trên serial terminal của Arduino nhưng sẽ không có tác dụng điều khiển led GPIO16. Kết quả hiển thị như hình bên dưới:</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/MQTTLEnsPubSUb.png" alt="MQTTLEnsPubSUb" width="897">
</div>
<div class="title">Hình 54. Kết quả hiển thị trên serial terminal và MQTT lens khi sử dụng thư viện pubsubClient</div>
</div>
</div>
<div class="sect3">
<h4 id="_esp8266mqttclient">ESP8266MQTTClient</h4>
<div class="paragraph">
<p>Tiếp theo, chúng ta sẽ tìm hiểu cách sử dụng thư viện ESP8266MQTTClient, thư viện được cộng đồng developer đánh giá là ổn định dễ sử dụng hơn so với thư viện PubSubClient thông qua 1 ứng dụng điều khiển led trên board ESP8266 WiFi Uno bằng 1 ứng dụng trên điện thoại smartphone.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 1 :</strong> Download thư viện <code>ESP8266MQTTClient</code> tại đường dẫn <a href="https://github.com/tuanpmt/ESP8266MQTTClient" class="bare">github.com/tuanpmt/ESP8266MQTTClient</a> và add vào chương trình Arduino. Ngoài ra có thể import thư viện này trong Arduino bằng cách tìm kiếm thư viện với từ khóa <code>ESP8266MQTT</code>, chọn thư viện của tác giả Tuan PM, version 1.3 và nhấn install.</p>
</li>
<li>
<p><strong>Bước 2 :</strong> Viết và nạp chương trình cho ESP8266. Mã nguồn được trình bày ở phía dưới.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266MQTTClient.h&gt;
#include &lt;ESP8266WiFi.h&gt;

#define ledPin 16   //Led on board ESP8266 WiFi Uno

MQTTClient mqtt;

const char* ssid = "Your SSID";
const char* password = "Your password";

void setup() {
  Serial.begin(115200);
  pinMode(ledPin, OUTPUT);

  // OFF led GPIO16 khi bắt đầu chương trình
  digitalWrite(ledPin, HIGH);

  // Thiết lập ESP8266 ở chế độ STA và kết nối Wifi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("\nConnecting to ");
  Serial.println(ssid);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());

  // Kết nối đến server MQTT, in ra id của topic "esp8266/GPIO16" đồng thời đăng kí nhận message với gói QoS 0,
  // và subcribe các topic "hello/esp8266"
  mqtt.onConnect([]() {
    Serial.printf("MQTT: Connected\r\n");
    Serial.printf("Subscribe id: %d\r\n", mqtt.subscribe("esp8266/GPIO16", 0));
    mqtt.subscribe("esp8266/GPIO16", 0);
  });

  // Thực hiện chức năng subscribe topic và publish các message
  mqtt.onSubscribe([](int sub_id) {
    //in ra id của các topic đã subscribe là "hello/esp8266" và "MQTTlens/test/#"
    Serial.printf("Subscribe topic id: %d ok\r\n", sub_id);

    //publish message có nội dung hello app đến topic Broker/app với gói QoS 0 và cờ retain 0
    mqtt.publish("Broker/app", "hello app", 0, 0);
  });

  // Xử lí dữ liệu nhận được của các topic đã subscribe
  mqtt.onData([](String topic, String data, bool cont) {
    Serial.printf("Data received, topic: %s, data: %s\r\n", topic.c_str(), data.c_str());

    // Nếu chuỗi nhận được là 'on' sẽ ON led trên board ESP8266 WiFi Uno, chuỗi 'off' sẽ OFF led
    if (topic == "esp8266/GPIO16" &amp;&amp; data[0] == 'o' &amp;&amp; data[1] == 'n' &amp;&amp; data[2] == '\0') {
      digitalWrite(ledPin, LOW);
      Serial.println("Turn on the led on board");
    } else if (topic == "esp8266/GPIO16" &amp;&amp; data[0] == 'o' &amp;&amp; data[1] == 'f' &amp;&amp; data[2] == 'f' &amp;&amp; data[3] == '\0' ) {
      digitalWrite(ledPin, HIGH);
      Serial.println("Turn off the led on board");
    }
  });
  // khởi tạo broker MQTT là iot.eclipse.org sử dụng phương thức websocket và lắng nghe client ở port 80
  mqtt.begin("ws://iot.eclipse.org:80/ws");
}

void loop() {
  // Hàm khởi tạo MQTT, kiểm tra và xử lí các dữ liệu từ các topic, kiểm tra các thuộc tính của giao
  // thức như gói keep-a-live, gói tin QoS, id của topic...,
  mqtt.handle();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Giải thích mã nguồn</strong></p>
</div>
<div class="paragraph">
<p>Tương tự như mã nguồn của chương trình sử dụng thư viện pubsubCLient, chúng ta cũng sẽ khởi tạo ESP8266 là MQTT Client trong class MQTT của thư viện ESP8266MQTTClient. Cài đặt ESP8266 ở chế độ Station và kết nối đến network wifi. Chức năng của các hàm trong thư viện đã được giải thích ở file mã nguồn, ở hàm <code>mqtt.onConnect()</code> chúng ta sẽ subscribe topic là <code>esp8266/GPIO16</code>. Hàm <code>mqtt.onSubscribe()</code> sẽ thực hiện puslish các message ở topic đã chỉ định là <code>Broker/app</code>. Hàm <code>mqtt.onData()</code> sẽ nhận, kiểm tra và xử lí dữ liệu nhận được từ topic đã subscribe. Ở đây ta sẽ dùng 1 public MQTT Broker là  iot.eclipse.org, sử dụng phương thức Websocket là lắng nghe các MQTT Client ở port 80, đây là port mặc định khi sử dụng Websocket. Việc gửi nhận dữ liệu bằng phương thức Websocket sẽ giúp giảm băng thông và độ trể khi truyền nhận dữ liệu thông qua giao thức MQTT. Chi tiết về Websocket chúng ta sẽ được học ở các bài học sau. Ở <code>loop()</code> chúng ta chỉ cần gọi hàm <code>handle()</code> để khởi tạo và kiểm tra các thuộc tính của giao thức cũng như xử lí, truyền và nhận dữ liệu từ các topic đã subscribe và public.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Để tìm hiểu chi tiết file cấu hình của thư viện, có thể xem tại <a href="https://github.com/tuanpmt/ESP8266MQTTClient/tree/master/src" class="bare">github.com/tuanpmt/ESP8266MQTTClient/tree/master/src</a>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 3 :</strong> Cài đặt và sử dụng ứng dụng trên điện thoại để điều khiển led GPIO16.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Truy cập vào <code>App Store</code> trên hệ điều hành iOS hoặc <code>CH Play</code> trên hệ điều hành Android. nhập từ khóa <code>IoT Smartconfig</code> và cài đặt ứng dụng <code>IoT Smartconfig</code> của developer Tuan PM. Hình ảnh ứng dụng hiển thị như bên dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/iotSmartConfig.png" alt="iotSmartConfig" width="600">
</div>
<div class="title">Hình 55. Hình ảnh ứng dụng IoT Smartconfig trên hệ điều hành iOS và Android</div>
</div>
<div class="paragraph">
<p>Ứng dụng này sử dụng với ESP8266 và ESP32, ngoài chức năng cơ bản là publish, subscribe của giao thức MQTT, ứng dụng còn có chức năng smartconfig để ESP8266 và ESP32 có thể dễ dàng thiết lập kết nối với các network wifi khác nhau một cách thuận tiện và nhanh chóng mà không phải nạp lại mã nguồn.</p>
</div>
<div class="paragraph">
<p>Tiếp theo, trượt ứng dụng qua phần MQTT, nhấn vào nút <code>connect</code> để kết nối đến server MQTT Broker <code>ws://iot.eclipse.org:80/ws</code>. Thực hiện subscribe topic <code>Broker/app</code> và publish message vào topic <code>esp8266/GPIO16</code>. Nếu publish message <code>on</code> vào <code>esp8266/GPIO16</code> thì led trên board ESP8266 WiFi Uno sẽ sáng, gửi <code>off</code> sẽ tắt led, đồng thời khi ESP8266 publish các message ở topic <code>Broker/app</code> thì nội dung các message sẽ được hiển thị trên ứng dụng. Kết quả hiển thị như hình bên dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/MQTTApp.png" alt="MQTTApp" width="300">
</div>
<div class="title">Hình 56. Hình ảnh subcribe topic và publish các message trên ứng dụng</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/MQTTArduino.png" alt="MQTTArduino" width="600">
</div>
<div class="title">Hình 57. Hình ảnh trên Serial terminal của Arduino</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mqtt_broker">MQTT Broker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ở phần trước chúng ta sử dụng các dịch vụ MQTT Broker miễn phí để thử nghiệm, tuy nhiên ta có thể sẽ phải trả phí dịch vụ với những ứng dụng lớn cần băng thông rộng và tốc độ đáp ứng nhanh, cộng với việc dữ liệu có thể bị tấn công do độ bảo mật thông tin chưa cao. Do đó, ở phần này, chúng ta sẽ tự mình xây dựng 1 MQTT Broker. Việc tự thiết lập 1 MQTT broker giúp chúng ta có thể sử dụng giao thức MQTT trên máy local mà không cần kết nối đến các dịch vụ  MQTT Broker ở mạng internet. Quá trình truyền, nhận và xử lí dữ liệu diễn ra 1 cách nhanh chóng cũng như bảo mật thông tin của người dùng. Tuy nhiên, để tạo được 1 MQTT Broker với đầy đủ tính năng của giao thức MQTT đòi hỏi chúng ta phải có kiến thưc tốt về  giao thức MQTT cũng như các ngôn ngữ lập trình bổ trợ cho việc xây dựng nó. Để bắt đầu, ta sẽ tạo ra 1 MQTT Broker đơn giản bằng cách dùng 1 module hỗ trợ sẵn có đó là <code>Mosca</code>.</p>
</div>
<div class="sect2">
<h3 id="_mosca">MOSCA</h3>
<div class="paragraph">
<p>Mosca là 1 trong số rất nhiều server MQTT Broker của giao thức MQTT. Có thể kế đến các server khác như HiveMQ, Apache Apollo, Mosquitto, Mongoose. Mosca có 1 số đặc điểm như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nó là 1 Node.js Broker, được viết bằng ngôn ngữ JavaScript vì vậy để có thể xây dựng MQTT Broker, chúng ta cần Node.js để chạy. Mosca có thể nhúng vào ứng dụng của bạn nếu ứng dụng này được viết bằng Node.js</p>
</li>
<li>
<p>Mosca là 1 multi-transport MQTT Broker, có nghĩa là nó hỗ trợ tất cả các chức năng publish, subscribe của các broker khác. Danh sách các publish/subscribe broker được hỗ trợ bao gồm RabbitMQ, Redis, Mosquitto, ZeroMQ. Ở phần này chúng ta sẽ tạo ta 1 MQTT Broker đơn giản dùng Mosca với sự hỗ trợ của cơ sở dữ liệu <code>Mongodb</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_mục_tiêu">Mục tiêu</h4>
<div class="ulist">
<ul>
<li>
<p>Chúng ta sẽ tạo 1 MQTT Client là ESP8266 và 1 MQTT Client trên máy tính sử dụng MQTT.js nhằm kết nối đến MQTT Broker , subscribe topic và publish các message.</p>
</li>
<li>
<p>Dùng Mosca tạo 1 MQTT Broker trên máy tính cá nhân nhằm broadcast messages (truyền bá các gói tin) đến các MQTT Client.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_các_bước_thực_hiện">Các bước thực hiện</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 1 :</strong> Trước tiên, chúng ta nên tạo 1 folder để  thiết lập 1 MQTT Broker trên máy local. Đi đến folder này, tạo file package.js bằng lệnh <code>npm init</code> và thiết lập các thông tin của dự án. Tiếp theo, cài đặt module mosca bằng lệnh <code>npm install mosca --save</code>. Để lắng nghe các kết nối đến từ client cũng như lưu trữ dữ liệu về thông tin kết nối và nội dung các message ta cần công cụ hỗ trợ đó là <code>MongoDB</code>, bạn cũng có thể chọn Redis, Mosquitto, RabbitMQ&#8230;&#8203; và tìm hiểu thêm về điểm mạnh, yếu của các cơ sở dữ liệu này. Để cài đặt MongoDB, chúng ta sẽ truy cập vào điạ chỉ <a href="https://docs.mongodb.com/manual/administration/install-community/" class="bare">docs.mongodb.com/manual/administration/install-community/</a>, tùy theo hệ điều hành để chọn gói cài đặt thích hợp. Sau khi cài đặt xong, chúng ta sẽ mở port 27017 (port mặc định khi dùng mongodb, chúng ta có thể  điều chỉnh port ở file cấu hình của mongodb) để lắng nghe các kết nối từ client thông qua lệnh
<code>sudo service mongod start</code>. Trên hệ điều hành Linux, có thể kiểm tra các kết nối trên hệ thống bằng lệnh <code>Netstat</code> như hình dưới:</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/netstatPort.png" alt="netstatPort" width="600">
</div>
<div class="title">Hình 58. Hình ảnh port 27017 đã mở thành công và lắng nghe các kết nối</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 2 :</strong> Tạo file Javascript để viết mã nguồn cho MQTT Broker. Ví dụ về mã nguồn của file serverMosca.js được viết bên dưới:</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_mã_nguồn_file_servermosca_js">Mã nguồn file serverMosca.js</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var mosca = require('mosca');   // Khai báo biến mosca sử dụng các thuộc tính của module mosca
// Sử dụng thư viện ascoltatore nhằm hỗ trợ publish message, subscribe topic đến  từ các Broker/Protocol
var ascoltatore = {

  type: 'mongo',
  url: 'mongodb://localhost:27017/mqtt', // url: địa chỉ url của mongodb, server sẽ lắng nghe các client ở địa
                                         // chỉ localhost:27017
  pubsubCollection: 'ascoltatori',       // pubsubCollection: Nơi để lưu trữ các message của mongodb
  mongo: {}                              // mongo: Cài đặt dành cho kết nối của mongo. Không sử dụng
};
var settings = {
  port: 1883,          // port kết nối đến server
  backend: ascoltatore // ascoltatore sẽ được gọi và thực thi khi tạo server được tạo để thiết lập các kết nối
};

// Lệnh tạo server sử dụng mosca
var server = new mosca.Server(settings);

// Thực hiện hàm setup, in ra màn hình console nếu có sự kiện ready của server
server.on('ready', setup);
function setup() {
  console.log('Mosca server is up and running');
}

// In ra dòng chữ client connected và id của client khi có sự kiện client kết nối thành công đến server
server.on('clientConnected', function(client) {
    console.log('client connected', client.id);
});

// In ra dòng chữ client disconnected và id của client khi có sự kiện client ngắt kết nối với server
server.on('clientDisconnected', function(client) {
    console.log('client disconnected', client.id);
});

// In ra message của client gửi ở dạng string khi có sự kiện client publish 1 message
server.on('published', function(packet, client) {
  console.log('Published', packet.payload.toString());
});</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bước 3 :</strong> Viết mã nguồn cho ESP8266. Để nhanh chóng, chúng ta sẽ dùng mã nguồn của thư viện ESP8266MQTTClient đã viết ở mục trước. Sửa đổi địa chỉ của MQTT Broker từ <code>mqtt.begin("mqtt://iot.eclipse.org:1883");</code> thành <code>mqtt.begin("mqtt://your-local-ip:1883");</code> với your-local-ip là địa chỉ IP của máy tính (ví dụ 192.168.1.7), chú ý rằng ESP8266 và MQTT Broker phải kết nối chung 1 network WiFi.</p>
</li>
<li>
<p><strong>Bước 4 :</strong> Tạo MQTT Client dùng MQTT.js. Chúng ta sẽ tạo 1 folder để chứa các file của MQTT Client. Tương tự như bước 1 , dùng <code>npm init</code> để tạo file package.js và thiết lập các thông tin của dự án. Tiếp theo cài đặt module mqtt bằng lệnh <code>npm install mqtt --save</code> và tạo file Javascript để viết nội dung cho MQTT Client. Ví dụ về mã nguồn file <code>moscaClient.js</code> được trình bày bên dưới:</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_mã_nguồn_file_moscaclient_js">Mã nguồn file moscaClient.js</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">// Khai báo biến mqtt để sử dụng các thuộc tính thuộc module mqtt
var mqtt = require('mqtt');
// Tạo 1 kết nối đến địa chỉ 192.168.1.7 port 1883 thông qua giao thức MQTT
var client  = mqtt.connect('mqtt://192.168.1.7:1883');
// Khi có sự kiện connect đến server, client sẽ subscribe topic MQTTlens/test/3 và
// publish 1 message "on" vào topic hello/world để ON led ở board ESP8266 WiFi Uno
client.on('connect', function () {
  client.subscribe('Broker/app');
  client.publish('esp8266/GPIO16', 'on');

})
// Khi có message gửi đến client, client sẽ chuyển đổi dữ liệu từ Buffer sang dạng String và in ra màn
// hình console dữ liệu nhận được và đóng kết nối.
client.on('message', function (topic, message) {
  // message is Buffer
  console.log(message.toString());
  //client.end();
})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_kết_quả">Kết quả</h4>
<div class="paragraph">
<p>Trên terminal, đi đến thư mục chứa file <code>moscaServer.js</code> và khởi chạy server bằng lệnh <code>node moscaServer.js</code>. Server sẽ khởi động và lắng nghe các kết nối đến từ các MQTT Client. Tiếp theo, nạp chương trình trên Arduino cho ESP8266, sau đó khởi chạy MQTT Client trên máy tính bằng lệnh <code>node moscaClient.js</code>. Khi có các sự kiện kết nối , ngắt kết nối, pushlish 1 message hay subcrible 1 topic đến từ các client thì bên phía server đều sẽ hiển thị nội dung và thông tin. Các terminal hiển thị kết quả như hình bên dưới:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/moscarServer.png" alt="moscarServer" width="600">
</div>
<div class="title">Hình 59. Hình ảnh thông tin nhận được từ các client ở server mosca</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/06-mqtt/mqttjsArduino.png" alt="mqttjsArduino" width="600">
</div>
<div class="title">Hình 60. Hình ảnh thông tin nhận được ở client mqtt.js và client ESP8266</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_một_số_mqtt_broker_sử_dụng_cho_sản_phẩm_thực_tế">Một số MQTT Broker sử dụng cho sản phẩm thực tế</h3>
<div class="sect3">
<h4 id="_mosquitto">Mosquitto</h4>
<div class="paragraph">
<p>Mosquitto là 1 MQTT Broker viết bằng ngôn ngữ lập trình C. Một số đặc điểm nổi bật của mosquitto là tốc độ truyền nhận và xử lí dữ liệu nhanh, độ ổn định cao, được sử dụng rộng rãi và phù hợp với những ứng dụng embedded. Thích hợp cho các hệ thống nhỏ chạy trên máy local như Raspberry Pi, bên cạnh đó Mosquitto cũng được hỗ trợ các giao thức TLS/SSL (các giao thức nhằm xác thực server và client, mã hóa các message để bảo mật dữ liệu).</p>
</div>
<div class="paragraph">
<p>Một số nhược điểm của mosquitto là khó thiết kế khi làm những ứng dụng lớn và ít phương thức xác thực thiết bị nên khả năng bảo mật vẫn chưa tối ưu.</p>
</div>
</div>
<div class="sect3">
<h4 id="_emq">EMQ</h4>
<div class="paragraph">
<p>EMQ (Erlang MQTT Broker) là một MQTT Broker được viêt bằng ngôn ngữ lập trình Erlang. Ưu điểm của EMQ là tính ổn định cao, thích hợp để thiết kế các hệ thống lớn do khả năng mở rộng ứng dụng dễ dàng cũng như khá dễ để cài đặt. Ngoài ra EMQ còn hỗ trợ nhiều phương thức xác thực người dùng, phát triển và cập nhật tính năng liên tục bởi cộng đồng developer. Tuy nhiên điểm yếu của MQTT broker này là khó đối với những người mới bắt đầu. Thông tin về EMQ có thể xem tại trang <a href="http://emqttd-docs.readthedocs.io/en/latest/#" class="bare">emqttd-docs.readthedocs.io/en/latest/#</a></p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_tổng_kết_7" class="sect0">Tổng kết</h1>
<div class="openblock partintro">
<div class="content">
Từ những nội dung đã trình bày ở trên, chúng ta phần nào hiểu rõ về cách thức hoạt động của giao thức MQTT cũng như vai trò của nó trong các ứng dụng IoT. Những nội dung được trình bày ở phần này chỉ là phần cơ bản của giao thức, vì đây là giao thức quan trọng và thường sử dụng trong IoT nên chúng ta hãy dành nhiều thời gian hơn để nghiên cứu thêm về hoạt động của các gói QoS, Keep alive, cũng như các vấn đề chứng thực tài khoản, vấn đề bảo mật dữ liệu khi sử dụng MQTT.
</div>
</div>
<h1 id="_websocket" class="sect0">Websocket</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>WebSoket là công nghệ hỗ trợ giao tiếp hai chiều giữa client và server bằng cách sử dụng một TCP socket để tạo một kết nối liên tục, hiệu quả và ít tốn kém. Mặc dù được thiết kế để chuyên sử dụng cho các ứng dụng web, lập trình viên vẫn có thể đưa chúng vào bất kì loại ứng dụng nào.</p>
</div>
<div class="paragraph">
<p>WebSockets mới xuất hiện trong HTML5, cho phép các kênh giao tiếp song song hai chiều và hiện đã được hỗ trợ trong nhiều trình duyệt. Kết nối được mở thông qua một HTTP request (yêu cầu HTTP), với những header đặc biệt thông báo cho Server (có hỗ trợ) chuyển sang kết nối Websocket. Kết nối này được duy trì để bạn có thể gởi và nhận dữ liệu một cách liên tục, không đứt quãng, và không cần bất kỳ HTTP header (overhead) nào nữa.</p>
</div>
<div class="paragraph">
<p>Websocket hỗ trợ cho các trình duyệt phổ biến hiện nay như: Google Chrome, Microsoft Edge, Internet Explorer, Firefox, Safari và Opera.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Ưu_điểm">Ưu điểm</h3>
<div class="paragraph">
<p>WebSockets cung cấp khả năng giao tiếp hai chiều với kết nối được duy trì, có độ trễ thấp, giúp Server dễ dàng giao tiếp với Client. Do đó, websocket sẽ phù hợp cho các ứng dụng real-time, người dùng sẽ không mất thời gian phải reload lại trình duyệt để cập nhật thông tin mới nhất như khi sử dụng giao thức HTTP.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nhược_điểm">Nhược điểm</h3>
<div class="paragraph">
<p>Giao thức Websocket chưa được tất cả các trình duyệt đã có hiện nay hỗ trợ. Websocket cũng đòi hỏi các ứng dụng web trên server để hỗ trợ nó.</p>
</div>
</div>
<div class="sect1">
<h2 id="_sử_dụng_esp8266_như_websocket_server">Sử dụng ESP8266 như Websocket Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Trong phần này, chúng ta sẽ thiết lập ứng dụng sử dụng ESP8266 như 1 Websocket Server và Trình duyệt như là một Web Socket Client để cập nhật trạng thái nút nhấn, cũng như điều khiển đèn LED trên board thời gian thực thông qua Trình duyệt.</p>
</div>
<div class="sect2">
<h3 id="_yêu_cầu_3">Yêu cầu</h3>
<div class="ulist">
<ul>
<li>
<p>Khởi động 1 Webserver (có hỗ trợ Websocket) trên chip ESP8266.</p>
</li>
<li>
<p>Khi truy cập vào địa chỉ IP của ESP8266 sẽ trả về 1 file HTML bao gồm nội dung của đoạn Javascript thiết lập kết nối Websocket đến ESP8266 đồng thời lắng nghe các gói tin từ ESP8266 Server.</p>
</li>
<li>
<p>Khi nhấn nút trên board ESP8266 sẽ gởi nội dung trạng thái nút nhất đến Web Browser hiển thị dạng hộp kiểm (checkbox), nhấn nút là có kiểm, không nhấn nút là không có kiểm.</p>
</li>
<li>
<p>Đồng thời khi nhấn hộp kiểm trên trình duyệt sẽ thay đổi trạng thái đèn LED trên board ESP8266.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_chuẩn_bị_4">Chuẩn bị</h3>
<div class="paragraph">
<p>Cài đặt thư viện, xem thêm <a href="#install-library">Cài đặt thư viện Arduino</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/me-no-dev/ESPAsyncWebServer" class="bare">github.com/me-no-dev/ESPAsyncWebServer</a></p>
</li>
<li>
<p><a href="https://github.com/me-no-dev/ESPAsyncTCP" class="bare">github.com/me-no-dev/ESPAsyncTCP</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_giới_thiệu_về_thư_viện_espasyncwebserver">Giới thiệu về thư viện ESPAsyncWebServer</h4>
<div class="paragraph">
<p>Thư viện ESPAsyncWebServer dùng cho việc thiết lập HTTP server và websocket server cho module ESP8266, và xử lí các sự kiện trên server-client.</p>
</div>
<div class="paragraph">
<p>Để các chương trình dùng thư viện ESPAsyncWebserver hoat động, ta cần dùng thêm thư viện ESPAsyncTCP.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Đoạn_code_javascript_để_tạo_kết_nối_web_socket">Đoạn code Javascript để tạo kết nối Web Socket</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">//Trình tự mở một websocket cơ bản:

var ws = new WebSocket('ws://domain.com:8000/'); // mở 1 websocket
ws.onopen = function() //
{
   // sự kiện khi websocket được mở thành công
};

ws.onmessage = function(evt)
{
    // sự kiện xảy ra khi client nhận dữ liệu từ server
};
ws.onclose = function() {
    // sự kiện khi websocket bị đóng
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nhúng_file_html_chứa_đoạn_code_js_vào_esp8266">Nhúng file HTML chứa đoạn code JS vào ESP8266</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;ESP8266 WebSocket&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt; Webscoket status &lt;span id="status" style="font-weight: bold;"&gt; disconnected &lt;/span&gt; &lt;/div&gt;
    &lt;div&gt; ESP8266 Button Status &lt;input type="checkbox" id="btn" name="btn" /&gt; &lt;/div&gt;
    &lt;div&gt; Control LED &lt;input type="checkbox" id="led" name="led" disabled="true" /&gt; &lt;/div&gt;

    &lt;script type="text/javascript"&gt;
        var button = document.getElementById('btn');
        var led = document.getElementById('led');
        var url = window.location.host; // hàm trả về url của trang hiện tại kèm theo port
        var ws = new WebSocket('ws://' + url + '/ws'); // mở 1 websocket với port 8000
        ws.onopen = function() //khi websocket được mở thì hàm này sẽ được thưc hiện
        {
            document.getElementById('status').innerHTML = 'Connected';
            led.disabled = false; //khi websocket được mở, mới cho phép
        };

        ws.onmessage = function(evt) // sự kiện xảy ra khi client nhận dữ liệu từ server
        {
            if(evt.data == 'BTN_PRESSED') {
                button.checked = true;
            } else if(evt.data == 'BTN_RELEASE') {
                button.checked = false;
            }
        };
        ws.onclose = function() { // hàm này sẽ được thực hiện khi đóng websocket
            led.disabled = true;
            document.getElementById('status').innerHTML = 'Disconnected';
        };

        led.onchange = function() { // thực hiện thay đổi bật/tắt led
            var status = 'LED_OFF';
            if (led.checked) {
                status = 'LED_ON';
            }
            ws.send(status)
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_chương_trình_hoàn_chỉnh_cho_esp8266">Chương trình hoàn chỉnh cho ESP8266</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESPAsyncWebServer.h&gt;

const char* ssid = "******";
const char* password = "*********";
const int LED = 16;
const int BTN = 0;

// để đưa đoạn code HTML vào chương trình Arduino, cần chuyển đổi code HTML sang dạng char

const char index_html[] PROGMEM = ""
"&lt;!DOCTYPE HTML&gt;"
"&lt;html&gt;"
"&lt;head&gt;"
"    &lt;title&gt;ESP8266 WebSocket&lt;/title&gt;"
"&lt;/head&gt;"
"&lt;body&gt;"
"    &lt;div&gt; Webscoket status &lt;span id=\"status\" style=\"font-weight: bold;\"&gt; disconnected &lt;/span&gt; &lt;/div&gt;"
"    &lt;div&gt; ESP8266 Button Status &lt;input type=\"checkbox\" id=\"btn\" name=\"btn\" /&gt; &lt;/div&gt;"
"    &lt;div&gt; Control LED &lt;input type=\"checkbox\" id=\"led\" name=\"led\" disabled=\"true\" /&gt; &lt;/div&gt;"
"    &lt;script type=\"text/javascript\"&gt;"
"        var button = document.getElementById('btn');"
"        var led = document.getElementById('led');"
"        var status = document.getElementById('status');"
"        var url = window.location.host;"
"        var ws = new WebSocket('ws://' + url + '/ws');"
"        ws.onopen = function()"
"        {"
"            status.text = 'Connected';"
"            led.disabled = false;"
"        };"
"        ws.onmessage = function(evt)"
"        {"
"            if(evt.data == 'BTN_PRESSED') {"
"                button.checked = true;"
"            } else if(evt.data == 'BTN_RELEASE') {"
"                button.checked = false;"
"            }"
"        };"
"        ws.onclose = function() {"
"            led.disabled = true;"
"            status.text = 'Disconnected';"
"        };"
"        led.onchange = function() {"
"            var status = 'LED_OFF';"
"            if (led.checked) {"
"                status = 'LED_ON';"
"            }"
"            ws.send(status)"
"        }"
"    &lt;/script&gt;"
"&lt;/body&gt;"
"&lt;/html&gt;";

AsyncWebServer server(8000);
AsyncWebSocket ws("/ws");


// Hàm xử lí sự kiện trên Server khi client là browser phát sự kiện
void onWsEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len) {
  if (type == WS_EVT_DATA &amp;&amp; len &gt; 0) { // type: loại sự kiện mà server nhận được. Nếu sự kiện nhận được là từ websocket thì bắt đầu xử lí
    data[len] = 0;
    String data_str = String((char*)data); // ép kiểu, đổi từ kiểu char sang String
    if (data_str == "LED_ON") {
      digitalWrite(LED, 0); // Khi client phát sự kiện "LED_ON" thì server sẽ bật LED
    } else if (data_str == "LED_OFF") {
      digitalWrite(LED, 1); // Khi client phát sự kiện "LED_OFF" thì server sẽ tắt LED
    }
  }

}
void setup()
{
  pinMode(LED, OUTPUT);
  pinMode(BTN, INPUT);
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  WiFi.mode(WIFI_AP_STA);
  WiFi.begin(ssid, password);
  if (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.printf("STA: Failed!\n");
    WiFi.disconnect(false);
    delay(1000);
    WiFi.begin(ssid, password);
  }


  ws.onEvent(onWsEvent); // gọi hàm onWsEvent
  server.addHandler(&amp;ws);
  server.on("/", HTTP_GET, [](AsyncWebServerRequest * request) {

    request-&gt;send_P(200, "text/html", index_html); // trả về file index.html trên giao diện browser khi browser truy cập vào IP của server
  });
    server.begin(); // khởi động server

}


void loop()
{
  static bool isPressed = false;
  if (!isPressed &amp;&amp; digitalRead(BTN) == 0) { //Nhấn nút nhấn GPIO0
    isPressed = true;
    ws.textAll("BTN_PRESSED");
  } else if (isPressed &amp;&amp; digitalRead(BTN)) { //Nhả nút nhấn GPIO0
    isPressed = false;
    ws.textAll("BTN_RELEASE");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực hiện sau khi kiểm tra mã nguồn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a></p>
</li>
<li>
<p><a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_kết_quả_2">Kết quả</h3>
<div class="paragraph">
<p>Sau khi biên dịch xong code trên Arduino, ta vào browser, truy cập vào địa chỉ IP của ESP8266 đã trả về trên Serial Monitor cùng với port đã thiết lập trên server, ở trường hợp này là 192.168.1.65:8000</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/07-websocket/websocketBrowser.png" alt="websocketBrowser" width="500">
</div>
<div class="title">Hình 61. Cửa sổ trình duyệt có thể điều khiển ESP8266 thông qua Web Socket</div>
</div>
</div>
<div class="sect2">
<h3 id="_video_kết_quả">Video kết quả</h3>
<div class="videoblock">
<div class="content">
<iframe src="https://www.youtube.com/embed/pN3YSLiWbHk?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sử_dụng_esp8266_như_websocket_client">Sử dụng ESP8266 như Websocket Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Trong một số ứng dụng khác, chúng ta có 1 Server Websocket để thực hiện các tác vụ thời gian thực như Ứng dụng điện thoại, trình duyệt Web. Thì ESP8266 có thể kết nối trực tiếp vào các server này như 1 Websocket Client để tiếp nhận, hoặc gởi thông tin thông qua Websocket.</p>
</div>
<div class="paragraph">
<p>Một số dịch vụ sử dụng Websocket điển hình như dịch vụ tin nhắn <a href="https://slack.com">Slack</a>, dịch vụ cơ sở dữ liệu thời gian thực <a href="https://firebase.google.com">Firebase</a></p>
</div>
<div class="paragraph">
<p>Ở phần này, chúng ta sẽ sử dụng Node.js để tự xây dựng 1 Web server, vừa đóng vai trò là 1 Websocket Server. Có những tính năng:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Có thể cung cấp file <code>index.html</code> chứa các đoạn mã javascript tạo kết nối Websocket giữa trình duyệt với Server, giống như phần <a href="#server-nodejs">Server Nodejs</a></p>
</li>
<li>
<p>Cho phép kết nối Websocket đến, bao gồm từ trình duyệt, hay từ ESP8266</p>
</li>
<li>
<p>Server sẽ broadcast tất cả các gói tin từ bất kỳ 1 client nào gởi đến, tới tất cả các client còn lại.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Với tính năng như trên thì bạn có thể hình dung như sau: Nếu 1 cửa sổ trình duyệt có kết nối Websocket đến Server, khi nhấn 1 nút kiểm, thì sẽ gởi về server trạng thái của nút kiểm đó. Ví dụ <code>LED_ON</code>, server nhận được sẽ gởi dữ liệu <code>LED_ON</code> đến các trình duyệt còn lại (hoặc bao gồm cả ESP8266), và trình duyệt còn lại sẽ hiển thị trạng thái nút kiểm này đang bật.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/07-websocket/same-ctrl.png" alt="same ctrl" width="600">
</div>
<div class="title">Hình 62. Hai cửa sổ trình duyệt sẽ hiển thị trạng thái nút kiểm giống nhau khi click thay đổi</div>
</div>
<div class="sect2">
<h3 id="_javascript_websocket_client_trên_trình_duyệt">Javascript Websocket Client trên trình duyệt</h3>
<div class="paragraph">
<p>Với file <code>index.html</code> có chứa mã nguồn Javascript tạo kết nối đến Websocket, để cùng thư mục với file <code>server.js</code></p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;ESP8266 WebSocket&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt; Webscoket status &lt;span id="status" style="font-weight: bold;"&gt; disconnected &lt;/span&gt; &lt;/div&gt;
    &lt;div&gt; ESP8266 Button Status &lt;input type="checkbox" id="btn" name="btn" /&gt; &lt;/div&gt;
    &lt;div&gt; Control LED &lt;input type="checkbox" id="led" name="led" disabled="true" /&gt; &lt;/div&gt;

    &lt;script type="text/javascript"&gt;
        var button = document.getElementById('btn');
        var led = document.getElementById('led');
        var url = window.location.host; // hàm trả về url của trang hiện tại kèm theo port
        var ws = new WebSocket('ws://' + url + '/ws'); // mở 1 websocket với port 8000
        console.log('connecting...')
        ws.onopen = function() //khi websocket được mở thì hàm này sẽ được thưc hiện
        {
            document.getElementById('status').innerHTML = 'Connected';
            led.disabled = false; //khi websocket được mở, mới cho phép
            console.log('connected...')
        };

        ws.onmessage = function(evt) // sự kiện xảy ra khi client nhận dữ liệu từ server
        {
            console.log(evt.data)
            if(evt.data == 'BTN_PRESSED') {
                button.checked = true;
            } else if(evt.data == 'BTN_RELEASE') {
                button.checked = false;
            } else if(evt.data == 'LED_OFF') {
                led.checked = false;
            } else if(evt.data == 'LED_ON') {
                led.checked = true;
            }
        };
        ws.onclose = function() { // hàm này sẽ được thực hiện khi đóng websocket
            led.disabled = true;
            document.getElementById('status').innerHTML = 'Connected';
        };

        led.onchange = function() { // thực hiện thay đổi bật/tắt led
            var led_status = 'LED_OFF';
            if (led.checked) {
                led_status = 'LED_ON';
            }
            ws.send(led_status)
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_node_js_websocket_server">Node.js Websocket Server</h3>
<div class="paragraph">
<p>Trong phần này chúng ta cần dùng thư viện Websocket <code>ws</code> <a href="https://github.com/websockets/ws" class="bare">github.com/websockets/ws</a>. Bạn có thể cài đặt bằng cách:</p>
</div>
<div class="paragraph">
<p><code>npm install ws</code></p>
</div>
<div class="listingblock">
<div class="title">server.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var fs = require('fs');
var url = require('url');
var http = require('http');
var WebSocket = require('ws');


// function gửi yêu cầu(response) từ phía server hoặc nhận yêu cầu (request) của client gửi lên
function requestHandler(request, response) {
    fs.readFile('./index.html', function(error, content) {
        response.writeHead(200, {
            'Content-Type': 'text/html'
        });
        response.end(content);
    });

}

// create http server
var server = http.createServer(requestHandler);
var ws = new WebSocket.Server({ server });
var clients = [];

function broadcast(socket, data) {
    console.log(clients.length);
    for(var i=0; i&lt;clients.length; i++) {
        if(clients[i] != socket) {
            clients[i].send(data);
        }
    }
}
ws.on('connection', function(socket, req) {
    clients.push(socket);

    socket.on('message', function(message) {
        console.log('received: %s', message);
        broadcast(socket, message);
    });

    socket.on('close', function() {
        var index = clients.indexOf(socket);
        clients.splice(index, 1);
        console.log('disconnected');
    });
});

server.listen(8000);
console.log('Server listening on port 8000');</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_esp8266_websocket_client">ESP8266 Websocket Client</h3>
<div class="paragraph">
<p><a href="https://github.com/Links2004/arduinoWebSockets" class="bare">github.com/Links2004/arduinoWebSockets</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;Arduino.h&gt;

#include &lt;ESP8266WiFi.h&gt;
#include &lt;WebSocketsClient.h&gt; //https://github.com/Links2004/arduinoWebSockets
WebSocketsClient webSocket;

const char* ssid = "...";
const char* password = "...";
const int LED = 16;
const int BTN = 0;

void webSocketEvent(WStype_t type, uint8_t * payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      Serial.printf("[WSc] Disconnected!\n");
      break;
    case WStype_CONNECTED:
      {
        Serial.printf("[WSc] Connected to url: %s\n",  payload);
      }
      break;
    case WStype_TEXT:
      Serial.printf("[WSc] get text: %s\n", payload);
      if(strcmp((char*)payload, "LED_ON") == 0) {
        digitalWrite(LED, 0); // Khi client phát sự kiện "LED_ON" thì server sẽ bật LED
      } else if(strcmp((char*)payload, "LED_OFF") == 0) {
        digitalWrite(LED, 1); // Khi client phát sự kiện "LED_OFF" thì server sẽ tắt LED
      }
      break;
    case WStype_BIN:
      Serial.printf("[WSc] get binary length: %u\n", length);
      break;
  }
}

void setup() {
  pinMode(LED, OUTPUT);
  pinMode(BTN, INPUT);
  Serial.begin(115200);
  Serial.println("ESP8266 Websocket Client");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  webSocket.begin("192.168.0.106", 8000);
  webSocket.onEvent(webSocketEvent);

}

void loop() {
  webSocket.loop();
  static bool isPressed = false;
  if (!isPressed &amp;&amp; digitalRead(BTN) == 0) { //Nhấn nút nhấn GPIO0
    isPressed = true;
    webSocket.sendTXT("BTN_PRESSED");
  } else if (isPressed &amp;&amp; digitalRead(BTN)) { //Nhả nút nhấn GPIO0
    isPressed = false;
    webSocket.sendTXT("BTN_RELEASE");
  }
}</code></pre>
</div>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/07-websocket/browser-esp.png" alt="browser esp" width="600">
</div>
<div class="title">Hình 63. Click nút kiểm sẽ thay đổi trạng thái LED trên board</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tổng_kết_8">Tổng kết</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Việc sử dụng giao thức websocket sẽ có nhiều lợi ích cho các kết nối 2 chiều, luôn được duy trì và có độ trễ thấp.</p>
</div>
</div>
</div>
<h1 id="_fota" class="sect0">Firmware update over the air (FOTA)</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Các phương pháp phát triển phần mềm và sản phẩm phổ biến hiện nay, thì xuất bản kết quả từng giai đoạn thường mang lại hiệu quả cao, sản phẩm có thể đến tay người dùng sớm, nhận được phản hồi sớm từ khách hàng, và được điều chỉnh để hợp lý hơn. Chính việc phát hành sản phẩm sớm thường sẽ ít tính năng và cần cập nhật thêm tính năng, nâng cao chất lượng sản phẩm trong tương lai.</p>
</div>
<div class="paragraph">
<p>Cập nhật Ứng dụng từ xa trên các phần mềm điện thoại, máy tính đã rất phổ biến. Các phần mềm được cập nhật hàng tuần, tháng&#8230;&#8203; để sửa lỗi, nâng cấp tính năng.</p>
</div>
<div class="paragraph">
<p>Đối với các sản phẩm phần cứng cũng tương tự, chúng ta nên bổ sung các tính năng cập nhật từ xa ngay từ giai đoạn phát triển sản phẩm. Ngoài việc giúp nâng cấp các tính năng trong tương lai một cách dễ dàng, thì vấn để sửa lỗi, nâng cấp hệ thống từ xa sẽ giúp tiết kiệm được rất nhiều chi phí và nguồn lực.</p>
</div>
<div class="paragraph">
<p>Trong phần này, chúng ta sẽ tìm hiểu các phương pháp cập nhật từ xa cho ESP8266, làm sao để nạp Firmware không dây cho module, làm sao để ESP8266 có thể tự tải Firmware về, làm sao để ESP8266 có thể tự khởi động 1 HTTP Server để có giao diện Web upload firmware lên chip.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cập_nhật_firmware_từ_xa">Cập nhật firmware từ xa</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cập nhật firmware OTA (Over the Air) là tiến trình tải firmware mới vào ESP8266 module thay vì sử dụng cổng Serial. Tính năng này thực sự rất hữu dụng trong nhiều trường hợp giới hạn về kết nối vật lý đến ESP Module.</p>
</div>
<div class="paragraph">
<p>OTA có thể thực hiện với:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Arduino IDE</p>
</li>
<li>
<p>Web Browser</p>
</li>
<li>
<p>HTTP Server</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sử dụng OTA với tùy chọn dùng Arduino IDE trong quá trình phát triển, thử nghiệm, 2 tùy chọn còn lại phù hợp cho việc triển khai ứng dụng thực tế, cung cấp tính năng cập nhật OTA thông qua web hay sử dụng HTTP Server.</p>
</div>
<div class="paragraph">
<p>Trong tất cả các trường hợp, thì Firmware hỗ trợ OTA phải được nạp lần đầu tiên qua cổng Serial, nếu mọi thứ hoạt động trơn tru, logic ứng dụng OTA hoạt động đúng thì có thể thực hiện việc cập nhật firmware thông qua OTA.</p>
</div>
<div class="paragraph">
<p>Sẽ không có đảm bảo an ninh đối với quá trình cập nhật OTA bị hack. Nó phụ thuộc vào nhà phát triển đảm bảo việc cập nhật được phép từ nguồn hợp pháp, đáng tin cậy. Khi cập nhật hoàn tất, ESP8266 sẽ khởi động lại và thực thi code mới. Nhà phát triển phải đảm bảo ứng dụng thực trên module phải được tắt và khởi động lại 1 cách an toàn. Nội dung bên dưới cung cấp bổ sung các thông tin về an ninh, và an toàn cho tiến trình cập nhật OTA.</p>
</div>
<div class="sect2">
<h3 id="_bảo_mật">Bảo mật</h3>
<div class="paragraph">
<p>Khi ESP8266 được phép thực thi OTA, có nghĩa nó được kết nối mạng không dây và có khả năng được cập nhập Sketch mới. Cho nên khả năng ESP8266 bị tấn công sẽ nhiều hơn và bị nạp bởi mã thực thi khác là rất cao. Để giảm khả năng bị tấn công cần xem xét bảo vệ cập nhật của bạn với một mật khẩu, cổng sử dụng cố định khác biệt, v.v…</p>
</div>
<div class="paragraph">
<p>Kiểm tra những tính năng được cung cấp bởi thư viện ArduinoOTA thường xuyên, có thể được nâng cấp khả năng bảo vệ an toàn:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void setPort(uint16_t port);
void setHostname(const char* hostname);
void setPassword(const char* password);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Một số chức năng bảo vệ đã được xây dựng trong và không yêu cầu bất kỳ mã hóa nào cho nhà phát triển. ArduinoOTA và espota.py sử dụng Digest-MD5 để chứng thực việc tải firmware lên. Đơn giản là đảm bảo tính toàn vẹn của firmware bằng việc tính MD5.</p>
</div>
<div class="paragraph">
<p>Hãy phân tích rủi ro cho riêng ứng dụng của bạn và tùy thuộc vào ứng dụng mà quyết định những chức năng cũng như thư viện để thực hiện. Nếu cần thiết, có thẻ xem xét việc thực hiện các phương thức bảo vệ khỏi bị hack, ví dụ như cập nhật OTA chỉ cho tải lên chỉ theo lịch trình cụ thể, kích hoạt OTA chỉ được người dùng nhấn nút chuyên dụng “Cập nhật”, v.v…</p>
</div>
</div>
<div class="sect2">
<h3 id="_an_toàn">An toàn</h3>
<div class="paragraph">
<p>Quá trình OTA tiêu tốn nguồn tài nguyên và băng thông của ESP8266 khi tải lên. Sau đó, ESP8266 được khởi động lại và một Sketch mới được thực thi. Cần phân tích và kiểm tra ảnh hưởng của quá trình này tới các chức năng cũ và sketch mới của ESP module.</p>
</div>
<div class="paragraph">
<p>Nếu ESP được đặt ở xa và điều khiển một vài thiết bị, ta nên chú ý tới hoạt động của thiết bị nếu thiết bị ngừng hoạt động đột xuất do quá trình cập nhật. Do đó, ta cần phải xác định được trạng thái làm việc an toàn của thiết bị trước quá trình cập nhật. Ví dụ, module được dùng để điều khiển hệ thống tưới nước tự động trong vườn. Nếu trong quá trình hoạt động mà hệ thống điều khiển bị tắt đột ngột và các van bị mở, thì cả vườn sẽ bị ngập nước.</p>
</div>
<div class="paragraph">
<p>Các hàm sau đây được cung cấp bởi thư viện ArduinoOTA và được dùng để xử lý ứng dụng trong quá trình cập nhật OTA hoặc để xử lý khi OTA gặp lỗi:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">void onStart(OTA_CALLBACK(fn));
void onEnd(OTA_CALLBACK(fn));
void onProgress(OTA_CALLBACK_PROGRESS(fn));
void onError(OTA_CALLBACK_ERROR (fn));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_yêu_cầu_căn_bản">Yêu cầu căn bản</h3>
<div class="paragraph">
<p>Bộ nhớ Flash phải có đủ dung lượng để lưu cả sketch cũ (đang vận hành trên hệ thống) và sketch mới (cập nhật OTA).</p>
</div>
<div class="paragraph">
<p>Hệ thống File và EEPROM cũng cần dung lượng để lưu trữ.</p>
</div>
<div class="paragraph">
<p><strong>Hàm</strong> <code>ESP.getFreeSketchSpace();</code> được dùng để kiểm tra dung lượng trống cho sketch mới.</p>
</div>
</div>
<div class="sect2">
<h3 id="_update_process_memory_view">Update process - memory view</h3>
<div class="ulist">
<ul>
<li>
<p>Sketch mới sẽ được chứa trong dung lượng trống gĩưa sketch cũ và spiff will be stored in the space between the old sketch and the spiff.</p>
</li>
<li>
<p>Trong lần reboot tiếp theo thì “eboot” bootloader kiểm tra các câu lệnh.</p>
</li>
<li>
<p>Sketch mới sẽ được copy.</p>
</li>
<li>
<p>Sketch mới khởi động.</p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/update.png" alt="update" width="400">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ota_sử_dụng_arduino_ide">OTA sử dụng Arduino IDE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thưc hiện OTA với Arduino IDE chỉ nên thưc hiện khi:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Sử dụng nạp firmware cho module ESP8266 thông qua WiFi mà không dùng cổng Serial</p>
</li>
<li>
<p>ESP8266 và máy tính chạy Arduino IDE sử dụng chung mạng WiFi nội bộ</p>
</li>
<li>
<p>ESP8266 đã kết nối thành công vào mạng WiFi</p>
</li>
<li>
<p>Nạp firmware đã hỗ trợ OTA thông qua cổng Serial trước đó</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Trước khi bắt đầu, cần phải chắc chắn Arduino IDE đã được cài đặt phiên bản mới nhất, bao gồm gói ESP8266 cho Arudino, và Python 2.7</p>
</div>
<div class="sect2">
<h3 id="ota-step1">Bước 1: nạp firmware hỗ trợ OTA thông qua cổng Serial</h3>
<div class="paragraph">
<p>Mở sketch ví dụ mẫu <code>BasicOTA.ino</code>. Vào File &gt; Examples &gt; ArduinoOTA.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/00.png" alt="00" width="400">
</div>
<div class="title">Hình 64. Mở sketch ví dụ mẫu OTA</div>
</div>
<div class="paragraph">
<p>Cung cấp chính xác SSID và mật khẩu mạng WiFi đang dùng để ESP8266 có thể kết nối vào</p>
</div>
<div class="listingblock">
<div class="title">Cung cấp SSID và password</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">const char* ssid = "..........";
const char* password = "..........";</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Tùy vào phiên bản và board ESP bạn sử dụng, bạn có thể thấy ``Upload Using:`` trong menu. Lựa chọn này sẽ không hoạt động và không ảnh hưởng tới lựa chọn của bạn. Chức năng này tương thích với các phiên bản OTA cũ và bị gỡ bỏ ở platform package version 2.2.0.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Upload sketch <code>Ctrl+U</code> Khi hoàn thành, mở Serial Monitor <code>Ctrl+Shift+M</code> (xem <a href="#arudino-term">Sử dụng Arduino IDE Serial Monitor</a>) và kiểm tra module đã trup cập được WIFI chưa</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/basicota.png" alt="basicota" width="600">
</div>
<div class="title">Hình 65. Kiểm tra module ESP8266 đã truy cập được mạng WiFi nội bộ chưa</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
ESP module nên được reset sau khi Upload xong firmware
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266mDNS.h&gt;
#include &lt;WiFiUdp.h&gt;
#include &lt;ArduinoOTA.h&gt;

const char* ssid = "...";
const char* password = "...";

void setup() {
  Serial.begin(115200);
  Serial.println("Booting");
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  while (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("Connection Failed! Rebooting...");
    delay(5000);
    ESP.restart();
  }
  ArduinoOTA.onStart([]() {
    String type;
    if (ArduinoOTA.getCommand() == U_FLASH)
      type = "sketch";
    else // U_SPIFFS
      type = "filesystem";

    // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
    Serial.println("Start updating " + type);
  });
  ArduinoOTA.onEnd([]() {
    Serial.println("\nEnd");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });
  ArduinoOTA.setPassword((const char *)"ota-pass");
  ArduinoOTA.begin();
  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  ArduinoOTA.handle();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bước_2_lựa_chọn_cổng_nạp_thông_qua_ota">Bước 2: Lựa chọn cổng nạp thông qua OTA</h3>
<div class="paragraph">
<p>Khi module kết nối tới mạng WiFi thành công, sau vài giây, cổng esp8266-ota sẽ xuất hiện trên Arduino IDE. Lúc này bạn hoàn toàn có thể bỏ kết nối Serial từ board mạch đến máy tính. Arduino IDE có thể nạp firmware mới thông qua WiFi. Chọn port với địa chỉ IP hiện trên cửa sổ Serial Monitor ở bước trước.</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/select-port.png" alt="select port" width="400">
</div>
<div class="title">Hình 66. Chọn cổng nạp từ Network</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nếu cổng OTA không hiện lên, bạn cần thoát Arduino IDE, và mở lại. Kiểm tra lại port OTA. Nếu vẫn tiếp tục không hiển thị cổng OTA, kiểm tra tưòng lửa của máy và các cài đặt trên router.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_bước_3_sửa_firmware_mới_và_nạp_lại_thông_qua_wifi">Bước 3: Sửa firmware mới và nạp lại thông qua WiFi</h3>
<div class="paragraph">
<p>Sau khi đã chọn đúng cổng nạp OTA, bạn hoàn toàn có thể sửa lại firmware mới và nạp thông qua WiFi, tuy nhiên cần lưu ý như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Firmware mới phải đảm bảo kết nối đến WiFi không bị mất (ví dụ cấp sai mật khẩu)</p>
</li>
<li>
<p>Firmware mới phải có các hàm khởi tạo và xử lý OTA như <a href="#ota-step1">Bước 1: nạp firmware hỗ trợ OTA thông qua cổng Serial</a></p>
</li>
</ul>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/ota-ok.png" alt="ota ok" width="400">
</div>
<div class="title">Hình 67. Nạp firmware thành công thông qua OTA</div>
</div>
</div>
<div class="sect2">
<h3 id="_sử_dụng_mật_khẩu">Sử dụng mật khẩu</h3>
<div class="paragraph">
<p>Bảo vệ quá trình upload OTA với password là một quá trình khá đơn gỉản. Những việc bạn cần làm là bổ sung đoạn mã nguồn:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">ArduinoOTA.setPassword((const char *)"your-password");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sau đó upload lại sketch một lần nữa (dùng OTA). Sau khi biên dịch và upload xong, cửa sổ sẽ hiện lên yêu cầu nhập password:</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/ota-pass.png" alt="ota pass" width="300">
</div>
<div class="title">Hình 68. Password cho OTA</div>
</div>
<div class="paragraph">
<p>Nhập password, nếu đúng, kết quả là thông báo <code>Authenticating...OK</code> và quá trình nạp diễn ra bình thường.</p>
</div>
<div class="paragraph">
<p>Các lần nạp sau Arduino IDE sẽ nhớ mật khẩu và không hỏi lại, trừ khi bạn thay đổi mật khẩu OTA, và các bước xác thực không thành công, Arduino IDE sẽ hỏi lại bạn.</p>
</div>
<div class="paragraph">
<p>Cần lưu ý là password có thể dễ dàng thấy được, nếu IDE không được đóng sau lần upload cuối cùng. Việc này có thể được thực hiện bằng cách cho phép <code>Show verbose ouput during: upload</code> trong <code>File &gt; Preferences</code> và upload lên module.</p>
</div>
</div>
<div class="sect2">
<h3 id="_những_sự_cố_thường_gặp">Những sự cố thường gặp</h3>
<div class="paragraph">
<p>Nếu việc cập nhật OTA thất bại, bước đầu tiên bạn cần làm là kiểm tra phần báo lỗi hiện trên cửa sổ Log của Arduino IDE. Nếu việc này không giúp được bạn, hãy upload lại khi kiểm tra các thông tin của ESP hiện trên serial port.</p>
</div>
<div class="paragraph">
<p>Các nguyên nhân phổ biến gây lỗi OTA như sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Không đủ dung lượng bộ nhớ trên chip (ví dụ như ESP01 với 512KB bộ nhớ flash không đủ cho OTA).</p>
</li>
<li>
<p>Khu vực dữ liệu cho SPIFFS quá nhiều, không còn đủ để chưa firmware, trong trường hợp bạn có 4MB Flash thì trường hợp này không xảy ra.</p>
</li>
<li>
<p>Khu vực bộ nhớ chưa firmware quá ít, tối thiểu là 512KB</p>
</li>
<li>
<p>Không reset module ESP sau lần upload đầu dùng Serial Port.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cập_nhật_firmware_dùng_web_browser">Cập nhật Firmware dùng Web Browser</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Khi thực hiện cập nhật firmware dùng Web Browser, ESP8266 sẽ khởi động 1 HTTP Server, với 1 form upload. Khi truy cập đúng địa chỉ của nó, bạn sẽ được cung cấp 1 giao diện để chọn file binary, và upload lên Chip. Việc này hữu dụng khi không dùng Arudino IDE cho việc cập nhật, sử dụng luôn trình duyệt sẵn có. Hoặc tích hợp vào 1 ứng dụng mà bạn có thể muốn cập nhật nó trong tương.</p>
</div>
<div class="paragraph">
<p>Cập nhật với web browser được thực hiện bằng thư viện <code>ESP8266HTTPUpdateServer</code> cùng với 2 thư viện khác <code>ESP8266WebServer</code> và <code>ESP8266mDNS</code> cho việc nhận diện ESP8266 trong mạng nội bộ.</p>
</div>
<div class="sect2">
<h3 id="_thực_hiện_2">Thực hiện</h3>
<div class="paragraph">
<p>Mở ví dụ: <code>File &gt; Examples &gt; ESP8266HTTPUpdateServer &gt; WebUpdater</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;WiFiClient.h&gt;
#include &lt;ESP8266WebServer.h&gt;
#include &lt;ESP8266mDNS.h&gt;
#include &lt;ESP8266HTTPUpdateServer.h&gt;

const char* host = "esp8266-webupdate";
const char* ssid = "...";
const char* password = "...";

ESP8266WebServer httpServer(80);
ESP8266HTTPUpdateServer httpUpdater;

void setup(void){

  Serial.begin(115200);
  Serial.println();
  Serial.println("Booting Sketch...");
  WiFi.mode(WIFI_AP_STA);
  WiFi.begin(ssid, password);

  while(WiFi.waitForConnectResult() != WL_CONNECTED){
    WiFi.begin(ssid, password);
    Serial.println("WiFi failed, retrying.");
  }

  MDNS.begin(host);
  httpUpdater.setup(&amp;httpServer);
  httpServer.begin();

  MDNS.addService("http", "tcp", 80);
  Serial.printf("HTTPUpdateServer ready! Open http://%s.local/update in your browser\n", host);
}

void loop(void){
  httpServer.handleClient();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cung cấp đúng SSID và mật khẩu mạng WiFi máy tính bạn đang dùng, nạp Firmware <code>WebUpdater</code> vào ESP8266 <a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a> và <a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Lưu ý là máy tính phải sử dụng mạng WiFi cùng với ESP8266
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Khi bạn không thể truy cập vào module ESP8266 theo công Serial, thì để nhận diện được địa chỉ IP của module trong mạng LAN, bạn cần chạy dịch vụ mDNS trên máy tính. Dịch vụ này sẵn có trong MacOS, tuy nhiên, với Linux thì bạn cần cài đặt Avahi: <a href="https://avahi.org/" class="bare">avahi.org/</a>, còn Windows thì Bonjour: <a href="https://support.apple.com/downloads/bonjour_for_windows" class="bare">support.apple.com/downloads/bonjour_for_windows</a></p>
</div>
<div class="paragraph">
<p>Với dịch vụ mDNS chạy trên máy tính, bạn dễ dàng truy cập vào ESP8266 theo đường dẫn <a href="http://esp8266-webupdate.local/update" class="bare">esp8266-webupdate.local/update</a></p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/web-updater.png" alt="web updater" width="600">
</div>
<div class="title">Hình 69. Giao diện Web cập nhật firmware</div>
</div>
<div class="paragraph">
<p>Bằng cách chọn file và nhấn cập nhật, ESP8266 sẽ tiến hành cập nhật firmware mới do bạn gởi lên. File này có thể được xuất ra bằng cách <code>Sketch &gt; Export compiled Binary</code>, và file .bin sẽ nằm trong thư mục của Sketch</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/export-fw.png" alt="export fw" width="400">
</div>
<div class="title">Hình 70. Xuất file Binary</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Khi đã nhập <a href="http://esp8266-webupdate.local/update" class="bare">esp8266-webupdate.local/update</a> mà không thưc hiện được, hãy thay  esp8266-webupdate với địa chỉ IP của module (bạn có thể xem trong modem/router, hay Serial Terminal). Ví dụ, nếu IP của module là <code>192.168.1.100</code> thì URL phải là <a href="http://192.168.1.100/update" class="bare">192.168.1.100/update</a>. Phương pháp này hữu hiệu trong trường hợp host software cài đặt ở bước 1 không hoạt động.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nếu các bước diễn ra thành công tốt đẹp, thì trên trình duyệt và cửa sổ Serial Terminal (nếu mở) như hình</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/finish.png" alt="finish" width="600">
</div>
<div class="title">Hình 71. Thực hiện thành công cập nhật Firmware sử dụng WebUpdater</div>
</div>
</div>
<div class="sect2">
<h3 id="_bảo_mật_2">Bảo mật</h3>
<div class="paragraph">
<p>Nếu bổ sung WebUpdater vào sản phẩm của mình, dĩ nhiên bạn sẽ không muốn người khác tự do đưa vào thiết bị 1 firmware khác. Hãy sử dụng hàm <code>httpUpdater.setup(&amp;httpServer, update_path, update_username, update_password);</code> với các thông số username, password mà bắt buộc bạn phải nhập đúng mới được phép upload firmware mới.</p>
</div>
<div class="paragraph">
<p>Mở ví dụ : <code>File &gt; Examples &gt; ESP8266HTTPUpdateServer &gt; SecureWebUpdater</code> để xem chi tiết</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_http_server">HTTP Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Với 2 phương pháp trước, bạn dễ dàng cập nhật Firmware thông qua mạng WiFi nội bộ. Tuy nhiên, khi triển khai ứng dụng thực tế, chúng ta sẽ cần cập nhật Firmware từ xa thông qua Internet, và cần 1 Server để lưu trữ firmware, quản lý các phiên bản.</p>
</div>
<div class="paragraph">
<p>Một kịch bản phổ thông thường được làm nhất đó là:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Khi ESP8266 khởi động (khoảng sau 1 khoảng thời gian - ví dụ như 1 ngày), nó sẽ kết nối đến Server, cung cấp thông tin phiên bản hiện có của nó</p>
</li>
<li>
<p>Server khi nhận thấy phiên bản hiện tại cần phải được nâng cấp, nó sẽ trả về firmware mới</p>
</li>
<li>
<p>Nếu phiên bản hiện tại của ESP8266 không cần phải cập nhật, nó sẽ trả về mã 304.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Để thực hiện được điều này, chúng ta cần thực hiện trên cả ESP8266 và trên Server side. Thử nghiệm trong mục này, chúng ta sẽ dùng Node.js làm server. Bạn hoàn toàn có thể thực thi đoạn code Server này và gán cho nó domain để có thể truy cập từ bất kỳ đâu.</p>
</div>
<div class="sect2">
<h3 id="esp8266-ESPhttpUpdate">ESP8266 ESPhttpUpdate</h3>
<div class="paragraph">
<p>Bằng cách thực thi <code>ESPhttpUpdate.update("your-domain.com", 8000, "/fimrware.bin");</code>, ESP8266 sẽ tự động kết nối tới server ở địa chỉ <a href="http://your-domain.com:8000/fimrware.bin" class="bare">your-domain.com:8000/fimrware.bin</a> để tải phiên bản firmware mới về. Mã HTTP Status Code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(Mã) 200: Nếu tồn tại firmware mới, và nội dung file sẽ được gởi kèm sau đó</p>
</li>
<li>
<p>(Mã) 304: Thông báo là không có bản update mới.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Đoạn mã có thể dễ dàng tìm thấy ở <code>File &gt; Examples &gt; ESPhttpUpdate &gt; httpUpdate</code></p>
</div>
<div class="paragraph">
<p>Bạn cần cung cấp SSID, mật khẩu WiFi chính xác, thực hiên <a href="#select-arduino-board">Chọn Board ESP8266 WiFi Uno trong Arduino IDE</a> và <a href="#arduino-flash">Nạp chương trình xuống board dùng Arduino IDE</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#include &lt;Arduino.h&gt;
#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266HTTPClient.h&gt;
#include &lt;ESP8266httpUpdate.h&gt;

const char* ssid = "...";
const char* password = "...";
const char *currentVersion = "1.0"; <i class="conum" data-value="1"></i><b>(1)</b>
const char *serverUrl = "http://192.168.0.106:8000/firmware.bin"; <i class="conum" data-value="2"></i><b>(2)</b>
void setup() {

  Serial.begin(115200);
  Serial.println();
  Serial.println();
  Serial.print("ESP8266 http update, current version: ");
  Serial.println(currentVersion);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  t_httpUpdate_return ret = ESPhttpUpdate.update(serverUrl, currentVersion);
  switch (ret) {
    case HTTP_UPDATE_FAILED:
      Serial.printf("HTTP_UPDATE_FAILD Error (%d): %s", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
      break;

    case HTTP_UPDATE_NO_UPDATES:
      Serial.println("HTTP_UPDATE_NO_UPDATES");
      break;
    case HTTP_UPDATE_OK:
      Serial.println("HTTP_UPDATE_OK");
      break;
  }

}

void loop() {
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Phiên bản firmware của bạn, giả sử bạn thay đổi là <code>2.0</code> và đặt lên server, sau đó bạn đổi lại <code>1.0</code> và nạp vào board</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Đường dẫn đến firmware của bạn, là địa chỉ web, ip, hay domain</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_node_js_ota_server">Node.js OTA Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Khi ESP8266 kết nối tới Web Server, thì nó sẽ cung cấp các thông tin Header để Server căn cứ vào đó đánh giá firmware có cần phải cập nhật hay không. Ví dụ về các header</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">[HTTP_USER_AGENT] =&gt; ESP8266-http-Update
[HTTP_X_ESP8266_STA_MAC] =&gt; 18:FE:AA:AA:AA:AA
[HTTP_X_ESP8266_AP_MAC] =&gt; 1A:FE:AA:AA:AA:AA
[HTTP_X_ESP8266_FREE_SPACE] =&gt; 671744
[HTTP_X_ESP8266_SKETCH_SIZE] =&gt; 373940
[HTTP_X_ESP8266_SKETCH_MD5] =&gt; a56f8ef78a0bebd812f62067daf1408a
[HTTP_X_ESP8266_CHIP_SIZE] =&gt; 4194304
[HTTP_X_ESP8266_SDK_VERSION] =&gt; 1.3.0
[HTTP_X_ESP8266_VERSION] =&gt; 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dựa trên kiến thức phần <a href="#server-nodejs">Server Nodejs</a>, chúng ta xây dựng 1 OTA Server dùng Node.js như sau</p>
</div>
<div class="listingblock">
<div class="title">server.js</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var fs = require('fs');
var url = require('url');
var http = require('http');
var querystring = require('querystring');
var crypto = require('crypto');
// function gửi yêu cầu(response) từ phía server hoặc nhận yêu cầu (request) của client gửi lên
function requestHandler(request, response) {

    // Giả sử địa chỉ yêu cầu firmware http://192.168.1.7:8000/firmware.bin
    var uriData = url.parse(request.url);
    var pathname = uriData.pathname;          // /firmware.bin

    if (pathname == '/firmware.bin') {
        var ver = request.headers['x-esp8266-version'];
        console.log('Client request update, version ', ver);
        if(ver == '1.0') {
            console.log('Send firmware 2.0 to client');
            fs.readFile('./esp8266-firmware-2.0.bin', function(error, content) {
                response.writeHead(200, {
                    'Content-Type': 'binary/octet-stream',
                    'Content-Length': Buffer.byteLength(content),
                    'x-MD5': crypto.createHash('md5').update(content).digest("hex")
                });
                response.end(content);
            });
        } else {
            response.statusCode = 304;
            response.end();
        }
    }
}
var server = http.createServer(requestHandler);
server.listen(8000);
console.log('Server listening on port 8000');</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thực thi <code>node server.js</code> để khởi động Server</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Khi bạn làm việc với các ngôn ngữ lập trình khác, luôn phải đảm bảo khi gởi về client cần có đầy đủ thông tin header <code>Content-Length</code> và <code>x-MD5</code>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Bạn cần file <code>esp8266-firware-2.0.bin</code> ở mục <a href="#esp8266-ESPhttpUpdate">ESP8266 ESPhttpUpdate</a> biên dịch với <code>currentVersion = "2.0"</code> đặt cùng thư mục với file <code>server.js</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nếu bạn thực hiện đầy đủ các bước như trên, kết quả thực thi sẽ như hình</p>
</div>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/08-fota/http-ota.png" alt="http ota" width="600">
</div>
<div class="title">Hình 72. Kết quả thực hiện OTA sử dụng HTTP Server</div>
</div>
</div>
</div>
<h1 id="_cheat_sheet" class="sect0">Cheatsheet</h1>
<div class="openblock partintro">
<div class="content">
Phần này cung cấp thông tin cho việc tra cứu nhanh các hàm có thể sử dụng với Arduino, ESP8266 và ngôn ngữ lập trình C. Có rất nhiều thư viện cho Arduino cung cấp các tính năng hữu ích thông qua các API cho phép người sử dụng gọi, nội dung tóm lược ở đây chỉ đề cập tới các thư viện thường xuyên được sử dụng nhất. Nếu bạn sử dụng các thư viện khác, hoàn toàn có thể tra cứu dễ dàng trong tài liệu sử dụng của thư viện đó. Thông thường các thư viện được phát hành nguồn mở trên <a href="https://github.com">Github</a> sẽ có file <strong>README.md</strong> cung cấp đầy đủ các thông tin.
</div>
</div>
<div class="sect1">
<h2 id="_arduino_esp8266_cheatsheet">Arduino - ESP8266 Cheatsheet</h2>
<div class="sectionbody">
<table class="tableblock frame-none grid-none spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* CẤU TRÚC CƠ BẢN CỦA 1 SKETCH */
void setup() {
  /*
  Hàm được gọi khi bắt đầu sketch. Dùng để khởi tạo
  biến, cấu hình chân, khởi tạo thư viện...
  Code trong setup chỉ chạy 1 lần (khi khởi động hoặc
  reset board)
  */
}
void loop() {
  // Nội dung trong loop() lặp lại liên tục
}

/* LỆNH RẺ NHÁNH */
if (x &lt; 5)      // thực thi code nếu x&lt;5
 { code }
else if (x &gt; 10)// thực thi code nếu x&gt;10
	{ code }
else { code }   // thực thi code các trường hợp còn lại

switch (var) {  // thực thi case có giá trị var
case 1:
...
break;
case 2:
...
break;
default:
...
}

/* CÁC KIỂU VÒNG LẶP */
/* Thực hiện code nếu x&lt;5 */
while (x &lt; 5) { code };
/* Thực hiện code, so sánh, nếu x&lt;0 tiếp tục thực hiện
code */
do { code } while(x &lt; 0);
/* Khởi tạo i, thực hiện code và tăng i nếu i &lt; 10 */
for (int i = 0; i &lt; 10; i++) { code };
/* Thoát ra vòng lặp (for, while, do-while) ngay lập
tức */
break;
/* Đi đến chu kì lặp tiếp theo của vòng lặp hiện tại */
continue;

/* CÁC ĐỊNH NGHĨA VỀ HÀM*/
&lt;ret. type&gt; &lt;name&gt;(&lt;params&gt;) { ... }
int func_name(int x) { return x*2; }
return x; // x phải trùng khớp với kiểủ trả về của hàm
return;   // loại return dành cho hàm void

/* INCLUDE */
/* include thư viện chuẩn */
#include &lt;stdio.h&gt;
/* include thư viện tạo bởi người dùng */
#include "your-library.h"</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* DỮ LIỆU KIỂU CHUỖI */
/* Chuỗi bao gồm kí tự kết thúc chuỗi \0 (null) */
char str1[8] = {'A','r','d','u','i','n','o','\0'};
/* Trình biên dịch tự động thêm kí tự \0 vào cuối
chuỗi */
char str2[8] = {'A','r','d','u','i','n','o'};
/* Khai báo chuỗi ,không khai báo số phần tử và gán giá
trị chuỗi*/
char str3[] = "Arduino";
/* Khai báo và gán giá trị cho chuỗi */
char str4[8] = "Arduino";

/* DỮ LIỆU KIỂU MẢNG */
/* Khai báo mảng kiểu int có 6 phần tử và gán giá trị
cho mỗi phần tử */
int myPins[] = {2, 4, 8, 3, 6};
/* Mảng kiểu int 6 phần tử và không gán giá trị */
int myInts[6];
myInts[0] = 42; // Gán giá trị 42 cho phần tử đầu tiên
myInts[6] = 12; // LỖI ! chỉ số của mảng chỉ từ 0 đến 5

/*Qualifiers*/
static    // Không thay đổi giá trị ở các lần gọi
volatile  // In RAM (Thường dùng trong ngắt)
const     // Không đổi (chỉ đọc)
PROGMEM   /* Cho phép lưu trữ dữ liệu trong bộ nhớ
FLASH thay vì SRAM */

/* CÁC TOẢN TỬ, PHÉP TOÁN THƯỜNG DÙNG */
/* Các toán tử thường dùng */
=   toán tử bằng
+   toán tử cộng
-   toán tử trừ
*   toán tử nhân
/   toán tử chia lấy phần nguyên
%   toán tử chia lấy phần dư
==  phép so sánh bằng
!=  phép so sánh không không bằng (khác)
&lt;   phép so sánh nhỏ hơn
&gt;   phép so sánh lớn hơn
&lt;=  phép so sánh nhỏ hơn hoặc bằng
&gt;=  phép so sánh lớn hơn hoặc bằng
&amp;&amp;  phép toán logic (AND)
||  phép toán logic (OR)
!   phép toán logic (NOT)

/* Các toán tử hợp nhất */
++ tăng 1 đơn vị
-- giảm 1 đơn vị
+= phép toán cộng và gán giá trị
   ex: x = 5; x+= 1; //x = 6
-= phép toán trừ và gán giá trị
   ex: x = 5; x-= 1; //x = 4
*= phép toán nhân và gán giá trị
   ex: x = 5; x*= 3; //x = 15
/= phép toán chia lấy phần nguyên và gán giá trị
   ex: x = 6; x/= 2; //x = 3</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">   ex: x = 6; x/= 2; //x = 3
&amp;= phép toán logic AND và gán giá trị
   ex: x = 0b1010; x&amp;= 0110; //x =0b0010
|= phép toán logic OR và gán giá trị
   ex: x = 0b1010; x&amp;= 0110; //x =0b1110

/* Các toán tử trên bit */
&amp;   and          ^   xor
&lt;&lt;  dịch trái    &gt;&gt;  dịch phảii
|  or           ~   not

/* Thực thi với con trỏ */
&amp;reference:  // lấy địa chỉ của biến mà con trỏ trỏ tới
*dereference:// lấy giá trị của biến mà con trỏ trỏ tới

/* HẰNG SỐ VÀ KIỂU DỮ LIỆU */
123     Số thập phân
0b0111  Số nhị phân
0173    Số Octal - base 8
0x7B    Số thập lục phân base 16
123U    Số nguyên không dấu
123L    Số nguyên có dấu 4 bytes
123UL   Số nguyên không dấu 4bytes
123.0   Số thực
1.23e6  Số thực dùng cơ số mũ ex: 1.23*10^3 = 1230

/*PHẠM VI CỦA KIỂU DỮ LIỆU */
boolean       true | false
char          -128        - 127, 'a' '$' etc.
unsigned char 0           - 255
byte          0           - 255
int           -32768      - 32767
unsigned int  0           - 65535
word          0           - 65535
long          -2147483648 - 2147483647
unsigned long 0           - 4294967295
float         -3.4028e+38 - 3.4028e+38
double        -3.4028e+38 - 3.4028e+38
void          i.e., no return value

/* KHAI BÁO BIẾN */
int       a;
int       a = 0b01111011, b = 0123, c = 1, d;
float     fa = 1.0f;
double    da = 1.0;
char      *pointer;
char      *other_pointer = NULL;

/**
 * BUILT-IN FUNCTIONS
 * Pin Input/Output
 * Digital I/O - pins 0-13 A0-A5
 */
/* Thiết lập cấu hình chân */
pinMode(pin,[INPUT, OUTPUT, INPUT_PULLUP])
/* Đọc giá trị của pin_6 và gán cho a */
int a = digitalRead(pin_6);
/* Cài đặt mức HIGH/LOW cho pin_5 */
digitalWrite(pin_5, [HIGH, LOW])
/* Đọc giá trị của pin và gán cho a, pin từ A0--&gt;A5 */
int a = analogRead(pin)

/* PWM ngõ ra - pins 3 5 6 9 10 11
 * ESP8266: pin 0..16, range = 0..1023, 1KHz default
 */
/* Đặt giá trị PWM cho pin */</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">analogWrite(pin, value)
/* ESP8266: thay đổi RANGE PWM output */
analogWriteRange(new_range)
/* ESP8266: Tần số PWM output */
analogWriteFreq(new_frequency)

/* ADVANCED I/O */
/* Tạo sóng vuông tần số freq_Hz với duty cycle=50% */
tone(pin, freq_Hz)
/* Tạo sóng vuông tần số freq_Hz, duration mili giây */
tone(pin, freq_Hz, duration_ms)
/* Ngừng việc tạo sóng vuông khi dùng tone() */
noTone(pin)
/* Dịch 1 byte, mỗi lần dịch 1 bit, dịch từ bit cao */
shiftOut(dataPin, clockPin,[MSBFIRST, LSBFIRST], value)
/* Trả về (ms) của xung HIGH/LOW trên chân pin */
unsigned long pulseIn(pin,[HIGH, LOW])

/* CHỨC NĂNG NGẮT */
/* Thiết lập chức năng ngắt ở các chân digital */
attachInterrupt(interrupt, func, mode)
/*
interrupt: số ngắt (thường là chân sử dụng chức năng
ngắt)
func : hàm sẽ được gọi khi ngắt xảy ra (lưu ý : hàm
không có tham số đầu vào cũng như kiểu trả về)
mode : gồm các chế độ LOW,CHANGE, RISING, FALLING. Ngắt
sẽ được kích hoạt khi chân ngắt ở mode tương ứng
*/
/* Vô hiệu hóa ngắt interrupt */
detachInterrupt(interrupt)
/* Vô hiệu hóa tấ cả các ngắt */
noInterrupts()
/* Cho phép tái ngắt sau khi dùng noInterrupts() */
interrupts()

/*************************************************
 *            THƯ VIỆN PHỔ BIẾN                 *
 *************************************************/

/*************************************************
 *                     Serial                    *
 *Thư viện giao tiếp với PC hoặc thông qua RX/TX*
 *************************************************/
/* Thiết lập giao tiếp serial-UART với tốc độ speed */
begin(long speed)
/* Vô hiệu hóa giao tiếp serial */
end()
/* Trả về số bytes có sẵn để đọc */
int available()
/* đọc dữ liệu đến từ serial (trả về byte đầu tiên của
dữ liệu từ serial hoặc -1 nếu dữ liệu không có */
int read()
/* Chờ quá trình truyền dữ liệu serial hoàn tất */
flush()
/* In ra serial port dữ liệu data (với bất kì kiểu dữ
liệu nào được thiết lập */
print(data)
/* Tương tự như print(data) nhưng sau khi in ra serial
-port, con trỏ sẽ xuống dòng tiếp theo */
println(data)
/* Gửi dữ liệu value/string/array đến serial port */
write(byte)
/* Hàm được gọi khi có dữ liệu đến từ chân RX */
SerialEvent()</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/*************************************************
 *                  Servo.h                      *
 *     Thư viện hỗ trợ điều khiển động cơ servo *
 *************************************************/
/*
Thiết lập chân kết nối với servo và độ rộng xung
pin : Chân kết nối với servo
[min_uS, max_uS] : Độ rộng xung tính theo us tương ứng
với góc xoay từ 0 đến 180
*/
attach(pin, [min_uS, max_uS])
/* Ghi dữ liệu góc xoay cho động cơ angle từ 0~180 */
write(angle)
/* Viết giá trị để điều khiển góc quay cho servo, giá
trị từ 700 ~ 2300 */
writeMicroseconds(uS)
/* Đọc giá trị góc xoay (0 đến 180 độ) */
int read()
/* Trả về true nếu biến servo đã kết nối đến pin */
bool attached()
/* Gỡ bỏ biến servo ra khỏi chân đã kết nối */
detach()

/*************************************************
 *                       Wire.h                  *
 *               Dùng trong giao tiếp I2C        *
 *************************************************/
 /* Master khởi tạo thư viện Wire với giao tiếp I2C */
begin()
/* Slave tham gia vào kết nối i2C, addr là 7 bits địa
chỉ của slave */
begin(addr)
/*
Master yêu cầu 1 số byte từ slave:
address: 7bits địa chỉ của slave.
count: Số lượng byte master yêu cầu
stop: Kiểu boolean, nếu true, master tín hiệu stop sau
khi yêu cầu và giải phóng bus I2C, nếu false, master
gửi yêu cầu restart để giữ kết nối
*/
requestFrom(address, count, stop)
/* Gửi tín hiệu bắt đầu, truyền dữ liệu đến slave có
địa chỉ addr */
beginTransmission(addr)
/* Gửi dữ liệu (1 byte)đến slave */
send(byte)
/* Gửi dữ liệu (string) đến slave */
send(char * string)
/* Gửi dữ liệu (1 mảng )với số byte là size */
send(byte * data, size)
/* Gửi tín hiệu kết thúc truyền dữ liệu tới slave */
endTransmission()
/* Trả về số byte availabe sau khi đọc bởi read() */
int available()
/* truy xuất đến 1 byte đã truyền từ slave đến master
hoặc truyền ở chiều ngược lại khi nhận được
requestFrom. Trả về byte tiếp theo đã nhận được */
byte receive()
/* Hàm handler sẽ được gọi khi slave nhận dữ liệu */
onReceive(handler)
/* Handler sẽ được gọi khi master yêu cầu dữ liệu */
onRequest(handler)

/*************************************************
 *                    ESP8266                   *
 *************************************************/</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Dùng khi chương trình cần thực thi nhiều tác vụ cùng
một lúc, thư viện hỗ trợ &lt;Scheduler.h&gt; */
void yield();
/* Reset chip ESP */
void ESP.reset();
/* Trả về kích thước vùng nhớ trống ở heap */
uint32_t ESP.getFreeHeap();
/* Trả về ID của chip ESP */
uint32_t ESP.getChipId();

/*  CHẾ ĐỘ CẤU HÌNH WIFI STATION */
/* Thiết lập chế độ station */
WiFi.mode(WIFI_STA);
/* Kết nối đến AP */
WiFi.begin(ssid, password);
/* Ngắt kết nối đến network wifi hiện tại */
bool WiFi.disconnect();
/* Trả về địa chỉ IP của station */
WiFi.localIP();
/* Trả về trạng thái khi kết nối đến AP */
WiFi.status();
/* Trả về tên của netwwork WiFi đã kết nối */
WiFi.SSID();
/* Trả về cường độ của WiFi (đơn vị dBm) */
WiFi.RSSI();
/* Bắt đầu thiết lập chế độ WPS */
WiFi.beginWPSConfig();
/* Bắt đầu thiết lập chế độ smart config */
WiFi.beginSmartConfig();

/* CHẾ ĐỘ CẤU HÌNH WIFI SOFT ACCESS POINT (AP) */
/* Khởi tạo 1 AP với tên và password */
WiFi.softAP(ssid, password);
/* Khởi tạo 1 AP và thiết lập cấu hình cho AP gồm địa
chỉ IP, gateway và subnet */
WiFi.softAPConfig (local_ip, gateway, subnet);
/* Trả về số station đã kết nối đến AP */
WiFi.softAPgetStationNum();
/* Ngắt kết nối của các station */
WiFi.softAPdisconnect(wifioff);
/* Trả về địa chỉ IP của AP */
WiFi.softAPIP();
/* Trả về địa chỉ MAC của AP */
WiFi.softAPmacAddress(mac);

/* WIFI FEATURES */
/* SCAN */
/* Thiết lập chế độ Station */
WiFi.mode(WIFI_STA);
/* Scan và trả về số lượng network avalable */
WiFi.scanNetworks();
/* Trả về tên của network (kiểu string) ở vị trí num */
WiFi.SSID(num).c_str();
/* Trả về thông tin của tất cả các network */
WiFi.getNetworkInfo(networkItem,&amp;ssid,
&amp;encryptionType, &amp;RSSI,*&amp;BSSID, &amp;channel, &amp;isHidden)

/* DIAGNOSTICS */
/*
* Mục đích : chuẩn đoán, cung cấp thông tin và khắc
* phục sự cố khi không kết nối đến net work WiFi
*/
/* In ra serial các chuẩn đoán thông tin của network */
WiFi.printDiag(Serial);
/* Enable chế độ debug */
Serial.setDebugOutput(true);</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* WEBSERVER */
/* Máy chủ TCP tại port 80 sẽ phản hồi các HTTP request
được gửi lên từ client */
ESP8266WebServer server (80);
/* Server bắt đầu lắng nghe các client */
server.begin();
/* Viết dữ liệu đến các client */
server.write(buf, len)
/* Khởi tạo server ở địa chỉ URL, handleRoot là nội
dung hoặc hàm sẽ thực hiện */
server.on ( "URL", handleRoot );
/* Server tương tác với client để gửi, nhận dữ liệu */
server.handleClient();
/* Trả về 1 nếu biến val có tồn tại trên server */
server.hasArg(val)
/* Lấy giá trị của biến val trên server */
server.arg(val);
/* Gửi yêu cầu cập nhật dữ liệu từ server:
code : HTTP code
text/html : Định dạng trả về là file HTML
content: Nội dung sẽ trả về từ phía server */
server.send (code, "text/html",content);

/* MQTT */
/*
Các thư viện hỗ trợ giao thức MQTT dành cho ESP8266
trên arduino thường sử dụng là ESP8266MQTTClient
và PubSubClient. Phần này giải thích các hàm của các
thư viện
*/
/* Các hàm của thư viện ESP8266MQTTClient*/
/* Khai báo 1 biến mqtt thuộc class MQTTClient */
MQTTClient mqtt;
/* Lấy dữ liệu nhận được từ topic đã subcribe */
mqtt.onData([](String topic, String data, bool cont)
/* Hủy subcribe topic /qos0 */</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">mqtt.unSubscribe("/qos0");
/* Thực hiện subscribe topic và publish các message */
mqtt.onSubscribe([](int sub_id)
/* Publish 1 message "qos0" đến topic /qos0 với QoS =0,
và Retain = 0 */
mqtt.publish("/qos0", "qos0", 0, 0);
/* Kết nối đến server MQTT */
mqtt.onConnect([]()
/* Subscribe topic và nhận message tại topic /qos0 */
mqtt.subscribe("/qos0", 0)
/* Bắt đầu truyền nhận dữ liệu với broker MQTT có url
mqtt://test.mosquitto.org tại port 1883 */
mqtt.begin("mqtt://test.mosquitto.org:1883")
/* Hàm được gọi trong loop() nhằm khởi tạo MQTT, kiểm
tra xử lí các dữ liệu từ các topic, kiểm tra các thuộc
tính của giao thức như gói keep-a-live, QoS... */
mqtt.handle();

/* Các hàm của thư viện PubSubClient*/
/* Khai báo biến espClient thuộc đối tượng client trong
class PubSubClient */
PubSubClient client(espClient);
/* Publish gói tin "Connected!" đến topic ESP8266 */
client.publish("ESP8266", "Connected!");
/* Subscribe để nhận các message từ topic ESP8266 */
client.subscribe("ESP8266");
/* Cài đặt server lắng nghe client ở port 1883 */
client.setServer(url_server, 1883);
/* Gọi hàm callback để thực hiện các chức năng
publish/subcribe */
client.setCallback(callback);
/* Hàm được gọi trong loop() nhằm khởi tạo MQTT, kiểm tra
xử lí các dữ liệu từ các topic, kiểm tra các thuộc tính
của giao thức như gói keep-a-live, gói tin QoS... */
client.loop();</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_c_cheatsheet">C - Cheatsheet</h2>
<div class="sectionbody">
<table class="tableblock frame-none grid-none spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* CẤU TRÚC CƠ BẢN */
Viết chú thích trên 1 dòng dùng //
      ex: x++ ; // tăng x 1 đơn vị
/* */ Viết chú thích trên nhiều dòng.
ex : /*************************
      * Chú thích được viết   *
      *    trên nhiều dòng    *
      ************************/
/* CẤU TRÚC 1 CHƯƠNG TRÌNH */
#include &lt;stdio.h&gt;//include thư viện chuẩn của C
#include "iLib.h" //include thư viện tạo bởi người dùng
int global_var;   //biến được dùng  trong chương trình
/* Khai báo hàm bắt đầu của 1 chương trình C với kiểu
trả về là integer. Đối số arg kiểu int được truyền vào
hàm */
int main (int arg){
 float local_var ; // Biến chỉ được dùng trong hàm main
 Lệnh 1
 ...
 Lệnh n ;
return 0; //chương trình thực hiện thành công và thoát
}

/*KIỂU DỮ LIỆU VÀ PHẠM VI */
boolean       true | false
char          -128         -  127, 'a' '$' etc.
unsigned char 0            -  255
byte          0            -  255
int           -32768       -  32767
unsigned int  0            -  65535
word          0            -  65535
long          -2147483648  -  2147483647
unsigned long 0            -  4294967295
float         -3.4028e+38  -  3.4028e+38
double        -3.4028e+38  -  3.4028e+38
void          i.e., no return value

/* ĐẶT TÊN BIẾN */
/* Đặt tên đúng */
int x;            // Một biến
int x = 1;        // Biến được khai báo và khởi tạo
float x, y, z;    // Nhiều biến cùng kiểu dữ liệu
const int x = 88; // Biễn tĩnh, không ghi được
int tenBien1ok;   // Đặt tên biến này đúng
int ten_bien_nay_ok;
/* Đặt tên sai */
int 2001_tensai;  // Vì số ở đầu
int ten-sai;      // Dấu '-' không phải là alphanumberic
int while;        // Sai, vì dùng từ khóa vòng lặp while

/* HẰNG SỐ VÀ KIỂU DỮ LIỆU */
123      Số thập phân
0b0111   Số nhị phân
0173     Số Octal - base 8
0x7B     Số thập lục phân base 16
123U     Số nguyên không dấu</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">123L     Số nguyên có dấu 4 bytes
123UL    Số nguyên không dấu 4bytes
123.0    Số thực
1.23e6   Số thực dùng cơ số mũ ex: 1.23*10^3 = 1230
/* định nghĩa hằng số a kiểu nguyên, có giá trị là 1 */
const int a = 1;
/* Định nghĩa hằng số x kiểu thực, có giá trị là 4.0 */
const float x = 4;
/* Định nghĩa hằng số c kiểu integer có giá trị 49 */
const c = ‘1’; // Kí tự 1 trong mã ASCII là 49
/* Định nghĩa str là hằng số kiểu con trỏ, trỏ tới
chuỗi “Cheasheet C” */
const char * str = “Cheasheet C”;

/* KHAI BÁO BIẾN */
/* Khai báo biến a kiểu nguyên và không gán giá trị */
int a;
/* khai báo a kiểu binary, b kiểu base8, c kiểu số
nguyên, d kiểu số nguyên và không gán giá trị */
int a = 0b01111011, b = 0123, c = 1, d;
/* Khai báo biến fa thuộc kiểu số thực float */
float fa = 1.0f;
/* Khai báo biến da thuộc kiểu số thực double */
double da = 1.0;
/* Khai báo biến con trỏ và trỏ đến 1 vùng nhớ không
xác định */
char *pointer;
/* Khai báo biến con trỏ và trỏ về NULL (0)*/
char *other_pointer = NULL;

/* CHUỖI KÍ TỰ */
/* Chuỗi bao gồm kí tự kết thúc chuỗi \0 (null) */
char str1[8] = {'A','r','d','u','i','n','o','\0'};
/* Trình biên dịch tự động thêm kí tự \0 vào cuối
chuỗi */
char str2[8] = {'A','r','d','u','i','n','o'};
/* Khai báo chuỗi ,không khai báo số phần tử và gán giá
trị chuỗi */
char str3[] = "Arduino";
/* Khai báo và gán giá trị cho chuỗi */
char str4[8] = "Arduino";

/* Các hàm xử lí chuỗi thường dùng */
/* Nối các kí tự từ chuỗi source tiếp vào vị trí cuối
của chuỗi dest */
strcat(dest, source)
/* Tìm vị trí xuất hiện đầu tiên của kí tự c trong
source, trả về con trỏ chỉ tới vị trí đó hoặc null nếu
không tìm thấy c trong source */
strchr(source, c)
/* Hàm trả về độ dài của chuỗi st */
strlen(st)
/* copy và thay các kí tự của chuỗi soure vào dest */
strcpy(dest, source)
/* chép kí tự từ đầu đến n từ chuỗi source vào dest */
strncpy(dest, source, n)</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* MẢNG */
/* Khai báo mảng 1 chiều 6 phần tử kiểu integer và gán
giá trị cho mỗi phần tử */
int myPins[] = {2, 4, 8, 3, 6};
/* Khai báo mảng 1 chiều 6 phần tử kiểu integer và
không gán giá trị */
int myInts[6];
myInts[0] = 42; // Gán giá trị 42 cho phần tử đầu tiên
myInts[6] = 12; // LỖI ! chỉ số của mảng chỉ từ 0 đến 5
/* Lấy giá trị của phần tử thứ 3 trong mảng myInts */
int c = myInts[2]; // Có thể dùng *(myInts + 2)
/* Lấy địa chỉ của phần tử thứ 3 trong mảng myInts */
int c = &amp;myInts[2]; // Có thể dùng int c = myInts + int
/* Trả về chiều dài của mảng myInts */
int length = sizeof(myInts) / sizeof(myInts[0]);
/* Khai báo 2 mảng kiểu float, arr1 có 5 phần tử, arr2
có 10 phần tử */
float arr1[5], arr2[10];
/* Khai báo mảng số nguyên arr có 2 dòng, 5 cột. Tổng
cộng có 10 phần tử */
int a[2][5];

/* KHỐI LỆNH VÀ CÁC LỆNH DÙNG TRONG VÒNG LẶP */
{} // bao gồm nhiều lệnh, thường được sử dụng trong hàm
/* Goto : chương trình sẽ nhảy đến nhãn (nhãn phải có
mặt trong câu lệnh chứa goto) */
goto nhãn;
/* Continue : Chỉ dùng trong các lệnh có vòng lặp sẽ
chuyển qua chu kì mới của vòng lặp trong cùng nhất */
continue; /*
/* Break : Dùng với các vòng lặp thoát khỏi vòng lặp
trong cùng nhất, hoặc dùng trong cấu trúc switch..case
để thoát ra khỏi case tương ứng */
break; /*
/* Return */
/* Dùng cho hàm không có kiểu trả về (void) */
return;
/* Value có thể là hằng số, biến, biểu thức hoặc gọi
đến 1 hàm khác để trả về giá trị */
return &lt;value&gt;;

/* LỆNH RẺ NHÁNH */
if (x &lt; 5)      // thực thi code nếu x&lt;5
 { code }
else if (x &gt; 10)// thực thi code nếu x&gt;10
	{ code }
else { code }   // thực thi code các trường hợp còn lại

switch (var) {  // thực thi case có giá trị var
case 1:
...
break;
case 2:
...
break;
default:
...
}

/* CÁC KIỂU VÒNG LẶP */
/* While: Thực hiện code nếu x&lt;5 */
while (x &lt; 5) { code };
/* Do-While : Thực hiện code, so sánh, nếu x&lt;0 tiếp tục
thực hiện code */
do { code } while(x &lt; 0);</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* for : Khởi tạo và gán giá trị cho i, thực hiện code
tăng i nếu i &lt; 10 */
for (int i = 0; i &lt; 10; i++) { code };

/* PHÉP TOÁN VÀ TOÁN TỬ THƯỜNG DÙNG
/* Các toán tử thường dùng */
=   toán tử bằng
+   toán tử cộng
-   toán tử trừ
*   toán tử nhân
/   toán tử chia lấy phần nguyên
%   toán tử chia lấy phần dư
==  phép so sánh bằng
!=  phép so sánh không không bằng (khác)
&lt;   phép so sánh nhỏ hơn
&gt;   phép so sánh lớn hơn
&lt;=  phép so sánh nhỏ hơn hoặc bằng
&gt;=  phép so sánh lớn hơn hoặc bằng
&amp;&amp;  phép toán logic (AND)
||  phép toán logic (OR)
!   phép toán logic (NOT)

/* Các toán tử hợp nhất */
++   tăng 1 đơn vị
--   giảm 1 đơn vị
+=   phép toán cộng và gán giá trị
     ex: x = 5; x+= 1; //x = 6
-=   phép toán trừ và gán giá trị
     ex: x = 5; x-= 1; //x = 4
*=   phép toán nhân và gán giá trị
     ex: x = 5; x*= 3; //x = 15
/=   phép toán chia lấy phần nguyên và gán giá trị
     ex: x = 6; x/= 2; //x = 3
&amp;=   phép toán logic AND và gán giá trị
     ex: x = 0b1010; x&amp;= 0110; //x =0b0010
|=   phép toán logic OR và gán giá trị
     ex: x = 0b1010; x&amp;= 0110; //x =0b1110

/* Các toán tử trên bit */
&amp;   and          ^   xor
&lt;&lt;  dịch trái    &gt;&gt;  dịch phảii
|  or           ~   not

/* THỰC THI VỚI CON TRỎ */
&amp;reference:  // lấy địa chỉ của biến mà con trỏ trỏ tới
*dereference:// lấy giá trị của biến mà con trỏ trỏ tới
/* khai báo biến con trỏ kiểu int trỏ tới địa chỉ của
biến a */
int a = 5; int *pointer = &amp;a;

/* CÁC KÍ TỰ ĐIỀU KHIỂN VÀ KÍ TỰ ĐẶC BIỆT */
\n  Nhảy xuống dòng kế tiếp canh về cột đầu tiên
\t  Canh cột tab ngang.
\r  Nhảy về đầu hàng, không xuống hàng.
\a  Tiếng kêu bip.
\\  In ra dấu \
\"  In ra dấu "
\'  In ra dấu '
%%: In ra dấu %
\b ~ backspace (xóa 1 ký tự ngay trước)

/* HÀM VÀ CÁC VẤN ĐỀ LIÊN QUAN */
/* Khai báo prototype của hàm max, có 2 đối số đầu vào
là a và b thuộc kiểu số nguyên, kết quả trả về của hàm
kiểu số nguyên */
int max(int a, int b);</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">/* Khai báo biến c là giá trị trả về của hàm max */
int c = max(5,4);
/* Khai báo prototype của hàm không có đối số và không
có kiểu trả về (void) */
void none();

/* TYPEDEF- Định nghĩa kiểu dữ liệu */
/* Định nghĩa kiểu unsigned char là BYTE, khai báo các
biến a, b thuộc kiểu BYTE */
typedef unsigned char BYTE;  BYTE  a, b;

/* KIỂU LIỆT KÊ - ENUMERATION (enum) */
/* khai báo kiểu dữ liệu enum là các ngày trong tuần */
enum daysOfWeek { sunday, monday, tuesday, wednesday };
/* Tạo biến toDay thuộc daysOfWeek và gán giá trị */
daysOfWeek toDay = wednesday;

/* STRUCT - KIỂU DỮ LIỆU DO NGƯỜI DÙNG ĐỊNH NGHĨA */
/* Khai báo struct sinhVien */
struct sinhVien{
  char tenSinhVien;
  char MSSinhVien;
  int tuoiSinhVien;
};
/* Truy xuất đến thành phần MSSinhVien trong struct
sinhVien */
sinhVien.MSSinhVien;
/* Đổi tên struct sinhVien thành 1 biến duy nhất là</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">SINHVIEN */
typedef struct sinhVien SINHVIEN;
/* Khai báo biến sinhVienA thuộc struct SINHVIEN */
SINHVIEN sinhVienA;

/* CÁC LỆNH XỬ LÝ TẬP TIN (#include &lt;stdio.h&gt;) */
/* Khai báo 1 biến con trỏ là đường dẫn của 1 file */
const char *filePath = "Đường/dẫn/file/document.txt";
/* Tạo 1 biến con trỏ thuộc kiểu FILE */
FILE *file;
/* Mở 1 file ở đường dẫn filePath và đọc dữ liệu */
file = fopen(filePath, "r");// Trả về NULL nếu thất bại
/* Đóng 1 file đã mở, trả về 0 nếu thành công , ngược
lại trả về EOF */
fclose(file);
/* Viết kí tự c lên file đang mở, trả về EOF nếu ghi
thất bại, trả về mã ASCII của c nếu thành công */
int fputc(int c, FILE *f);
/* Viết chuỗi "hello" lên file đang mở */
int c = fputs("hello", file);
/* Đọc (255-1) kí tự từ file đang mở, kết quả đọc được
sẽ lưu vào mảng str, việc đọc bị dừng nếu gặp kí tự
'\n' hoặc EOL */
fgets(str, 255, file);
/* Thay đổi vị trí trỏ đến trong file của con trỏ
internal file position indicator về lại đầu file */
int fseek(file, 0, SEEK_SET);
/* Trả về kích thước của nội dung có trong file */
ftell(file);</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="https://www.cheatography.com/ashlyn-black/cheat-sheets/c-reference/" class="bare">www.cheatography.com/ashlyn-black/cheat-sheets/c-reference/</a></p>
</div>
</div>
</div>
<h1 id="_contributors" class="sect0">Lời kết</h1>
<div class="sect2">
<h3 id="_các_thành_viên_tham_gia_đóng_góp">Các thành viên tham gia đóng góp.</h3>
<div class="paragraph">
<p>Để hoàn thiện nội dung của sách còn có sự đóng góp của các thành viên sau:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. <strong>Phạm Minh Tuấn (TuanPM)</strong> - Chủ biên</p>
</li>
<li>
<p>2. <strong>Lâm Nhật Quân</strong> - Kĩ sư làm việc tại IoT Maker Việt Nam.</p>
</li>
<li>
<p>3. <strong>Trịnh Hoàng Đức</strong> - Kĩ sư làm việc tại IoT Maker Việt Nam.</p>
</li>
<li>
<p>4. <strong>Lê Phương Trình</strong> - Thực tập sinh tại IoT Maker Việt Nam - Sinh viên Đại Học Bách Khoa, chuyên ngành điện tử viễn thông, khóa học 2014.</p>
</li>
<li>
<p>5. <strong>Trần Phúc Vinh</strong> - Thực tập sinh tại IoT Maker Việt Nam - Sinh viên Đại Học Bách Khoa, chuyên ngành kĩ thuật điện, khóa học 2014.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Và sử đóng góp của cộng đồng tại tại <a href="https://arduino.esp8266.vn" class="bare">arduino.esp8266.vn</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_lời_kết">Lời kết.</h3>
<div class="paragraph">
<p>Thật vui khi bạn đã đồng hành cùng chúng tôi đi đến hết cuốn sách này. Mục đích của cuốn sách là giúp những người mới bắt đầu tìm hiểu về <code>Internet Of Things (IoT)</code> có kiến thức cơ bản và hướng đi chính xác để nghiên cứu về IoT một cách nhanh chóng hơn. Hi vọng cuốn sách sẽ đến tay thật nhiều bạn đam mê lĩnh vực công nghệ còn mới mẻ nhưng rất tiềm năng này. Chúc các bạn thành công trên con đường mà mình đã chọn.</p>
</div>
<div class="paragraph">
<p>Mặc dù đã cố gắng để hoàn thành tốt nhất nội dung cho cuốn sách, tuy nhiên vẫn không tránh khỏi những thiếu sót. Mọi ý kiến đóng góp xin gửi mail về địa chỉ <a href="mailto:support@iotmaker.vn">support@iotmaker.vn</a></p>
</div>
<div class="paragraph">
<p>Ngoài ra các bạn có thể tương tác với chúng tôi qua 1 số địa chỉ:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. Webstore : <a href="https://iotmaker.vn/" class="bare">iotmaker.vn/</a></p>
</li>
<li>
<p>2. Facebook : <a href="https://www.facebook.com/iotmaker.vn/" class="bare">www.facebook.com/iotmaker.vn/</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Một số trang web đóng góp cho cộng đồng (mong nhận được sự chia sẻ và đóng góp của các bạn để cộng đồng IoT Việt Nam nói riêng cũng như cộng đồng kĩ thuật Việt Nam nói chung ngày một phát triển hơn):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. Về ESP8266 với Arduino : <a href="https://arduino.esp8266.vn/" class="bare">arduino.esp8266.vn/</a></p>
</li>
<li>
<p>2. Về ESP32 : <a href="https://esp32.vn" class="bare">esp32.vn</a></p>
</li>
<li>
<p>3. Facebook Group: <a href="https://www.facebook.com/groups/iotmaker/" class="bare">www.facebook.com/groups/iotmaker/</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_giấy_phép_sử_dụng_tài_liệu">Giấy phép sử dụng tài liệu.</h3>
<div class="imageblock center" style="text-align: center">
<div class="content">
<img src="images/contributions/Cc-by-nc-sa_icon.svg" alt="Cc by nc sa icon" width="200">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Tài liệu tuân theo giấy phép CC-BY-NC-SA (<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode" class="bare">creativecommons.org/licenses/by-nc-sa/4.0/legalcode</a>)</p>
</li>
<li>
<p>Bản quyền toàn bộ tài liệu này thuộc về <a href="https://iotmaker.vn">IoT Maker Việt Nam</a>, bạn được miễn phí sử dụng cho mục đích cá nhân, học tập và sử dụng trong các dự án của mình, không được sử dụng cho mục đích thương mại. Nếu bạn muốn sửa chữa, phân phối lại, bạn bắt buộc phải giữ nguyên giấy phép và cần có sự đồng ý của <a href="https://iotmaker.vn">IoT Maker Việt Nam</a>.</p>
</li>
<li>
<p>Chỉ duy nhất các các nhân, tổ chức được liệt kê tại <a href="http://iota.edu.vn" class="bare">iota.edu.vn</a> là được phép sử dụng tài liệu cho mục đích thương mại.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-10-02 09:56:15 +07
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>